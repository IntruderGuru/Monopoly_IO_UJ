C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\Main.py
import os
import pygame
from model.gra import Gra
from view.kontroler_wiadomosci import KontrolerWiadomosci
from controller.menu import Menu


class Main:
    _SEC_TO_MS = 1000
    _background_color = pygame.color.THECOLORS["white"]

    def __init__(self):
        pygame.init()  # Inicjalizacja pygame
        pygame.font.init()  # Inicjalizacja modułu fontów

        os.environ["SDL_VIDEO_CENTERED"] = "1"

        self.font = pygame.font.Font(None, 20)

        pygame.display.set_caption("Monopoly")
        self._screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        self._screen_info = pygame.display.Info()
        self._screen_width = self._screen_info.current_w
        self._screen_height = self._screen_info.current_h

        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font)
        self._gra = None  # Gra(self._screen, self._kontroler_wiadomosci)
        self._clock = pygame.time.Clock()
        self._running = True
        self._delta_time = 0
        self.input_text = ""
        # self.messages = []
        self.menu = Menu()

    def __del__(self):
        pygame.quit()
        # del self._gra

    def start(self):
        self._kontroler_wiadomosci.dodaj_wiadomosc("Witaj w UJpoly!")
        while self.menu.stan != "stop":
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self._running = False
                self.menu.handle_event(event)

            self._screen.fill((255, 255, 255))
            if self.menu.stan != "stop":
                self.menu.draw(self._screen)
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Wprowadź liczbę graczy między (2-5) :"
                )
                self._gra = Gra(
                    self._screen,
                    self._kontroler_wiadomosci,
                    self.menu.liczba_graczy,
                    self.menu.gracze,
                )
                self._petla_gry()

            pygame.display.flip()

    def _petla_gry(self):
        while self._running:
            self._aktualizuj_delta_time()
            self._petla_zdarzen(pygame.event.get())
            self._aktualizuj(delta_time=self._delta_time)
            self._wyswietlaj()

    def _aktualizuj_delta_time(self):
        self._clock.tick(60)
        self._delta_time = self._clock.get_time() / Main._SEC_TO_MS

    def _petla_zdarzen(self, events_list):
        for event in events_list:
            if event.type == pygame.QUIT:
                self._running = False
                break
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    self.process_input(self.input_text)
                    self.input_text = ""
                elif event.key == pygame.K_BACKSPACE:
                    self.input_text = self.input_text[:-1]
                else:
                    self.input_text += event.unicode
            elif event.type == pygame.VIDEORESIZE:
                self._screen_width = event.w
                self._screen_height = event.h
                self._gra.aktualna_szerokosc_ekranu = self._screen_width
                self._gra.aktualna_wysokosc_ekranu = self._screen_height

            self._gra.aktualizacja_zdarzenia(event)

    def _aktualizuj(self, delta_time):
        _delta_time = delta_time
        self._gra.aktualizacja()

    def render_text(self, text, pos):
        text_surface = self.font.render(text, True, (0, 0, 0))
        self._screen.blit(text_surface, pos)

    def _wyswietlaj(self):
        self._screen.fill(Main._background_color)

        # Wyświetlanie komunikatów z prawej strony
        # y_offset = 10
        # for message in self.messages[-15:]:  # Wyświetla ostatnie 15 komunikatów
        #     self.render_text(message, (self._screen_width - 400, y_offset))
        #     y_offset += 40

        self._kontroler_wiadomosci.wyswietl(self._screen, self._screen_width)

        # Wyświetlanie pola tekstowego
        self.render_text(
            self.input_text, (self._screen_width - 400, self._screen_height - 50)
        )

        self._gra.wyswietl()

        pygame.display.update()

    def process_input(self, input_text):
        self._kontroler_wiadomosci.dodaj_wiadomosc(f"Wprowadzono: {input_text}")
        if input_text.isdigit():
            liczba_graczy = int(input_text)
            if liczba_graczy >= 2 and liczba_graczy <= 5:
                self._gra._liczba_graczy = liczba_graczy
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"Ustaw liczbe graczy na {liczba_graczy}"
                )
                self._gra.przygotuj_graczy()
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Naciśnij spację, aby rzucić kostką"
                )
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Nieprawidłowa liczba graczy."
                )
        else:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Nieznana komenda: {input_text}"
            )


if __name__ == "__main__":
    game_runner = Main()
    game_runner.start()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\searcher.py
import os
from pathlib import Path


def get_all_python_files(directory):
    python_files = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".py"):
                python_files.append(Path(root) / file)
    return python_files


def save_files_content_to_text(python_files, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for file in python_files:
            with open(file, "r", encoding="utf-8") as py_file:
                content = py_file.read()
                f.write(f"{file}\n{content}\n\n")


def main():
    directory = "C:/Users/barte/OneDrive/Pulpit/Studia/ROK II/Semestr 4/IO/ProjektFUN/Monopoly_IO_UJ"  # Zmień na właściwą ścieżkę do katalogu
    output_file = "output.txt"

    python_files = get_all_python_files(directory)
    save_files_content_to_text(python_files, output_file)
    print(f"Zapisano zawartość {len(python_files)} plików .py do {output_file}")


if __name__ == "__main__":
    main()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\controller\menu.py
import pygame


class Menu:
    def __init__(self):
        self.stan = "liczba_graczy"
        self.liczba_graczy = 0
        self.gracze = []
        self.font = pygame.font.Font(None, 32)

    def handle_event(self, event):
        if event.type == pygame.KEYDOWN:
            if self.stan == "liczba_graczy":
                if pygame.K_2 <= event.key <= pygame.K_5:
                    self.liczba_graczy = event.key - pygame.K_0
                    self.stan = "nazwy_graczy"
                    self.gracze.append("")
            elif self.stan == "nazwy_graczy":
                if event.key == pygame.K_RETURN:
                    if len(self.gracze) < self.liczba_graczy:
                        self.gracze.append("")
                    else:
                        self.stan = "stop"
                elif event.key == pygame.K_BACKSPACE:
                    self.gracze[-1] = self.gracze[-1][:-1]
                else:
                    self.gracze[-1] += event.unicode

    def draw(self, screen):
        if self.stan == "liczba_graczy":
            text = self.font.render("Wprowadź liczbę graczy", True, (0, 0, 0))
        elif self.stan == "nazwy_graczy":
            text = self.font.render(
                "Wprowadź nazwę gracza " + str(len(self.gracze)),
                True,
                (0, 0, 0),
            )
        screen.blit(text, (50, 50))


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\controller\__init__.py
# monopoly/controller/__init__.py
from .menu import Menu

# from .game_controller import GameController


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\gra.py
import random
import pygame
from typing import List

from view.okna.okno_akcji_pola import OknoBazowe, OknoAkcjiPola
from view.okna.okno_nieruchomosci import OknoNieruchomosci
from view.okna.okno_kart import OknoKart
from view.okna.okno_zastawu import OknoZastawu
from view.okna.okno_zagadek import OknoZagadek
from view.okna.okno_wiezienia import OknoWiezienia
from model.plansza import Plansza
from model.pole import *
from view.pionek import Pionek
from model.gracz import Gracz
from model.posiadlosc import Posiadlosc
from view.kontroler_wiadomosci import KontrolerWiadomosci


KWOTA_POCZATKOWA = 10000
MIN_LICZBA_GRACZY = 2
MAX_LICZBA_GRACZY = 5
LICZBA_POL = 40


# Dodajemy listę kolorów dla pionków jako obiekty pygame.Color
PIECE_COLORS: List[pygame.Color] = [
    pygame.Color("red"),
    pygame.Color("green"),
    pygame.Color("blue"),
    pygame.Color("yellow"),
    pygame.Color("purple"),
]


class StosOtwartychOkien:
    def __init__(self):
        self.stos: list[OknoBazowe] = list()
        self.rozmiar_stosu = 0

    def dodaj(self, okno: OknoBazowe):
        self.stos.append(okno)
        self.rozmiar_stosu += 1

    def usun(self):
        if self.rozmiar_stosu > 0:
            self.stos.pop()
            self.rozmiar_stosu -= 1

    def gora(self):
        return self.stos[self.rozmiar_stosu - 1]

    def czy_pusty(self):
        return self.rozmiar_stosu == 0

    def aktualizacja(self):
        if not self.czy_pusty():
            self.gora().aktualizacja()

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if not self.czy_pusty():
            self.gora().aktualizacja_zdarzen(event)

    def wyswietl(self, okno: pygame.Surface):
        if not self.czy_pusty():
            self.gora().wyswietl(okno)


class Gra:
    def __init__(
        self,
        glowne_okno: pygame.Surface,
        kontroler_wiadomosci: KontrolerWiadomosci,
        liczba_graczy: int,
        gracze: list[str],
    ):
        self._glowne_okno: pygame.Surface = glowne_okno
        self._gracze = [
            Gracz(name, KWOTA_POCZATKOWA, Pionek(0, PIECE_COLORS[i], "path"))
            for i, name in enumerate(gracze)
        ]
        self._plansza: Plansza = Plansza()
        self._kwota_poczatkowa = KWOTA_POCZATKOWA
        self._liczba_graczy = liczba_graczy
        self._suma_oczek = 0
        self._kolejny_rzut_kostka = False
        self._aktualny_gracz = 1
        self.messages = []
        self.aktualna_szerokosc_ekranu = 1200
        self.aktualna_wysokosc_ekranu = 800
        self.kontroler_wiadomosci = kontroler_wiadomosci

        # sekcja wizualna
        self.kolor_przycisku = (70, 70, 70)
        self.kolor_gdy_kursor = (150, 150, 150)
        self.kolor_tekstu = (200, 200, 200)

        # sekcja okien
        self._plansza = Plansza()

        self._stos_otwartych_okien = StosOtwartychOkien()
        self.akcja_pola_okno = OknoAkcjiPola(self)
        self.akcja_nieruchomosci_okno = OknoNieruchomosci(self)
        self.akcja_kart_okno = OknoKart(self)
        self.akcja_zastaw_okno = OknoZastawu(self)
        self.akcja_zagadek_okno = OknoZagadek(self)
        self.akcja_wiezienie_okno = OknoWiezienia(self)
        self.czy_akcja_zakonczona = True

    def przygotuj_graczy(self):
        self.kontroler_wiadomosci.dodaj_wiadomosc(
            f"Liczba graczy: {self._liczba_graczy}"
        )
        for i in range(1, self._liczba_graczy + 1):
            pionek = Pionek(0, PIECE_COLORS[i - 1], "path")
            gracz = Gracz(i, self._kwota_poczatkowa, pionek)
            gracz.pozycja = 0
            self._gracze.append(gracz)
            color = PIECE_COLORS[i - 1]
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {i} gotowy z pionkiem w kolorze {color.r}, {color.g}, {color.b}"
            )

    def wybierz_kolejnego_gracza(self):
        self._suma_oczek = 0
        poczatkowy_gracz = self._aktualny_gracz

        while True:
            if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
                self._czy_gracz_ma_ture = True
                break
            else:
                self._gracze[self._aktualny_gracz - 1].odczekajJednaTure()
                if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
                    self.kontroler_wiadomosci.dodaj_wiadomosc(
                        f"Gracz {self._aktualny_gracz} opuszcza więzienie po dwóch turach"
                    )
                self._aktualny_gracz = (self._aktualny_gracz % self._liczba_graczy) + 1
                self._suma_oczek = 0
                if self._aktualny_gracz == poczatkowy_gracz:
                    self.kontroler_wiadomosci.dodaj_wiadomosc(
                        "Wszyscy gracze są w więzieniu. Przechodzimy do następnej tury."
                    )
                    break

    def analizuj_rzut(self, kostka_pierwsza, kostka_druga):
        if kostka_pierwsza + kostka_druga == 7:
            self._kolejny_rzut_kostka = True
            self.kontroler_wiadomosci.dodaj_wiadomosc("Siódemka, rzuć jeszcze raz")
        else:
            self._kolejny_rzut_kostka = False

        if self._suma_oczek == 21:
            self.kontroler_wiadomosci.dodaj_wiadomosc("Idziesz do więzienia")
            self._gracze[self._aktualny_gracz - 1].pozycja = 10
            self.przesun_gracza_bez_raportu(self._gracze[self._aktualny_gracz - 1], 10)
            self._gracze[self._aktualny_gracz - 1].uwiezienie = True
            self._gracze[self._aktualny_gracz - 1].tury_w_wiezieniu = 0
            self._kolejny_rzut_kostka = False
            self._suma_oczek = 0

    def przesun_gracza(self, gracz, ruch):
        stara_pozycja = gracz.pionek.numer_pola
        nowa_pozycja = (stara_pozycja + ruch) % LICZBA_POL
        gracz.pionek.przesun(ruch)
        gracz.czy_przeszedl_przez_start(self, stara_pozycja)

        self.kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {gracz.id} przesunął się z pozycji {stara_pozycja} na {nowa_pozycja}"
        )

        pole = self._plansza.pobierz_pole(nowa_pozycja)
        self.wykonaj_akcje_na_polu(gracz, pole)

    def przesun_gracza_bez_raportu(self, gracz, nowa_pozycja):
        stara_pozycja = gracz.pionek.numer_pola
        gracz.pionek.przesun(40 - stara_pozycja + nowa_pozycja) % LICZBA_POL

    # def akcja_dostepnego_pola(self, gracz, pole, nr_pola=1):
    #     self.akcja_pola_okno.czy_akcja_pola = True

    def akcja_kupienia_nieruchomosci(self, gracz, posiadlosc, nr_pola=1):
        if posiadlosc.kolor == "kolo" or posiadlosc.kolor == "pozaWmii":
            return
        if not gracz.caly_kolor(posiadlosc.kolor):
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie posiadasz wszystkich kart z koloru, dlatego nie możesz jeszcze kupić domku"
            )
            return
        if posiadlosc.czy_zastawiona:
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie można kupić domku lub hotelu na zastawionej posiadłości"
            )
            return

        nieruchomosc = gracz.czy_cztery_domki(posiadlosc)
        if nieruchomosc == "nie":
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Masz już 4 domki na tej posiadłości, aby kupić hotel, musisz mieć 4 domki na każdej posiadłości w kolorze {posiadlosc.kolor}"
            )
            return

        self.akcja_nieruchomosci_okno.czy_kupno = True
        self.akcja_nieruchomosci_okno.nieruchomosc = nieruchomosc

    def wykup_z_wiezienia_rzutem(self):
        liczba_siodemek = 0
        for x in range(3):
            kostka_pierwsza = random.randint(1, 6)
            kostka_druga = random.randint(1, 6)
            suma += kostka_pierwsza + kostka_druga
            if suma == 7:
                liczba_siodemek += 1
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}, Kostka druga: {kostka_druga}"
            )
        if liczba_siodemek < 2:
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Niestety, wyrzuciłeś tylko {liczba_siodemek} siódemek. Nie udało Ci się wykupić z więzienia, musisz odsiedzieć wyrok"
            )
            return False
        self.kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gratulacje! Wyrzuciłeś {liczba_siodemek} siódemek. Udało Ci się wykupić z więzienia"
        )
        return True

    def wykonaj_akcje_na_polu(self, gracz, pole):
        self.kontroler_wiadomosci.dodaj_wiadomosc(pole.zwroc_info())

        if pole.typ == "Podatek dochodowy":
            self.czy_akcja_zakonczona = False
            self.akcja_zagadek_okno.akcja_podatkowa(gracz, pole)
            self.akcja_zagadek_okno.przygotuj_zagadke()
            self.akcja_zagadek_okno.czy_zagadka = True

        elif pole.typ == "Szansa":
            self.czy_akcja_zakonczona = False
            self.akcja_kart_okno.czy_szansa = True
            karta = self._plansza.karty.nastepna_karta()
            karta.wyswietl_tresc(self)
            karta.wykonaj_akcje(self, gracz)

        elif pole.typ == "Wiezienie":
            self.kontroler_wiadomosci.dodaj_wiadomosc("Gracz odwiedza więzienie")

        # TODO: mozliwosc wykupienia sie z wiezienia za pomoca wyrzucenia 2 siodemek na 3 rzuty kostka
        elif pole.typ == "idz_do_wiezienia":
            self.kontroler_wiadomosci.dodaj_wiadomosc("Gracz idzie do więzienia")
            if self.wykup_z_wiezienia_rzutem():
                return
            if not gracz.liczba_kart_wyjdz_z_wiezienia:
                self.czy_akcja_zakonczona = False
                self.akcja_wiezienie_okno.czy_wiezienie = True
                gracz.uwiezienie = True
                self.przesun_gracza_bez_raportu(
                    self._gracze[self._aktualny_gracz - 1], 10
                )
            else:
                gracz.liczba_kart_wyjdz_z_wiezienia -= 1
                self.kontroler_wiadomosci.dodaj_wiadomosc(
                    "Wykorzystano kartę 'wyjdź bezpłatnie z więzienia'"
                )

        elif pole.typ == "Posiadlosc":
            if isinstance(pole, Posiadlosc):
                posiadlosc = pole
                posiadlosc.wyswietl_info(self)
                if posiadlosc.wlasciciel is None:
                    self.czy_akcja_zakonczona = False
                    self.akcja_pola_okno.czy_akcja_pola = True
                    self.akcja_pola_okno.akcja_kupowania(posiadlosc, gracz)
                elif posiadlosc.wlasciciel == gracz.id:
                    self.czy_akcja_zakonczona = False
                    self.akcja_kupienia_nieruchomosci(gracz, posiadlosc)
                    self.akcja_nieruchomosci_okno.akcja_kupowania(posiadlosc, gracz)
                else:
                    self.kontroler_wiadomosci.dodaj_wiadomosc("Gracz płaci czynsz")
                    gracz.zaplac_czynsz(self, posiadlosc)
            else:
                raise Exception("Błąd. Posiadłość jest innym polem")

    def tura(self):
        if not self._kolejny_rzut_kostka:
            self.wybierz_kolejnego_gracza()

        if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Ruch gracza: {self._aktualny_gracz}"
            )

            kostka_pierwsza = random.randint(1, 6)
            kostka_druga = random.randint(1, 6)
            self._suma_oczek += kostka_pierwsza + kostka_druga

            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}, Kostka druga: {kostka_druga}"
            )
            self.kontroler_wiadomosci.dodaj_wiadomosc(f"Suma: {self._suma_oczek}")

            self.analizuj_rzut(kostka_pierwsza, kostka_druga)
            self.przesun_gracza(
                self._gracze[self._aktualny_gracz - 1], kostka_pierwsza + kostka_druga
            )
        else:
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {self._aktualny_gracz} jest w więzieniu."
            )
            self.wybierz_kolejnego_gracza()

        if not self._kolejny_rzut_kostka:
            self._aktualny_gracz = (self._aktualny_gracz % self._liczba_graczy) + 1
            self.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Teraz tura gracza: {self._aktualny_gracz}"
            )

    def get_messages(self):
        messages = self.messages.copy()
        self.messages.clear()
        return messages

    def aktualizacja(self):
        pass
        # if not self._stos_otwartych_okien.czy_pusty():
        #     self._stos_otwartych_okien.gora().aktualizacja()

        # if not self.akcja_pola_okno.czy_koniec_zakupu():
        #     self._czy_gracz_ma_ture = False
        #     self._stos_otwartych_okien.usun()

    #     def aktualizacja_zdarzenia(self, event: pygame.event.Event):

    #         # self._akcja_pola_okno.aktulizacja_zdarzen(event)

    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        if (
            event.type == pygame.KEYDOWN
            and event.key == pygame.K_SPACE
            and self.czy_akcja_zakonczona
        ):
            self.tura()

        # if not self._stos_otwartych_okien.czy_pusty():
        #     self._stos_otwartych_okien.gora().aktualizacja_zdarzen(event)

        self.akcja_pola_okno.aktualizacja_zdarzen(event)
        self.akcja_nieruchomosci_okno.aktualizacja_zdarzen(event)
        self.akcja_kart_okno.aktualizacja_zdarzen(event)
        self.akcja_zastaw_okno.aktualizacja_zdarzen(event)
        self.akcja_zagadek_okno.aktualizacja_zdarzen(event)
        self.akcja_wiezienie_okno.aktualizacja_zdarzen(event)

    def wyswietl(self):

        self.aktualizuj_rozmiar_okien()
        self._plansza.render(self._glowne_okno)

        for gracz in self._gracze:
            gracz.pionek.wyswietl(self._glowne_okno)

        # self._akcja_pola_okno.wyswietl(self._glowne_okno)
        # if not self._stos_otwartych_okien.czy_pusty():
        #     self._stos_otwartych_okien.gora().wyswietl(self._glowne_okno)

        self.akcja_pola_okno.wyswietl(self._glowne_okno)
        self.akcja_nieruchomosci_okno.wyswietl(self._glowne_okno)
        self.akcja_kart_okno.wyswietl(self._glowne_okno)
        self.akcja_zastaw_okno.wyswietl(self._glowne_okno)
        self.akcja_zagadek_okno.wyswietl(self._glowne_okno)
        self.akcja_wiezienie_okno.wyswietl(self._glowne_okno)

    def aktualizuj_rozmiar_okien(self):
        self.akcja_pola_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_nieruchomosci_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_kart_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_zagadek_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_wiezienie_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\gracz.py
class Gracz:
    def __init__(self, id, kwota, pionek):
        self.id = id
        self.kwota = kwota
        self.pionek = pionek
        self.pozycja = 0
        self.uwiezienie = False
        self.tury_w_wiezieniu = 0  # Licznik tur w więzieniu
        self.liczba_kart_wyjdz_z_wiezienia = 0
        self.lista_posiadlosci = []
        self.liczba_zastawionych = 0

    def odczekajJednaTure(self):
        if self.uwiezienie:
            self.tury_w_wiezieniu += 1
            if self.tury_w_wiezieniu >= 2:
                self.uwiezienie = False
                self.tury_w_wiezieniu = 0
                print(f"Gracz {self.id} opuszcza więzienie po dwóch turach")

    # TODO: wczytanie numeru zastawianej posiadlosci
    def zastaw_posiadlosci(self, gra):
        if self.liczba_zastawionych >= len(self.lista_posiadlosci):
            gra.kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz już posiadłości, które mógłbyś zastawić"
            )
            gra.akcja_zastaw_okno.czy_zastaw = False
            return

        gra.kontroler_wiadomosci.dodaj_wiadomosc(
            "To wszystkie Twoje posiadłości, które możesz zastawić:"
        )
        for posiadlosc in self.lista_posiadlosci:
            if not posiadlosc.czy_zastawiona:
                posiadlosc.wyswietl_info(gra)

        # wczytanie numeru, sprawdzenie czy numer jest dobry
        x = 0
        self.lista_posiadlosci[x].czy_zastawiona = True
        self.liczba_zastawionych += 1
        self.kwota += self.lista_posiadlosci[x].zastaw_kwota

    def zdejmij_zastaw_posiadlosci(self, gra):
        if self.liczba_zastawionych == 0:
            gra.kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz zastawionych posiadlosci"
            )
            gra.akcja_zastaw_okno.czy_zdejmij_zastaw = False
            return

        gra.kontroler_wiadomosci.dodaj_wiadomosc(
            "To wszystkie Twoje posiadłości, które masz zastawione:"
        )
        for posiadlosc in self.lista_posiadlosci:
            if posiadlosc.czy_zastawiona:
                posiadlosc.wyswietl_info(gra)

        # wczytanie numeru, sprawdzenie czy numer jest dobry
        x = 0
        cena = self.lista_posiadlosci[x].zastaw_kwota * 1.2
        if self.kwota >= cena:
            self.lista_posiadlosci[x].czy_zastawiona = False
            self.liczba_zastawionych -= 1
            self.kwota -= cena
        else:
            gra.kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz wystarczająco dużo pieniędzy, aby zdjąć zastaw z posiadłości"
            )

    def zaplac_czynsz(self, gra, posiadlosc):
        czynsz = posiadlosc.oblicz_czynsz(gra)
        self.wykonaj_oplate(gra, czynsz)
        posiadlosc.wlasciciel.dodaj_pieniadze(gra, czynsz)

    def ile_w_kolorze(self, kolor):
        liczba_w_kolorze = 0
        for posiadlosc in self.lista_posiadlosci:
            if not posiadlosc.kolor == kolor:
                liczba_w_kolorze += 1
        return liczba_w_kolorze

    def caly_kolor(self, kolor):
        if kolor == "brazowy" or kolor == "granatowy" or kolor == "pozaWmii":
            return self.ile_w_kolorze(kolor) == 2
        else:
            return self.ile_w_kolorze(kolor) == 3

    def czy_cztery_domki(self, posiadlosc):
        if posiadlosc.liczba_domow < 4:
            return "domek"

        liczba_domkow_w_kolorze = 0
        for pole in self.lista_posiadlosci:
            if not pole.kolor == pole.kolor:
                liczba_domkow_w_kolorze += pole.liczba_domow

        if posiadlosc.kolor == "brazowy" or posiadlosc.kolor == "granatowy":
            if liczba_domkow_w_kolorze < 8:
                return "nie"
            return "hotel"
        else:
            if liczba_domkow_w_kolorze < 12:
                return "nie"
            return "hotel"

    def wykonaj_oplate(self, gra, cena):
        if cena > self.kwota:
            gra.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Brakuje Ci {cena - self.kwota} pieniędzy. Czy chcesz zastawić którąś z posiadłości?"
            )
            gra.akcja_zastaw_okno.czy_zastaw = True
            gra.akcja_zastaw_okno.akcja_zastawiania(self)
        else:
            self.kwota -= cena
            return 1
        return 0

    def dodaj_pieniadze(self, gra, cena):
        self.kwota += cena
        gra.kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {self.id} otrzymał {cena} pieniędzy"
        )

    def czy_przeszedl_przez_start(self, gra, stara_pozycja):
        if self.pionek.numer_pola < stara_pozycja and self.uwiezienie == False:
            self.dodaj_pieniadze(gra, 2000)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\karta_szansy.py
import random


class KartaSzansy:
    def __init__(self, typ, tresc, wartosc=0):
        self.typ = typ
        self.tresc = tresc
        self.wartosc = wartosc

    def wyswietl_tresc(self, gra):
        gra.kontroler_wiadomosci.dodaj_wiadomosc(self.tresc)

    def wykonaj_akcje(self, gra, gracz):
        if self.typ == "pobierz":
            gracz.dodaj_pieniadze(gra, self.wartosc)

        elif self.typ == "pobierz_od_graczy":
            for g in gra._gracze:
                if g.id != gracz.id:
                    g.wykonaj_oplate(gra, self.wartosc)
                    gracz.dodaj_pieniadze(gra, self.wartosc)
            gra.kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} otrzymuje {self.wartosc} zł od każdego gracza"
            )

        elif self.typ == "oplata":
            gracz.wykonaj_oplate(gra, self.wartosc)

        elif self.typ == "oplata_za_domki":
            liczba_domkow = 0
            liczba_hoteli = 0
            for pole in gracz.lista_posiadlosci:
                liczba_domkow += pole.liczba_domow
                liczba_hoteli += pole.liczba_hoteli
            cena = liczba_domkow * self.wartosc
            cena += liczba_hoteli * self.wartosc * 3
            gracz.wykonaj_oplate(gra, cena)

        elif self.typ == "przejdz_na_pole":
            stara_pozycja = gracz.pionek.numer_pola
            ruch = (stara_pozycja - self.wartosc) % 40
            gra.przesun_gracza(gracz, ruch)

        # brak poboru oplaty za przejscie przez start
        elif self.typ == "cofnij_na_pole":
            gra.przesun_gracza_bez_raportu(gracz, self.wartosc)

        elif self.typ == "cofnij_do_wiezienia":
            gracz.uwiezienie = True
            gra.przesun_gracza_bez_raportu(gracz, 10)

        elif self.typ == "karta_wyjscie_z_wiezienia":
            gracz.liczba_kart_wyjdz_z_wiezienia += 1


class Karty:
    def __init__(self):
        self.karty = self.wczytaj_karty("data/karty.txt")
        random.shuffle(self.karty)
        self.current_index = 0

    def wczytaj_karty(self, plik: str) -> list[KartaSzansy]:
        karty = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 2 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda karta powinna mieć 3 linie danych."
                    )
                typ = lines[i].strip()
                tresc = lines[i + 1].strip()
                wartosc = int(lines[i + 2].strip())
                karta = KartaSzansy(typ, tresc, wartosc)
                karty.append(karta)
                i += 4
        return karty

    def nastepna_karta(self):
        karta = self.karty[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.karty)
        return karta


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\odpowiedz.py
from enum import Enum


class Odpowiedz(Enum):
    Odpowiedz_A = 0
    Odpowiedz_B = 1
    Odpowiedz_C = 2


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\plansza.py
from typing import List

import pygame.color
from model.pole import Pole
from view.pionek import Pionek
from model.posiadlosc import Posiadlosc
from model.karta_szansy import *
from model.podatek_dochodowy import Zagadki
from model.podatek_dochodowy import PodatekDochodowy


class Plansza:
    @staticmethod
    def inicializacja_planszy() -> List[Pole]:
        board: List[Pole] = list()
        board.append(Pole(0, "Start"))
        board.append(Posiadlosc(1, "Automat z kawą", "brazowy", 600, 20, 300, 500))
        board.append(Pole(2, "Szansa"))
        board.append(Posiadlosc(3, 'Bistro "Świetlica"', "brazowy", 600, 40, 300, 500))
        board.append(PodatekDochodowy(4, 1000))
        board.append(Posiadlosc(5, "KNRSI", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(6, "Parking", "niebieski", 1000, 60, 500, 500))
        board.append(Pole(7, "Szansa"))
        board.append(Posiadlosc(8, "Winda", "niebieski", 1000, 60, 500, 500))
        board.append(Posiadlosc(9, "Szatnia", "niebieski", 1200, 80, 500, 500))
        board.append(Pole(10, "Wiezienie"))
        board.append(
            Posiadlosc(11, "Sala 1073 (sieci)", "rozowy", 1400, 100, 700, 1000)
        )
        board.append(Posiadlosc(12, "Drążki za wydziałem", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(13, "Sala 0056 (laby)", "rozowy", 1400, 100, 700, 1000))
        board.append(
            Posiadlosc(14, "Sala 1072 (macbooki)", "rozowy", 1600, 120, 800, 1000)
        )
        board.append(Posiadlosc(15, "KNMF", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(16, "Ślimak", "pomaranczowy", 1800, 140, 900, 1000))
        board.append(Pole(17, "Szansa"))
        board.append(
            Posiadlosc(18, "Serwerownia", "pomaranczowy", 1800, 140, 900, 1000)
        )
        board.append(
            Posiadlosc(19, "Pokój samorządu", "pomaranczowy", 2000, 160, 1000, 1000)
        )
        board.append(Pole(20, "Parking"))
        board.append(Posiadlosc(21, "Recepcja", "czerwony", 2200, 180, 1100, 1500))
        board.append(Pole(22, "Szansa"))
        board.append(Posiadlosc(23, "Dziekanat", "czerwony", 2200, 180, 1100, 1500))
        board.append(
            Posiadlosc(24, "Muzeum komputerów", "czerwony", 2400, 200, 1200, 1500)
        )
        board.append(Posiadlosc(25, "KMS", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(26, "Mural", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(27, "Pomnik Kopernika", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(28, "Przejście przez WZIKS", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(29, "Fontanna", "zolty", 2800, 240, 1400, 1500))
        board.append(Pole(30, "Idz do wiezienia"))
        board.append(Posiadlosc(31, "Ping-pong", "zielony", 3000, 260, 1500, 2000))
        board.append(Posiadlosc(32, "Bilard", "zielony", 3000, 260, 1500, 2000))
        board.append(Pole(33, "Szansa"))
        board.append(Posiadlosc(34, "Piłkarzyki", "zielony", 3200, 280, 1600, 2000))
        board.append(Posiadlosc(35, "KSI", "kolo", 2000, 250, 1000))
        board.append(Pole(36, "Szansa"))
        board.append(Posiadlosc(37, "sala 0004", "granatowy", 3500, 350, 1750, 2000))
        board.append(PodatekDochodowy(38, 500))
        board.append(Posiadlosc(39, "sala 0089", "granatowy", 4000, 500, 2000, 2000))

        return board

    def __init__(self):
        self.plansza: List[Pole] = self.inicializacja_planszy()
        self.karty = Karty()
        self.zagadki = Zagadki()
        self.wczytaj_grafiki()

    def pobierz_pole(self, numer_pola: int) -> Pole:
        if 0 <= numer_pola < len(self.plansza):
            return self.plansza[numer_pola]
        else:
            raise Exception("Bledny numer pola")

    # def wysrodkuj_pionki(self):
    #
    # def wysrodkuj_plansze(self):

    # def update(self):

    def render(self, screen):
        for pole in self.plansza:
            pole.render(screen)

    def wczytaj_grafiki(self):
        i = 0
        path = "graphics/pola/pole_"
        extension = ".png"

        for pole in self.plansza:
            pole.sciezka_do_grafiki = path + str(i) + extension
            i += 1


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\podatek_dochodowy.py
from model.pole import Pole
from model.gracz import Gracz
from numpy import random
from model.odpowiedz import Odpowiedz


class Zagadka:
    def __init__(
        self,
        tresc_zagadki: str,
        odpowiedz_a: str,
        odpowiedz_b: str,
        odpowiedz_c: str,
        poprawna: Odpowiedz,
    ) -> None:
        self.tresc_zagadki = tresc_zagadki
        self.odpowiedz_a = odpowiedz_a
        self.odpowiedz_b = odpowiedz_b
        self.odpowiedz_c = odpowiedz_c
        self.poprawna = poprawna


class Zagadki:

    def __init__(self) -> None:
        self.lista_zagadek = self.wczytaj_zagadki("data/zagadki.txt")
        self.permutacja = random.permutation(self.lista_zagadek)
        self.ind = 0

    def nastepna_zagadka(self) -> Zagadka:
        curr = self.ind
        self.ind = (self.ind + 1) % len(self.lista_zagadek)
        return self.permutacja[curr]

    def wczytaj_zagadki(self, plik: str) -> list[Zagadka]:
        zagadki = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 4 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda zagadka powinna mieć 5 linii danych."
                    )
                tresc = lines[i].strip()
                odpowiedz_a = lines[i + 1].strip()
                odpowiedz_b = lines[i + 2].strip()
                odpowiedz_c = lines[i + 3].strip()
                poprawna = lines[i + 4].strip()
                zagadka = Zagadka(
                    tresc, odpowiedz_a, odpowiedz_b, odpowiedz_c, poprawna
                )
                zagadki.append(zagadka)
                i += 6
        return zagadki


class PodatekDochodowy(Pole):

    def __init__(self, numer: int, podatek: int) -> None:
        super().__init__(numer, "Podatek dochodowy")
        self.podatek = podatek

    def wyswietl_info(self) -> str:
        return f"Stanąłeś na polu podatek dochodowy. Musisz zapłacić podatek w wysokości {self.podatek}"

    def zaplac_podatek(self, gra, gracz: Gracz, czy_dobra: bool) -> None:
        do_zaplaty = self.podatek
        if czy_dobra:
            do_zaplaty /= 2

        if do_zaplaty > gracz.kwota:
            if gra.pobierz_info_tak_nie(
                "Nie masz wystarczająco dużo pieniędzy, aby zapłacić podatek. Czy chcesz zastawić którąś z nieruchmości? Jeśli tego nie zrobisz przegrywasz."
            ):
                gracz.zastaw_nieruchomosci()
        if do_zaplaty > gracz.kwota:
            gra.messages.append("Bankrutujesz")
        gracz.kwota -= do_zaplaty
        gra.kontroler_wiadomosci.dodaj_wiadomosc(
            "Podatek został zapłacony, zapłacono: " + str(do_zaplaty)
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\pole.py
import pygame
from typing import NamedTuple
from enum import Enum


# TODO: Do usuniecia, korzystanie z jednego enuma z Pionka, problem z kolejnoscia wystepowania
# TODO: atrybutow w enumie w Pionku, zla kolejnosc, poprawna ponizej
class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pole:
    WYMIAR_NAGLOWKA: Vector2 = Vector2(30, 50)
    MALE_POLE_WYMIARY: Vector2 = Vector2(30, 50)
    # warning: najlepiej gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(50, 50)
    KOLOR_TLA = pygame.color.THECOLORS["red"]
    OFF_SET: Vector2 = Vector2(100, 100)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    """
    numer_pola - nr. id pola [0, maksymalna_liczba_pol)
    dlugosc_sciany_w_polach - ilosc pol na jednym z czterech brzegow planszy, /*??odejmowana jest 1 do liczenia orientacji??*/, zakladamy ze plansza jest kwadratem 
    maksymalna_liczba_pol - ilosc pol na planszy
    """
    @staticmethod
    def oblicz_zwrot_naglowka_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> KierunekPol:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return KierunekPol((numer_pola % maksymalna_liczba_pol) // dlugosc_sciany_w_polach)

    @staticmethod
    def oblicz_rozmiar_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> Vector2:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return Pole.DUZE_POLE_WYMIARY if (numer_pola % dlugosc_sciany_w_polach) == 0 else Pole.MALE_POLE_WYMIARY

    @staticmethod
    def inicjalizacja_pozycji(numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pole.OFF_SET.x
        gora = Pole.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += ((Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING) if numer_pola % 10 != 0 else 0)
                lewo += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))

            case KierunekPol.Prawo:
                lewo += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING
                gora += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))
                gora += ((Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING) if numer_pola % 10 != 0 else 0)

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING)
                lewo += (Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING)       # Czemu dziala nie mam bladego pojecia
                gora += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

            case KierunekPol.Lewo:
                gora += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

        return Vector2(lewo, gora)

    def __init__(self, numer: int, typ: str):
        self.numer = numer
        self.typ = typ
        self.kolor_naglowka = pygame.color.THECOLORS["violet"]
        self.wymiary: Vector2 = self.oblicz_rozmiar_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.kierunek_sciany = self.oblicz_zwrot_naglowka_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.pozycja: Vector2 = self.inicjalizacja_pozycji(self.numer, self.kierunek_sciany)
        self.sciezka_do_grafiki = "..."

    def zwroc_info(self) -> str:
        return f"Nazwa: {self.typ}"

    def render(self, screen):
        szerokosc_aktualny_kierunek = self.wymiary.x if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.y
        wysokosc_aktualny_kierunek = self.wymiary.y if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.x

        my_font = pygame.font.SysFont('Arial', 15)
        text_surface = my_font.render(str(self.numer), False, pygame.color.THECOLORS["black"])
        screen.blit(text_surface, (self.pozycja.x, self.pozycja.y))
        
        pygame.draw.rect(screen, Pole.KOLOR_TLA, pygame.Rect(self.pozycja.x, self.pozycja.y, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek), width=1)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\posiadlosc.py
from model.pole import Pole
from model.gracz import Gracz

KOSZT_SPRZEDAZY = 0.8


class Posiadlosc(Pole):

    def __init__(self, numer, nazwa, kolor, cena, czynsz, zastaw, cena_domu=0):
        super().__init__(numer, "Posiadlosc")
        self.nazwa = nazwa
        self.kolor = kolor
        self.cena = cena
        self.czynsz = czynsz
        self.zastaw_kwota = zastaw
        self.cena_domu = cena_domu
        self.wlasciciel = None
        self.czy_zastawiona = False
        self.liczba_domow = 0
        self.liczba_hoteli = 0

    def zwroc_info(self):
        if self.liczba_domow:
            return f"Nazwa: {self.nazwa} \nCena: {self.cena}   Czynsz: {self.czynsz}  Zastaw: {self.zastaw_kwota} \nCena-dom: {self.cena_domu}  Liczba domkow: {self.liczba_domow}"
        return f"Nazwa: {self.nazwa} \nCena: {self.cena}   Czynsz: {self.czynsz}  Zastaw: {self.zastaw_kwota} \nCena-dom: {self.cena_domu}"

    def pobierz_id_wlasciciela(self):
        return self.IDwlasciciela

    # wyswietl_info
    def wyswietl_info(self, gra):
        czynsz = self.czynsz
        if self.wlasciciel:
            czynsz = self.oblicz_czynsz(gra)

        if self.kolor != "pozaWmii" and self.kolor != "kolo":
            gra.messages.append(f"Nazwa: {self.nazwa}")
            gra.messages.append(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )
            gra.messages.append(
                f"Cena-dom: {self.cena_domu}  Liczba domkow: {self.liczba_domow}"
            )
        else:
            gra.messages.append(f"Nazwa: {self.nazwa}")
            gra.messages.append(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )

    def oblicz_czynsz(self, gra):
        liczba_w_kolorze = self.wlasciciel.ile_w_kolorze(self.kolor)
        if self.kolor == "pozaWmii":
            if liczba_w_kolorze == 2:
                return gra._suma_oczek * 10 * 10
            else:
                return gra._suma_oczek * 4 * 10
        elif self.kolor == "kolo":
            if liczba_w_kolorze == 1:
                return 250
            elif liczba_w_kolorze == 2:
                return 500
            elif liczba_w_kolorze == 3:
                return 1000
            else:
                return 2000
        else:
            if liczba_w_kolorze < 3:
                return self.czynsz
            if liczba_w_kolorze == 3 and self.liczba_domow == 0:
                return 2 * self.czynsz

            cena = 0
            if self.liczba_domow == 1:
                cena = 5 * self.czynsz
            elif self.liczba_domow == 2:
                cena = 15 * self.czynsz
            elif self.liczba_domow == 3:
                cena = 45 * self.czynsz
            elif self.liczba_domow == 4:
                cena = 80 * self.czynsz

            cena += self.czynsz * 125 * self.liczba_hoteli
            return cena

    def kup_posiadlosc(self, gra, gracz):
        x = gracz.wykonaj_oplate(gra, self.cena)
        if x == 1:
            gracz.lista_posiadlosci.append(self)
            self.wlasciciel = gracz
            gra.messages.append(f"Gratulacje, dokonałeś zakupu {self.nazwa}!")
            gra.akcja_pola_okno.czy_akcja_pola = False
        elif not gra.akcja_zastaw_okno.czy_zastaw:
            gra.messages.append("Wycofałeś się z zakupu")
            gra.akcja_pola_okno.czy_akcja_pola = False
        return

    def kup_dom(self, gra, gracz, ile_domow):
        if gracz.wykonaj_oplate(gra, self.cena_domu * ile_domow):
            self.liczba_domow += ile_domow
            while self.liczba_domow >= 5:
                self.liczba_domow -= 5
                self.liczba_hoteli += 1
            gra.messages.append(
                f"Zakup domu się udał posiadasz {self.liczba_domow} domów i {self.liczba_hoteli} hoteli"
            )
        else:
            gra.messages.append("Wycofałeś się z zakupu")

    def sprzedaj_dom(self, gra, gracz):
        if self.liczba_domow > 0:
            gracz.kwota = gracz.kwota + self.cena_domu * KOSZT_SPRZEDAZY
            self.liczba_domow -= 1

    def sprzedaj_hotel(self, gra, gracz):
        if self.liczba_hoteli > 0:
            gracz.kwota = (
                gracz.kwota
                + (self.liczba_hoteli * 5 * self.cena_domu) * KOSZT_SPRZEDAZY
            )
            self.liczba_hoteli -= 1


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\model\__init__.py
# monopoly/model/__init__.py
from .gra import Gra
from .gracz import Gracz
from .plansza import Plansza
from .posiadlosc import Posiadlosc
from .podatek_dochodowy import PodatekDochodowy, Zagadki
from .karta_szansy import KartaSzansy
from .pole import Pole


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\rand_files\UJpoly.py
class Gra:
    def __init__(self):
        self.gracze = []
        
class Plansza:
    def __init__(self):
        self.Pola = []
        
class Gracz:
    def __init__(self, Id: int, pionek: Pionek, kartaSzansy: KartaSzansy, liczbaPostojow: int, uwiezienie: bool):
        self.Id = Id
        self.pionek = pionek
        self.kartaSzansy = kartaSzansy
        self.liczbaPostojow = liczbaPostojow
        self.uwiezienie = uwiezienie
        
class Posiadlosc(Pole):
    def __init__(self, cena: int, czynsz: int, cenaDomu: int, cenaHotelu: int, wlasciciel: Gracz):
        self.cena = cena
        self.czynsz = czynsz
        self.cenaDomu = cenaDomu
        self.cenaHotelu = cenaHotelu
        self.wlasciciel = wlasciciel        

class Pole:
    def __init__(self, numer: int, grafika: Graphic):
        self.numer = numer
        self.grafika = grafika

class PoleWykonywalne(Pole):
    def __init__(self):

class PoleSpecjalne(Pole):
    def __init__(self):
        
class KartaSzansy:
    def __init__(self, trescKarty: str):
        self.trescKarty = trescKarty
        
class Pionek:
    def __init__(self, numerPola: int, color: Color, grafika: Graphic):
        self.numerPola = numerPola
        self.color = color
        self.grafika = grafika

    def zmienGrafike(self) -> bool:

    def zmienPozycje(self, nowaPozycja: int) -> bool:

class Statystyki:
    def __init__(self):
        self.statystyki = []

    def zaktualizujStatystykiGracza(self, gracz: Gracz): 
        
class Statystyka:
    def __init__(self, IDgracza: int, majatek: int, iloscPosiadlosci: int, iloscDomow: int, iloscHoteli: int):
        self.IDgracza = IDgracza
        self.majatek = majatek
        self.iloscPosiadlosci = iloscPosiadlosci
        self.iloscDomow = iloscDomow
        self.iloscHoteli = iloscHoteli

    def zmienWartosc(self):       
        
class Tutorial:
    def __init__(self, ukonczony: bool):
        self.ukonczony = ukonczony

    def rozpocznij(self):        


class Czas:
    def __init__(self, czasGry: float, czasTury: float):
        self.czasGry = czasGry
        self.czasTury = czasTury


class Zagadki:
    def __init__(self, trescZagadki: str, poprawnaOdpowiedz: int):
        self.trescZagadki = trescZagadki
        self.poprawnaOdpowiedz = poprawnaOdpowiedz

    def sprawdzOdpowiedz(self) -> bool:


















C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_pionek.py
import pytest
import pygame
from view.pionek import Pionek


# Komenda aby uruchomic testy: python -m pytest ./tests
class TestPionek:
    def setup_method(self):
        self.pionek = Pionek(0, pygame.color.THECOLORS["black"], "graphics")
        # Pozniej dodaj "mock object"

    @pytest.mark.parametrize(
        "liczba_pol", list(range(Pionek.MIN_LICZBA_OCZEK, Pionek.MAX_LICZBA_OCZEK))
    )
    def test_ruch_prawidlowa_ilosc_oczek(self, liczba_pol):
        assert self.pionek.przesun(liczba_pol) is True

    @pytest.mark.parametrize("liczba_pol", [-1, 0, 1, 13, 14])
    def test_ruch_nieprawidlowa_ilosc_oczek(self, liczba_pol):
        assert self.pionek.przesun(liczba_pol) is False


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\kontroler_wiadomosci.py
import pygame


class KontrolerWiadomosci:
    MAKSYMALNA_ILOSC_WIADOMOSCI = 15

    def __init__(self, font):
        self.wiadomosci: list[str] = list()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0
        self.font: pygame.font.Font = font

    def _render_text(self, text: str, pos, okno: pygame.Surface):
        text_surface = self.font.render(text, True, (0, 0, 0))
        okno.blit(text_surface, pos)

    def dodaj_wiadomosc(self, tresc: str):

        if self.ilosc_wiadomosci < KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI:
            self.ilosc_wiadomosci += 1
            self.wiadomosci.append(tresc)
        else:
            self.wiadomosci[self.ostatnia_pozycyjnie_wiadomosc_index] = tresc
            self.ostatnia_pozycyjnie_wiadomosc_index = (
                self.ostatnia_pozycyjnie_wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI

    def usun_wszystkie_wiadomosci(self):
        self.wiadomosci.clear()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0

    def wyswietl(self, okno: pygame.Surface, szerokosc_okna):
        y_offset = 10

        wiadomosc_index = self.ostatnia_pozycyjnie_wiadomosc_index
        wiadomosc_index_end = (
            (self.ostatnia_pozycyjnie_wiadomosc_index - 1)
            % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            if self.ilosc_wiadomosci == KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            else self.ilosc_wiadomosci - 1
        )

        while wiadomosc_index != wiadomosc_index_end:
            wiadomosc = self.wiadomosci[wiadomosc_index]

            if isinstance(wiadomosc, str | bytes):
                self._render_text(wiadomosc, (szerokosc_okna - 400, y_offset), okno)
                y_offset += 40

            wiadomosc_index = (
                wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI

        # for message in self.wiadomosci[-15:]:  # Wyświetla ostatnie 15 komunikatów
        #     if isinstance(message, str | bytes):
        #         self._render_text(message, (szerokosc_okna - 400, y_offset), okno)
        #         y_offset += 40


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\pionek.py
import pygame
from enum import Enum
from typing import NamedTuple


class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pionek:
    MIN_LICZBA_OCZEK = 1
    MAX_LICZBA_OCZEK = 12
    DLUGOSC_SCIANKI_W_POLACH = 10
    LICZBA_POL = 40

    MALE_POLE_WYMIARY: Vector2 = Vector2(30, 50)
    # warning: najlepiej gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(50, 50)
    OFF_SET: Vector2 = Vector2(100, 100)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    @staticmethod
    def oblicz_nowa_pozycje(numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pionek.OFF_SET.x
        gora = Pionek.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += (
                    (Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING)
                    if numer_pola % 10 != 0
                    else 0
                )
                lewo += (
                    0
                    if (numer_pola % 10 == 0)
                    else (
                        ((numer_pola % 10) - 1)
                        * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                    )
                )

            case KierunekPol.Prawo:
                lewo += (
                    9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                    + Pionek.DUZE_POLE_WYMIARY.x
                    + Pionek.SPACING
                )
                gora += (
                    0
                    if (numer_pola % 10 == 0)
                    else (
                        ((numer_pola % 10) - 1)
                        * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                    )
                )
                gora += (
                    (Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING)
                    if numer_pola % 10 != 0
                    else 0
                )

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (
                    Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING
                )
                lewo += (
                    Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING
                )  # Czemu dziala nie mam bladego pojecia
                gora += (
                    9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                    + Pionek.DUZE_POLE_WYMIARY.y
                    + Pionek.SPACING
                )

            case KierunekPol.Lewo:
                gora += (
                    (9 - (numer_pola % 10))
                    * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                    + Pionek.DUZE_POLE_WYMIARY.y
                    + Pionek.SPACING
                )

        return Vector2(lewo, gora)

    def __init__(self, numer_pola: int, color: pygame.color, grafika: str):
        self.numer_pola = numer_pola
        self.color = color
        self.grafika = grafika
        self.kierunek: KierunekPol = KierunekPol.Gora
        self.wymiary: Vector2 = Vector2(20, 20)
        self.pozycja: Vector2 = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)

    def przesun(self, liczba_pol: int) -> bool:
        if Pionek.MIN_LICZBA_OCZEK <= liczba_pol <= Pionek.MAX_LICZBA_OCZEK:
            self.numer_pola = (self.numer_pola + liczba_pol) % Pionek.LICZBA_POL
            self.kierunek = KierunekPol(
                self.numer_pola // Pionek.DLUGOSC_SCIANKI_W_POLACH
            )
            self.pozycja = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)

            return True

        return False

    def wyswietl(self, okno: pygame.Surface):
        pygame.draw.rect(
            okno,
            self.color,
            pygame.Rect(self.pozycja.x, self.pozycja.y, self.wymiary.x, self.wymiary.y),
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\przycisk.py
import pygame


class Przycisk:
    def __init__(self, x, y, width, height, color, hover_color, text, text_color):
        self.rect = pygame.Rect(x, y, width, height)
        self.color = color
        self.hover_color = hover_color
        self.text = text
        self.text_color = text_color
        self.font = pygame.font.Font(None, 36)

    def pobierz_wymiary(self) -> pygame.Rect:
        return self.rect

    def draw(self, screen):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(screen, color, self.rect)

        if self.text:
            text_surf = self.font.render(self.text, True, self.text_color)
            text_rect = text_surf.get_rect(center = self.rect.center)
            screen.blit(text_surf, text_rect)

    def is_clicked(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                return True
        return False

    def updateSize(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\__init__.py
# monopoly/view/__init__.py
from .kontroler_wiadomosci import KontrolerWiadomosci
from .przycisk import Przycisk
from .pionek import Pionek
from .okna import *


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_akcji_pola.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
import pygame
from enum import Enum


class OknoAkcjiPola(OknoBazowe):
    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zakup = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kupuję",
            self.gra.kolor_tekstu,
        )
        self.licytacja = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "licytacja",
            self.gra.kolor_tekstu,
        )
        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.6,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )
        self.board_png = None

        self.czy_akcja_pola = False
        self.gracz_majacy_mozliwosc_zakupu = None
        self.posiadlosc_do_zakupu = None

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.zakup.is_clicked(event):
            self.kup_pole()
            self.czy_akcja_pola = False
            self.zamknij()
        elif self.licytacja.is_clicked(event):
            self.czy_akcja_pola = False
            self.zamknij()
            pass
        elif self.wyjscie.is_clicked(event):
            self.czy_akcja_pola = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        if self.czy_akcja_pola:
            self.zakup.draw(screen)
            self.licytacja.draw(screen)
            self.wyjscie.draw(screen)
            if self.board_png:
                plansza_wymiary_pozycja = self.board_png.get_rect(
                    center=(self.W // 3, self.H // 2)
                )
                screen.blit(self.board_png, plansza_wymiary_pozycja)

    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_do_zakupu = posiadlosc
        self.gracz_majacy_mozliwosc_zakupu = gracz
        self.board_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
            (0.28 * self.W, 0.64 * self.H),
        )

    def kup_pole(self):
        self.posiadlosc_do_zakupu.kup_posiadlosc(
            self.gra, self.gracz_majacy_mozliwosc_zakupu
        )

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_bazowe.py
import pygame
from abc import abstractmethod


class OknoBazowe:
    @staticmethod
    def wysrodkuj_obraz(okno: pygame.Vector2, obraz: pygame.Vector2) -> pygame.Vector2:
        left = (okno.x // 2) - (obraz.x // 2)
        top = (okno.y // 2) - (obraz.y // 2)

        return pygame.Vector2(left, top)

    @abstractmethod
    def aktualizacja(self):
        pass

    @abstractmethod
    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        pass

    @abstractmethod
    def wyswietl(self, screen: pygame.Surface):
        pass

    @abstractmethod
    def aktualizuj_rozmiar_okna(self, width, height):
        pass

    @abstractmethod
    def zamknij(self):
        pass


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_kart.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
import pygame


class OknoKart(OknoBazowe):

    def __init__(self, gra):
        self.H = 800
        self.W = 1200
        self.gra = gra
        self.szansa_png = pygame.transform.scale(
            pygame.image.load("graphics/karta_szansy.png"), (0.6 * self.W, 0.5 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.42,
            self.H * 0.7,
            self.W * 0.2,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.czy_szansa = False

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.wyjscie.is_clicked(event):
            self.czy_szansa = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        if self.czy_szansa:
            self.szansa_png = pygame.transform.scale(
                self.szansa_png, (0.64 * self.W, 0.5 * self.H)
            )
            screen.blit(self.szansa_png, (self.W * 0.2, self.H * 0.15))
            self.wyjscie.updateSize(
                self.W * 0.42, self.H * 0.7, self.W * 0.2, self.H * 0.1
            )
            self.wyjscie.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_nieruchomosci.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
import pygame


class OknoNieruchomosci(OknoBazowe):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.nieruchomosc = "brak"

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_hotel = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup hotel",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_domek = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup domek",
            self.gra.kolor_tekstu,
        )

        self.przycisk = self.wyjscie
        self.ktore_kupno = 0
        self.czy_kupno = False

    def ustaw_poprawny_przycisk_domek_hotel(self):

        if self.nieruchomosc == "domek":
            self.przycisk = self.przycisk_kup_domek
        elif self.nieruchomosc == "hotel":
            self.przycisk = self.przycisk_kup_hotel
        else:
            self.przycisk = self.wyjscie

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.przycisk.is_clicked(event) and self.nieruchomosc == "domek":
            self.kup_domek()
            self.czy_kupno = False
            self.zamknij()
        elif self.przycisk.is_clicked(event) and self.nieruchomosc == "hotel":
            self.kup_hotel()
            self.czy_kupno = False
            self.zamknij()
        elif self.wyjscie.is_clicked(event):
            self.czy_kupno = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        if self.czy_kupno:
            self.pole_png = pygame.transform.scale(
                self.pole_png, (0.28 * self.W, 0.64 * self.H)
            )
            screen.blit(self.pole_png, (self.W * 0.2, self.H * 0.15))
            self.przycisk.updateSize(
                self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
            )
            self.wyjscie.updateSize(
                self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
            )
            self.przycisk.draw(screen)
            self.wyjscie.draw(screen)

    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_gracza = posiadlosc
        self.gracz = gracz
        self.ustaw_poprawny_przycisk_domek_hotel()
        self.pole_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
            (0.28 * self.W, 0.64 * self.H),
        )

    def kup_domek(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 1)

    def kup_hotel(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 5)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_wiezienia.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
import pygame


class OknoWiezienia(OknoBazowe):

    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zdjecie = pygame.transform.scale(
            pygame.image.load("graphics/wiezienie.png"), (0.45 * self.H, 0.45 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.3,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.czy_wiezienie = False

        self.skalar_czcionki = 24  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(None, int(self.W / self.skalar_czcionki))
        self.informacja_o_wiezeniu = "idziesz do więzienia, stoisz 2 tury"

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.wyjscie.is_clicked(event):
            self.czy_wiezienie = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        H = self.H
        W = self.W

        if self.czy_wiezienie:
            screen.fill((255, 255, 255))

            self.zaktualizuj_rozmiar_czcionki()
            self.wyswietl_teksty(screen)

            self.zdjecie = pygame.transform.scale(
                self.zdjecie, (0.45 * self.H, 0.45 * self.H)
            )
            screen.blit(self.zdjecie, (W * 0.2, H * 0.15))
            self.wyjscie.updateSize(W * 0.6, H * 0.3, W * 0.2, H * 0.15)
            self.wyjscie.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(None, int(self.W / self.skalar_czcionki))
        self.tekst = self.font.render(self.informacja_o_wiezeniu, True, (0, 0, 0))

    def wyswietl_teksty(self, screen):
        screen.blit(self.tekst, (self.W * 0.18, self.H * 0.7))

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_zagadek.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
from model.odpowiedz import Odpowiedz
import pygame


class OknoZagadek(OknoBazowe):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.czy_zagadka = False

        self.A = Przycisk(
            self.W * 0.2,
            self.H * 0.5,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "A",
            self.gra.kolor_tekstu,
        )
        self.B = Przycisk(
            self.W * 0.2,
            self.H * 0.6,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "B",
            self.gra.kolor_tekstu,
        )
        self.C = Przycisk(
            self.W * 0.2,
            self.H * 0.7,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "C",
            self.gra.kolor_tekstu,
        )

        self.odpowiedz_A = "empty"
        self.odpowiedz_B = "empty"
        self.odpowiedz_C = "empty"

        self.skalar_czcionki = 22  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(None, int(self.W / self.skalar_czcionki))
        self.informacja_o_podatku = "Zapłać podatek dochodowy o wartości "
        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + "x"
        self.informacja_o_zagadce = (
            "odpowiedz poprawnie na pytanie aby zmniejszyć opłatę"
        )
        self.tekst_zagadki = "empty"

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.A.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_A)
            )
            self.czy_zagadka = False
            self.zamknij()
        elif self.B.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_B)
            )
            self.czy_zagadka = False
            self.zamknij()
        elif self.C.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_C)
            )
            self.czy_zagadka = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        self.zaktualizuj_rozmiar_czcionki()

        if self.czy_zagadka:
            self.wyswietl_teksty(screen)

            self.A.updateSize(self.W * 0.2, self.H * 0.5, self.H * 0.1, self.H * 0.1)
            self.A.draw(screen)
            self.B.updateSize(self.W * 0.2, self.H * 0.62, self.H * 0.1, self.H * 0.1)
            self.B.draw(screen)
            self.C.updateSize(self.W * 0.2, self.H * 0.74, self.H * 0.1, self.H * 0.1)
            self.C.draw(screen)

    def przygotuj_zagadke(self):

        zagadka = self.gra._plansza.zagadki.nastepna_zagadka()
        self.tekst_zagadki = zagadka.tresc_zagadki

        self.odpowiedz_A = zagadka.odpowiedz_a
        self.odpowiedz_B = zagadka.odpowiedz_b
        self.odpowiedz_C = zagadka.odpowiedz_c
        self.poprawna_odpowiedz = zagadka.poprawna

        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + str(
            self.pole.podatek
        )

    def akcja_podatkowa(self, gracz, pole):
        self.gracz = gracz
        self.pole = pole

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(None, int(self.W / self.skalar_czcionki))
        self.podatek = self.font.render(
            self.informacja_o_podatku_z_cena, True, (0, 0, 0)
        )
        self.font = pygame.font.Font(None, int(self.W / self.skalar_czcionki) - 15)
        self.info = self.font.render(self.informacja_o_zagadce, True, (0, 0, 0))
        self.zagadka = self.font.render(self.tekst_zagadki, True, (0, 0, 0))

        # odpowiedzi
        self.oA = self.font.render(self.odpowiedz_A, True, (0, 0, 0))
        self.oB = self.font.render(self.odpowiedz_B, True, (0, 0, 0))
        self.oC = self.font.render(self.odpowiedz_C, True, (0, 0, 0))

    def wyswietl_teksty(self, screen):
        screen.fill((255, 255, 255))
        screen.blit(self.podatek, (self.W * 0.18, self.H * 0.2))
        screen.blit(self.info, (self.W * 0.19, self.H * 0.27))
        screen.blit(self.zagadka, (self.W * 0.2, self.H * 0.4))

        # odpowiedzi
        screen.blit(self.oA, (self.W * 0.3, self.H * 0.54))
        screen.blit(self.oB, (self.W * 0.3, self.H * 0.66))
        screen.blit(self.oC, (self.W * 0.3, self.H * 0.78))

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\okno_zastawu.py
from view.okna.okno_bazowe import OknoBazowe
from view.przycisk import Przycisk
import pygame


class OknoZastawu(OknoBazowe):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.pole_png = pygame.transform.scale(
            pygame.image.load("graphics/zastaw.jpg"), (0.28 * self.W, 0.64 * self.H)
        )

        self.kolor_przycisku = (70, 70, 70)
        self.kolor_hovera = (150, 150, 150)

        self.przycisk_zastaw = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.kolor_przycisku,
            self.kolor_hovera,
            "zastaw",
            (255, 255, 255),
        )
        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.kolor_przycisku,
            self.kolor_hovera,
            "wyjscie",
            (255, 255, 255),
        )
        self.czy_zastaw = False

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.czy_zastaw:
            if self.przycisk_zastaw.is_clicked(event):
                self.zastaw()
                # self.czy_zastaw = False
            elif self.wyjscie.is_clicked(event):
                self.czy_zastaw = False

    def wyswietl(self, screen: pygame.Surface):
        if self.czy_zastaw:
            self.pole_png = pygame.transform.scale(
                self.pole_png, (0.28 * self.W, 0.64 * self.H)
            )
            screen.blit(self.pole_png, (self.W * 0.2, self.H * 0.15))
            self.przycisk_zastaw.updateSize(
                self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
            )
            self.wyjscie.updateSize(
                self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
            )
            self.przycisk_zastaw.draw(screen)
            self.wyjscie.draw(screen)

    def akcja_zastawiania(self, gracz):
        self.gracz = gracz

    def zastaw(self):
        self.gracz.zastaw_posiadlosci(self.gra)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\view\okna\__init__.py
# monopoly/view/okna/__init__.py
from .okno_bazowe import OknoBazowe
from .okno_nieruchomosci import OknoNieruchomosci
from .okno_kart import OknoKart
from .okno_wiezienia import OknoWiezienia
from .okno_zagadek import OknoZagadek
from .okno_zastawu import OknoZastawu
from .okno_akcji_pola import OknoAkcjiPola


