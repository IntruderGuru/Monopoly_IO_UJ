C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\Main.py
import os
import pygame
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci
from src.Wizualizator import Wizualizator
from src.Menu import Menu


class Main:
    _SEC_TO_MS = 1000

    def __init__(self):
        pygame.init()  # Inicjalizacja pygame
        pygame.font.init()  # Inicjalizacja modułu fontów

        os.environ["SDL_VIDEO_CENTERED"] = "1"

        self.font = pygame.font.Font(None, 20)

        pygame.display.set_caption("Monopoly")
        self._screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        self._screen_info = pygame.display.Info()
        self._screen_width = self._screen_info.current_w
        self._screen_height = self._screen_info.current_h

        self._gra = None
        self._clock = pygame.time.Clock()
        self._running = True
        self._delta_time = 0
        self.input_text = ""
        self.wizualizator = Wizualizator()
        self.menu = Menu(self.wizualizator)
        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font, self.wizualizator)

    def __del__(self):
        pygame.quit()
        # del self._gra

    def start(self):
        self._kontroler_wiadomosci.dodaj_wiadomosc("Witaj w UJpoly!")
        while self.menu.stan != "stop":

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self._running = False
                elif event.type == pygame.VIDEORESIZE:
                    self._screen_width = event.w
                    self._screen_height = event.h
                self.menu.handle_event(event, self._screen_width, self._screen_height)

            self._screen.fill(self.wizualizator.kolor_tla)
            if self.menu.stan != "stop":
                self.menu.draw(self._screen, self._screen_width, self._screen_height)
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Wprowadź liczbę graczy między (2-5) :"
                )
                self._gra = Gra(
                    self._screen,
                    self._kontroler_wiadomosci,
                    self.menu.liczba_graczy,
                    self.menu.gracze,
                    self.wizualizator,
                    self._screen_width,
                    self._screen_height,
                )
                self._petla_gry()

            pygame.display.flip()

    def _petla_gry(self):
        while self._running:
            self._aktualizuj_delta_time()
            self._petla_zdarzen(pygame.event.get())
            self._aktualizuj(delta_time=self._delta_time)
            self._wyswietlaj()

    def _aktualizuj_delta_time(self):
        self._clock.tick(60)
        self._delta_time = self._clock.get_time() / Main._SEC_TO_MS

    def _petla_zdarzen(self, events_list):
        for event in events_list:
            if event.type == pygame.QUIT:
                self._running = False
                break
            elif event.type == pygame.VIDEORESIZE:
                self._screen_width = event.w
                self._screen_height = event.h

            self._gra.aktualizacja_zdarzenia(event)

    def _aktualizuj(self, delta_time):
        _delta_time = delta_time

    def render_text(self, text, pos):
        text_surface = self.font.render(text, True, self.wizualizator.kolor_czcionki)
        self._screen.blit(text_surface, pos)

    def _wyswietlaj(self):
        self._screen.fill(self.wizualizator.kolor_tla)
        self._gra.wyswietl(self._screen, self._screen_width, self._screen_height)
        pygame.display.update()


if __name__ == "__main__":
    game_runner = Main()
    game_runner.start()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\searcher.py
import os
from pathlib import Path


def get_all_python_files(directory):
    python_files = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".py"):
                python_files.append(Path(root) / file)
    return python_files


def save_files_content_to_text(python_files, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for file in python_files:
            with open(file, "r", encoding="utf-8") as py_file:
                content = py_file.read()
                f.write(f"{file}\n{content}\n\n")


def main():
    directory = "C:/Users/barte/OneDrive/Pulpit/Studia/ROK II/Semestr 4/IO/ProjektFUN/Monopoly_IO_UJ"  # Zmień na właściwą ścieżkę do katalogu
    output_file = "output.txt"

    python_files = get_all_python_files(directory)
    save_files_content_to_text(python_files, output_file)
    print(f"Zapisano zawartość {len(python_files)} plików .py do {output_file}")


if __name__ == "__main__":
    main()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Gra.py
import random
import pygame

from src.okno.AkcjaPolaOkno import AkcjaPolaOkno
from src.okno.AkcjaNieruchomosciOkno import AkcjaNieruchomosciOkno
from src.okno.AkcjaKartOkno import AkcjaKartOkno
from src.okno.AkcjaZastawOkno import AkcjaZastawOkno
from src.okno.AkcjaZagadekOkno import AkcjaZagadekOkno
from src.okno.AkcjaWiezieniaOkno import AkcjaWiezieniaOkno
from src.okno.AkcjaStatystykOkno import AkcjaStatystykOkno
from src.Wizualizator import Wizualizator
from src.Plansza import Plansza
from src.Posiadlosc import *
from src.Pionek import Pionek
from src.KontrolerWiadomosci import KontrolerWiadomosci
from src.interface.IGra import IGra


KWOTA_POCZATKOWA = 10000
MIN_LICZBA_GRACZY = 2
MAX_LICZBA_GRACZY = 5
LICZBA_POL = 40


# Dodajemy listę kolorów dla pionków jako obiekty pygame.Color
PIECE_COLORS: list[pygame.Color] = [
    pygame.Color("red"),
    pygame.Color("green"),
    pygame.Color("blue"),
    pygame.Color("yellow"),
    pygame.Color("purple"),
]


class Gra:
    def __init__(
        self,
        glowne_okno: pygame.Surface,
        kontroler_wiadomosci: KontrolerWiadomosci,
        liczba_graczy: int,
        gracze: list[str],
        wizualizator,
        szerokosc_ekranu,
        wysokosc_ekranu,
    ):
        self._glowne_okno: pygame.Surface = glowne_okno
        self._gracze = [
            Gracz(name, KWOTA_POCZATKOWA, Pionek(0, PIECE_COLORS[i], "graphics/pionek/PionekColor" + str(i + 1) + ".png"))
            for i, name in enumerate(gracze)
        ]
        self._plansza: Plansza = Plansza()
        self._kwota_poczatkowa = KWOTA_POCZATKOWA
        self._liczba_graczy = liczba_graczy
        self._suma_oczek = 0
        self._kolejny_rzut_kostka = False
        self._aktualny_gracz = 1
        self.messages = []
        self.aktualna_szerokosc_ekranu = szerokosc_ekranu
        self.aktualna_wysokosc_ekranu = wysokosc_ekranu
        self._kontroler_wiadomosci = kontroler_wiadomosci
        self.wizualizator = wizualizator

        # sekcja wizualna
        self.kolor_przycisku = self.wizualizator.kolor_przycisku
        self.kolor_gdy_kursor = self.wizualizator.kolor_gdy_kursor
        self.kolor_tekstu = self.wizualizator.kolor_czcionki_na_przycisku
        self.kolor_tla = self.wizualizator.kolor_tla
        self.kolor_czcionki = self.wizualizator.kolor_czcionki
        self.kolor_czcionki_tyl_karty = self.wizualizator.kolor_czcionki_tyl_karty
        self.czcionka = self.wizualizator.czcionka
        self.kolor_nakladki = self.wizualizator.kolor_nakladki
        self.przezroczystosc_nakladki = self.wizualizator.przezroczystosc_nakladki
        self.font = pygame.font.Font(self.czcionka, 20)

        # sekcja okien
        self._plansza = Plansza()

        self.akcja_pola_okno = AkcjaPolaOkno(self)
        self.akcja_nieruchomosci_okno = AkcjaNieruchomosciOkno(self)
        self.akcja_kart_okno = AkcjaKartOkno(self)
        self.akcja_zastaw_okno = AkcjaZastawOkno(self)
        self.akcja_zagadek_okno = AkcjaZagadekOkno(self)
        self.akcja_wiezienie_okno = AkcjaWiezieniaOkno(self)
        self.akcja_statystyk_okno = AkcjaStatystykOkno(self)
        self.czy_akcja_zakonczona = True

        # feature_testingMechanism
        self.input_text = ""
        print("HELLO from Gra")


    def wybierz_kolejnego_gracza(self):
        self._suma_oczek = 0
        poczatkowy_gracz = self._aktualny_gracz

        while True:
            if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
                self._czy_gracz_ma_ture = True
                break
            else:
                self._gracze[self._aktualny_gracz - 1].odczekajJednaTure()
                if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
                    self._kontroler_wiadomosci.dodaj_wiadomosc(
                        f"Gracz {self._aktualny_gracz} opuszcza więzienie po dwóch turach"
                    )
                self._aktualny_gracz = (self._aktualny_gracz % self._liczba_graczy) + 1
                self._suma_oczek = 0
                if self._aktualny_gracz == poczatkowy_gracz:
                    self._kontroler_wiadomosci.dodaj_wiadomosc(
                        "Wszyscy gracze są w więzieniu. Przechodzimy do następnej tury."
                    )
                    break

    def analizuj_rzut(self, kostka_pierwsza, kostka_druga):
        if kostka_pierwsza + kostka_druga == 7:
            self._kolejny_rzut_kostka = True
            self._kontroler_wiadomosci.dodaj_wiadomosc("Siódemka, rzuć jeszcze raz")
        else:
            self._kolejny_rzut_kostka = False

        if self._suma_oczek == 21:
            self._kontroler_wiadomosci.dodaj_wiadomosc("Idziesz do więzienia")
            self._gracze[self._aktualny_gracz - 1].pozycja = 10
            self.przesun_gracza_bez_raportu(self._gracze[self._aktualny_gracz - 1], 10)
            self._gracze[self._aktualny_gracz - 1].uwiezienie = True
            self._gracze[self._aktualny_gracz - 1].tury_w_wiezieniu = 0
            self._kolejny_rzut_kostka = False
            self._suma_oczek = 0

    def przesun_gracza(self, gracz, ruch):
        stara_pozycja = gracz.pionek.numer_pola
        nowa_pozycja = (stara_pozycja + ruch) % LICZBA_POL
        gracz.pionek.przesun(ruch)
        gracz.czy_przeszedl_przez_start(self, stara_pozycja)

        self._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {gracz.id} przesunął się z pozycji {stara_pozycja} na {nowa_pozycja}"
        )

        pole = self._plansza.pobierz_pole(nowa_pozycja)
        self.wykonaj_akcje_na_polu(gracz, pole)


    def przesun_gracza_bez_raportu(self, gracz, nowa_pozycja):
        stara_pozycja = gracz.pionek.numer_pola
        gracz.pionek.przesun(40 - stara_pozycja + nowa_pozycja) % LICZBA_POL

    def akcja_kupienia_nieruchomosci(self, gracz, posiadlosc, nr_pola=1):
        if posiadlosc.kolor == "kolo" or posiadlosc.kolor == "pozaWmii":
            return
        if not gracz.caly_kolor(posiadlosc.kolor):
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie posiadasz wszystkich kart z koloru, dlatego nie możesz jeszcze kupić domku"
            )
            return
        if posiadlosc.czy_zastawiona:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie można kupić domku lub hotelu na zastawionej posiadłości"
            )
            return

        nieruchomosc = gracz.czy_cztery_domki(posiadlosc)
        if nieruchomosc == "nie":
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Masz już 4 domki na tej posiadłości, aby kupić hotel, musisz mieć 4 domki na każdej posiadłości w kolorze {posiadlosc.kolor}"
            )
            return

        self.akcja_nieruchomosci_okno.czy_kupno = True
        self.akcja_nieruchomosci_okno.nieruchomosc = nieruchomosc

    def wykup_z_wiezienia_rzutem(self):
        liczba_siodemek = 0
        for x in range(3):
            kostka_pierwsza = random.randint(1, 6)
            kostka_druga = random.randint(1, 6)
            suma += kostka_pierwsza + kostka_druga
            if suma == 7:
                liczba_siodemek += 1
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}, Kostka druga: {kostka_druga}"
            )
        if liczba_siodemek < 2:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Niestety, wyrzuciłeś tylko {liczba_siodemek} siódemek. Nie udało Ci się wykupić z więzienia, musisz odsiedzieć wyrok"
            )
            return False
        self._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gratulacje! Wyrzuciłeś {liczba_siodemek} siódemek. Udało Ci się wykupić z więzienia"
        )
        return True

    def wykonaj_akcje_na_polu(self, gracz, pole):
        self._kontroler_wiadomosci.dodaj_wiadomosc(pole.zwroc_info())

        if pole.typ == "Podatek dochodowy":
            self.czy_akcja_zakonczona = False
            self.akcja_zagadek_okno.akcja_podatkowa(gracz, pole)
            self.akcja_zagadek_okno.przygotuj_zagadke()
            self.akcja_zagadek_okno.czy_zagadka = True

        elif pole.typ == "Szansa":
            self.czy_akcja_zakonczona = False
            self.akcja_kart_okno.czy_szansa = True
            karta = self._plansza.karty.nastepna_karta()
            karta.wyswietl_tresc(self)
            karta.wykonaj_akcje(self, gracz)

        elif pole.typ == "Wiezienie":
            self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz odwiedza więzienie")

        # TODO: mozliwosc wykupienia sie z wiezienia za pomoca wyrzucenia 2 siodemek na 3 rzuty kostka
        elif pole.typ == "idz_do_wiezienia":

            self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz idzie do więzienia")
            if self.wykup_z_wiezienia_rzutem():
                return
            if not gracz.liczba_kart_wyjdz_z_wiezienia:
                self.czy_akcja_zakonczona = False
                self.akcja_wiezienie_okno.czy_wiezienie = True
                gracz.uwiezienie = True
                self.przesun_gracza_bez_raportu(
                    self._gracze[self._aktualny_gracz - 1], 10
                )
            else:
                gracz.liczba_kart_wyjdz_z_wiezienia -= 1
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Wykorzystano kartę 'wyjdź bezpłatnie z więzienia'"
                )

        elif pole.typ == "Posiadlosc":
            if isinstance(pole, Posiadlosc):
                posiadlosc = pole
                posiadlosc.wyswietl_info(self)
                if posiadlosc.wlasciciel is None:
                    self.czy_akcja_zakonczona = False
                    self.akcja_pola_okno.czy_akcja_pola = True
                    self.akcja_pola_okno.akcja_kupowania(posiadlosc, gracz)
                elif posiadlosc.wlasciciel == gracz.id:
                    self.czy_akcja_zakonczona = False
                    self.akcja_kupienia_nieruchomosci(gracz, posiadlosc)
                    self.akcja_nieruchomosci_okno.akcja_kupowania(posiadlosc, gracz)
                else:
                    self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz płaci czynsz")
                    gracz.zaplac_czynsz(self, posiadlosc)
            else:
                raise Exception("Błąd. Posiadłość jest innym polem")

    def tura(self):
        if not self._kolejny_rzut_kostka:
            self.wybierz_kolejnego_gracza()

        if not self._gracze[self._aktualny_gracz - 1].uwiezienie:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Ruch gracza: {self._aktualny_gracz}"
            )

            kostka_pierwsza = random.randint(1, 6)
            kostka_druga = random.randint(1, 6)
            self._suma_oczek += kostka_pierwsza + kostka_druga

            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}, Kostka druga: {kostka_druga}"
            )
            self._kontroler_wiadomosci.dodaj_wiadomosc(f"Suma: {self._suma_oczek}")

            self.analizuj_rzut(kostka_pierwsza, kostka_druga)
            self.przesun_gracza(
                self._gracze[self._aktualny_gracz - 1], kostka_pierwsza + kostka_druga
            )
        else:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {self._aktualny_gracz} jest w więzieniu."
            )
            self.wybierz_kolejnego_gracza()

        if not self._kolejny_rzut_kostka:
            self._aktualny_gracz = (self._aktualny_gracz % self._liczba_graczy) + 1
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Teraz tura gracza: {self._aktualny_gracz}"
            )

    def get_messages(self):
        messages = self.messages.copy()
        self.messages.clear()
        return messages

    # override
    def aktualizacja(self):
        pass
        # if not self._stos_otwartych_okien.czy_pusty():
        #     self._stos_otwartych_okien.gora().aktualizacja()

        # if not self.akcja_pola_okno.czy_koniec_zakupu():
        #     self._czy_gracz_ma_ture = False
        #     self._stos_otwartych_okien.usun()

    def process_input(self, input_text):
        self._kontroler_wiadomosci.dodaj_wiadomosc(f"Wprowadzono: {input_text}")
        if input_text.isdigit():
            liczba_graczy = int(input_text)
            if liczba_graczy >= 2 and liczba_graczy <= 5:
                self._liczba_graczy = liczba_graczy
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"Ustaw liczbe graczy na {liczba_graczy}"
                )
                self.przygotuj_graczy()
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Naciśnij spację, aby rzucić kostką"
                )
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Nieprawidłowa liczba graczy."
                )
        else:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Nieznana komenda: {input_text}"
            )

    # metoda pomocnicza w celu wykonania pojdynczego zdarzenia
    # oddzielona od aktualizacja_zdarzenia, na rzecz architektury i wykorzystania klasy GraProxy(event injection, tracking)
    def wykonaj_zdarzenie(self, event: pygame.event.Event):
        if (
            event.type == pygame.KEYDOWN
            and event.key == pygame.K_SPACE
            and self.czy_akcja_zakonczona
        ):
            self.tura()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                self.process_input(self.input_text)
                self.input_text = ""
            elif event.key == pygame.K_BACKSPACE:
                self.input_text = self.input_text[:-1]
            else:
                self.input_text += event.unicode
        elif event.type == pygame.VIDEORESIZE:
            self.aktualna_szerokosc_ekranu = event.w
            self.aktualna_wysokosc_ekranu = event.h

        self.akcja_pola_okno.aktualizacja_zdarzen(event)
        self.akcja_nieruchomosci_okno.aktualizacja_zdarzen(event)
        self.akcja_kart_okno.aktualizacja_zdarzen(event)
        self.akcja_zastaw_okno.aktualizacja_zdarzen(event)
        self.akcja_zagadek_okno.aktualizacja_zdarzen(event)
        self.akcja_wiezienie_okno.aktualizacja_zdarzen(event)

    # override
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        self.wykonaj_zdarzenie(event)

    def render_text(self, text, pos):
        text_surface = self.font.render(text, True, (0, 0, 0))
        self._glowne_okno.blit(text_surface, pos)

    # override
    def wyswietl(self, okno: pygame.Surface, W, H):

        self.aktualizuj_rozmiar_okien()

        self.render_text(
            self.input_text,
            (self.aktualna_szerokosc_ekranu - 400, self.aktualna_wysokosc_ekranu - 50),
        )

        self._plansza.render(self._glowne_okno)

        for gracz in self._gracze:
            gracz.pionek.wyswietl(self._glowne_okno)

        self.akcja_statystyk_okno.wyswietl(self._glowne_okno)
        self._kontroler_wiadomosci.wyswietl(okno, W, H)
        self.akcja_pola_okno.wyswietl(self._glowne_okno)
        self.akcja_nieruchomosci_okno.wyswietl(self._glowne_okno)
        self.akcja_kart_okno.wyswietl(self._glowne_okno)
        self.akcja_zastaw_okno.wyswietl(self._glowne_okno)
        self.akcja_zagadek_okno.wyswietl(self._glowne_okno)
        self.akcja_wiezienie_okno.wyswietl(self._glowne_okno)

    def aktualizuj_rozmiar_okien(self):
        self.akcja_pola_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_nieruchomosci_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_kart_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_zagadek_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_wiezienie_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_zastaw_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_statystyk_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Gracz.py
from src.Statystyka import Statystyka

class Gracz:
    def __init__(self, id, kwota, pionek):
        self.id = id
        self.kwota = kwota
        self.pionek = pionek
        self.pozycja = 0
        self.uwiezienie = False
        self.tury_w_wiezieniu = 0  # Licznik tur w więzieniu
        self.liczba_kart_wyjdz_z_wiezienia = 0
        self.lista_posiadlosci = []
        self.liczba_zastawionych = 0
        self.statystyka = Statystyka(kwota, self.id)

    def odczekajJednaTure(self):
        if self.uwiezienie:
            self.tury_w_wiezieniu += 1
            if self.tury_w_wiezieniu >= 2:
                self.uwiezienie = False
                self.tury_w_wiezieniu = 0
                print(f"Gracz {self.id} opuszcza więzienie po dwóch turach")

    # TODO: wczytanie numeru zastawianej posiadlosci
    def zastaw_posiadlosci(self, gra):
        if self.liczba_zastawionych >= len(self.lista_posiadlosci):
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz już posiadłości, które mógłbyś zastawić"
            )
            gra.akcja_zastaw_okno.czy_zastaw = False
            return

        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            "To wszystkie Twoje posiadłości, które możesz zastawić:"
        )
        for posiadlosc in self.lista_posiadlosci:
            if not posiadlosc.czy_zastawiona:
                posiadlosc.wyswietl_info(gra)

        # wczytanie numeru, sprawdzenie czy numer jest dobry
        x = 0
        self.lista_posiadlosci[x].czy_zastawiona = True
        self.liczba_zastawionych += 1
        self.kwota += self.lista_posiadlosci[x].zastaw_kwota
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)

    def zdejmij_zastaw_posiadlosci(self, gra):
        if self.liczba_zastawionych == 0:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz zastawionych posiadlosci"
            )
            gra.akcja_zastaw_okno.czy_zdejmij_zastaw = False
            return

        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            "To wszystkie Twoje posiadłości, które masz zastawione:"
        )
        for posiadlosc in self.lista_posiadlosci:
            if posiadlosc.czy_zastawiona:
                posiadlosc.wyswietl_info(gra)

        # wczytanie numeru, sprawdzenie czy numer jest dobry
        x = 0
        cena = self.lista_posiadlosci[x].zastaw_kwota * 1.2
        if self.kwota >= cena:
            self.lista_posiadlosci[x].czy_zastawiona = False
            self.liczba_zastawionych -= 1
            self.kwota -= cena
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz wystarczająco dużo pieniędzy, aby zdjąć zastaw z posiadłości"
            )
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)

    def zaplac_czynsz(self, gra, posiadlosc):
        czynsz = posiadlosc.oblicz_czynsz(gra)
        self.wykonaj_oplate(gra, czynsz)
        posiadlosc.wlasciciel.dodaj_pieniadze(gra, czynsz)

    def ile_w_kolorze(self, kolor):
        liczba_w_kolorze = 0
        for posiadlosc in self.lista_posiadlosci:
            if not posiadlosc.kolor == kolor:
                liczba_w_kolorze += 1
        return liczba_w_kolorze

    def caly_kolor(self, kolor):
        if kolor == "brazowy" or kolor == "granatowy" or kolor == "pozaWmii":
            return self.ile_w_kolorze(kolor) == 2
        else:
            return self.ile_w_kolorze(kolor) == 3

    def czy_cztery_domki(self, posiadlosc):
        if posiadlosc.liczba_domow < 4:
            return "domek"

        liczba_domkow_w_kolorze = 0
        for pole in self.lista_posiadlosci:
            if not pole.kolor == pole.kolor:
                liczba_domkow_w_kolorze += pole.liczba_domow

        if posiadlosc.kolor == "brazowy" or posiadlosc.kolor == "granatowy":
            if liczba_domkow_w_kolorze < 8:
                return "nie"
            return "hotel"
        else:
            if liczba_domkow_w_kolorze < 12:
                return "nie"
            return "hotel"

    def wykonaj_oplate(self, gra, cena):
        if cena > self.kwota:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Brakuje Ci {cena - self.kwota} pieniędzy. Czy chcesz zastawić którąś z posiadłości?"
            )
            gra.akcja_zastaw_okno.czy_zastaw = True
            gra.akcja_zastaw_okno.akcja_zastawiania(self)
        else:
            self.kwota -= cena
            self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)
            return 1
        
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)
        return 0

    def dodaj_pieniadze(self, gra, cena):
        self.kwota += cena
        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {self.id} otrzymał {cena} pieniędzy"
        )
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)

    def czy_przeszedl_przez_start(self, gra, stara_pozycja):
        if self.pionek.numer_pola < stara_pozycja and self.uwiezienie == False:
            self.dodaj_pieniadze(gra, 2000)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\KartaSzansy.py
import random


class KartaSzansy:
    def __init__(self, typ, tresc, wartosc=0):
        self.typ = typ
        self.tresc = tresc
        self.wartosc = wartosc

    def wyswietl_tresc(self, gra):
        gra._kontroler_wiadomosci.dodaj_wiadomosc(self.tresc)

    def wykonaj_akcje(self, gra, gracz):
        if self.typ == "pobierz":
            gracz.dodaj_pieniadze(gra, self.wartosc)

        elif self.typ == "pobierz_od_graczy":
            for g in gra._gracze:
                if g.id != gracz.id:
                    g.wykonaj_oplate(gra, self.wartosc)
                    gracz.dodaj_pieniadze(gra, self.wartosc)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} otrzymuje {self.wartosc} zł od każdego gracza"
            )

        elif self.typ == "oplata":
            gracz.wykonaj_oplate(gra, self.wartosc)

        elif self.typ == "oplata_za_domki":
            liczba_domkow = 0
            liczba_hoteli = 0
            for pole in gracz.lista_posiadlosci:
                liczba_domkow += pole.liczba_domow
                liczba_hoteli += pole.liczba_hoteli
            cena = liczba_domkow * self.wartosc
            cena += liczba_hoteli * self.wartosc * 3
            gracz.wykonaj_oplate(gra, cena)

        elif self.typ == "przejdz_na_pole":
            stara_pozycja = gracz.pionek.numer_pola
            ruch = (stara_pozycja - self.wartosc) % 40
            gra.przesun_gracza(gracz, ruch)

        # brak poboru oplaty za przejscie przez start
        elif self.typ == "cofnij_na_pole":
            gra.przesun_gracza_bez_raportu(gracz, self.wartosc)

        elif self.typ == "cofnij_do_wiezienia":
            gracz.uwiezienie = True
            gra.przesun_gracza_bez_raportu(gracz, 10)

        elif self.typ == "karta_wyjscie_z_wiezienia":
            gracz.liczba_kart_wyjdz_z_wiezienia += 1


class Karty:
    def __init__(self):
        self.karty = self.wczytaj_karty("data/karty.txt")
        random.shuffle(self.karty)
        self.current_index = 0

    def wczytaj_karty(self, plik: str) -> list[KartaSzansy]:
        karty = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 2 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda karta powinna mieć 3 linie danych."
                    )
                typ = lines[i].strip()
                tresc = lines[i + 1].strip()
                wartosc = int(lines[i + 2].strip())
                karta = KartaSzansy(typ, tresc, wartosc)
                karty.append(karta)
                i += 4
        return karty

    def nastepna_karta(self):
        karta = self.karty[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.karty)
        return karta


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\KontrolerWiadomosci.py
import pygame
from src.Wizualizator import Wizualizator


class KontrolerWiadomosci:
    MAKSYMALNA_ILOSC_WIADOMOSCI = 8

    def __init__(self, font, wizualizator):
        self.wiadomosci: list[str] = list()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0
        self.font: pygame.font.Font = font
        self.wizualizator = wizualizator
        self.W = 1200
        self.H = 800
        self.skalar_czcionki = 60 # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / self.skalar_czcionki))

    def _render_text(self, text: str, pos, okno: pygame.Surface, ostatnia_wiadomosc):

        if ostatnia_wiadomosc:
            self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki - 15)))
            text_surface = self.font.render(text, True, self.wizualizator.kolor_ostatniej_wiadomosci)
        else:
            self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / self.skalar_czcionki))
            text_surface = self.font.render(text, True, self.wizualizator.kolor_wiadomosci)
        okno.blit(text_surface, pos)

    def dodaj_wiadomosc(self, tresc: str):

        if self.ilosc_wiadomosci < KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI:
            self.ilosc_wiadomosci += 1
            self.wiadomosci.append(tresc)
        else:
            self.wiadomosci[self.ostatnia_pozycyjnie_wiadomosc_index] = tresc
            self.ostatnia_pozycyjnie_wiadomosc_index = (
                self.ostatnia_pozycyjnie_wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI

    def usun_wszystkie_wiadomosci(self):
        self.wiadomosci.clear()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0

    def wyswietl(self, okno: pygame.Surface, W, H):

        self.H = H
        self.W = W

        y_offset = 0.06

        wiadomosc_index = self.ostatnia_pozycyjnie_wiadomosc_index
        wiadomosc_index_end = (
            (self.ostatnia_pozycyjnie_wiadomosc_index - 1)
            % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            if self.ilosc_wiadomosci == KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            else self.ilosc_wiadomosci - 1
        )

        wiadomosc_number = 0
        i = 0
        ostatnia_wiadomosc = False
        while wiadomosc_number < self.ilosc_wiadomosci:

            if wiadomosc_number == self.ilosc_wiadomosci - 1:
                ostatnia_wiadomosc = True

            # while wiadomosc_index != wiadomosc_index_end:
            wiadomosc = self.wiadomosci[wiadomosc_index]

            if isinstance(wiadomosc, str | bytes):
                self._render_text(wiadomosc, (W * 0.595, H * (0.45 + (i * y_offset))), okno, ostatnia_wiadomosc)

            wiadomosc_index = (
                wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            wiadomosc_number += 1
            i += 1

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Menu.py
import pygame
from src.Przycisk import Przycisk
from src.PrzyciskiMenu import PrzyciskiMenu
from src.Wizualizator import Wizualizator


class Menu:
    def __init__(self, wizualizator):
        self.stan = "witaj"
        self.liczba_graczy = 0
        self.gracze = []
        self.wizualizator: Wizualizator = wizualizator
        self.font = pygame.font.Font(self.wizualizator.czcionka, 32)
        self.H = 800
        self.W = 1200

        self.przyciski = PrzyciskiMenu(self.H, self.W, self.wizualizator)

        self.logo = pygame.transform.scale(
            pygame.image.load("graphics/logo.png"), (0.5 * self.W, 0.5 * self.H)
        )

        self.skalar_czcionki = 22  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / self.skalar_czcionki))
        self.font_gracze = pygame.font.Font(self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 5)))

    def handle_event(self, event, W, H):

        self.W = W
        self.H = H
        self.przyciski.aktualizuj_rozmiar(self.W, self.H)

        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.stan == "witaj":
                if self.przyciski.nowa_gra.is_clicked(event):
                    self.stan = "liczba_graczy"
                elif self.przyciski.wyjscie.is_clicked(event):
                    pygame.quit()

            elif self.stan == "liczba_graczy":
                if self.przyciski.two.is_clicked(event):
                    self.liczba_graczy = 2
                elif self.przyciski.three.is_clicked(event):
                    self.liczba_graczy = 3
                elif self.przyciski.four.is_clicked(event):
                    self.liczba_graczy = 4
                elif self.przyciski.five.is_clicked(event):
                    self.liczba_graczy = 5

                if self.liczba_graczy > 1:
                    self.stan = "nazwy_graczy"
                    self.gracze.append("")

        elif event.type == pygame.KEYDOWN:
            
            if event.key == pygame.K_ESCAPE:
                pygame.quit()

            if self.stan == "nazwy_graczy":
                if event.key == pygame.K_RETURN:
                    if len(self.gracze) < self.liczba_graczy:
                        self.gracze.append("")
                    else:
                        self.stan = "stop"
                elif event.key == pygame.K_BACKSPACE:
                    self.gracze[-1] = self.gracze[-1][:-1]
                else:
                    self.gracze[-1] += event.unicode


    def draw(self, screen, W, H):

        self.font = pygame.font.Font(self.wizualizator.czcionka, int(W / self.skalar_czcionki))
        self.font_gracze = pygame.font.Font(self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 5)))

        if self.stan == "witaj":
            self.przyciski.nowa_gra.draw(screen)
            self.przyciski.wczytaj_gre.draw(screen)
            self.przyciski.wyjscie.draw(screen)

            self.logo = pygame.transform.scale(self.logo, (0.5 * W, 0.3 * H))
            screen.blit(self.logo, (W * 0.25, H * 0.05))

        elif self.stan == "liczba_graczy":
            self.przyciski.two.draw(screen)
            self.przyciski.three.draw(screen)
            self.przyciski.four.draw(screen)
            self.przyciski.five.draw(screen)

            text = self.font.render(
                "Wybierz liczbę graczy",
                True,
                self.wizualizator.kolor_czcionki,
            )

            screen.blit(text, (W * 0.32, H * 0.35))

        elif self.stan == "nazwy_graczy":
            text = self.font.render(
                "Wprowadź nazwę gracza: " + str(len(self.gracze)),
                True,
                self.wizualizator.kolor_czcionki
            )
            screen.blit(text, (W * 0.3, H * 0.35))
            
            odstep = 0.05
            ile_wpisanych = len(self.gracze)

            for i in range(0, len(self.gracze)):

                if i < ile_wpisanych - 1:
                    kolor_czcionki = self.wizualizator.kolor_akceptacji_nazwy_gracza
                else:
                    kolor_czcionki = self.wizualizator.kolor_czcionki

                gracz = self.font_gracze.render(
                    str(self.gracze[i]),
                    True,
                    kolor_czcionki
                )
                screen.blit(gracz, (W * 0.45, H * (0.45 + (i * odstep))))
            


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Odpowiedz.py
from enum import Enum

class Odpowiedz(Enum):
    Odpowiedz_A = 0
    Odpowiedz_B = 1
    Odpowiedz_C = 2

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Pionek.py
import pygame
from enum import Enum
from typing import NamedTuple


class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pionek:
    MIN_LICZBA_OCZEK = 2
    MAX_LICZBA_OCZEK = 12
    DLUGOSC_SCIANKI_W_POLACH = 10
    LICZBA_POL = 40

    MALE_POLE_WYMIARY: Vector2 = Vector2(30, 50)
    # warning: najlepiej gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(50, 50)
    OFF_SET: Vector2 = Vector2(100, 100)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    def __init__(self, numer_pola: int, color: pygame.color, grafika: str):
        self.numer_pola = numer_pola
        self.color = color
        self.sciezka_do_grafiki = grafika
        self.kierunek: KierunekPol = KierunekPol.Gora
        self.wymiary: Vector2 = Vector2(20, 20)
        self.pozycja: Vector2 = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)
        self.zdjecie_pionek = pygame.transform.scale(
            pygame.image.load(self.sciezka_do_grafiki), (self.wymiary.x, self.wymiary.y)
        )

        
    @staticmethod
    def oblicz_nowa_pozycje(numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pionek.OFF_SET.x
        gora = Pionek.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += ((Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING) if numer_pola % 10 != 0 else 0)
                lewo += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING))

            case KierunekPol.Prawo:
                lewo += 9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING
                gora += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING))
                gora += ((Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING) if numer_pola % 10 != 0 else 0)

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                lewo += (Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING)       # Czemu dziala nie mam bladego pojecia
                gora += 9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING

            case KierunekPol.Lewo:
                gora += (9 - (numer_pola % 10)) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING

        return Vector2(lewo, gora)


    def przesun(self, liczba_pol: int) -> bool:
        if Pionek.MIN_LICZBA_OCZEK <= liczba_pol <= Pionek.MAX_LICZBA_OCZEK:
            self.numer_pola = (self.numer_pola + liczba_pol) % Pionek.LICZBA_POL
            self.kierunek = KierunekPol(self.numer_pola // Pionek.DLUGOSC_SCIANKI_W_POLACH)
            self.pozycja = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)

            return True

        return False

    def wyswietl(self, okno: pygame.Surface):
        #pygame.draw.rect(okno, self.color, pygame.Rect(self.pozycja.x, self.pozycja.y, self.wymiary.x, self.wymiary.y))
        okno.blit(self.zdjecie_pionek, (self.pozycja.x, self.pozycja.y))



C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Plansza.py
import pygame.color

from src.Pole import Pole
from src.Pionek import Pionek
from src.Posiadlosc import Posiadlosc
from src.KartaSzansy import *
from src.PodatekDochodowy import Zagadki
from src.PodatekDochodowy import PodatekDochodowy


class Plansza:
    @staticmethod
    def inicializacja_planszy() -> list[Pole]:
        board: list[Pole] = list()
        board.append(Pole(0, "Start"))
        board.append(Posiadlosc(1, "Automat z kawą", "brazowy", 600, 20, 300, 500))
        board.append(Pole(2, "Szansa"))
        board.append(Posiadlosc(3, 'Bistro "Świetlica"', "brazowy", 600, 40, 300, 500))
        board.append(PodatekDochodowy(4, 1000))
        board.append(Posiadlosc(5, "KNRSI", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(6, "Parking", "niebieski", 1000, 60, 500, 500))
        board.append(Pole(7, "Szansa"))
        board.append(Posiadlosc(8, "Winda", "niebieski", 1000, 60, 500, 500))
        board.append(Posiadlosc(9, "Szatnia", "niebieski", 1200, 80, 500, 500))
        board.append(Pole(10, "Wiezienie"))
        board.append(Posiadlosc(11, "Sala 1073 (sieci)", "rozowy", 1400, 100, 700, 1000))
        board.append(Posiadlosc(12, "Drążki za wydziałem", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(13, "Sala 0056 (laby)", "rozowy", 1400, 100, 700, 1000))
        board.append(Posiadlosc(14, "Sala 1072 (macbooki)", "rozowy", 1600, 120, 800, 1000))
        board.append(Posiadlosc(15, "KNMF", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(16, "Ślimak", "pomaranczowy", 1800, 140, 900, 1000))
        board.append(Pole(17, "Szansa"))
        board.append(Posiadlosc(18, "Serwerownia", "pomaranczowy", 1800, 140, 900, 1000))
        board.append(Posiadlosc(19, "Pokój samorządu", "pomaranczowy", 2000, 160, 1000, 1000))
        board.append(Pole(20, "Parking"))
        board.append(Posiadlosc(21, "Recepcja", "czerwony", 2200, 180, 1100, 1500))
        board.append(Pole(22, "Szansa"))
        board.append(Posiadlosc(23, "Dziekanat","czerwony", 2200, 180, 1100, 1500))
        board.append(Posiadlosc(24, "Muzeum komputerów", "czerwony", 2400, 200, 1200, 1500))
        board.append(Posiadlosc(25, "KMS", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(26, "Mural", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(27, "Pomnik Kopernika", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(28, "Przejście przez WZIKS", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(29, "Fontanna", "zolty", 2800, 240, 1400, 1500))
        board.append(Pole(30, "Idz do wiezienia"))
        board.append(Posiadlosc(31, "Ping-pong", "zielony", 3000, 260, 1500, 2000))
        board.append(Posiadlosc(32, "Bilard", "zielony", 3000, 260, 1500, 2000))
        board.append(Pole(33, "Szansa"))
        board.append(Posiadlosc(34, "Piłkarzyki", "zielony", 3200, 280, 1600, 2000))
        board.append(Posiadlosc(35, "KSI", "kolo", 2000, 250, 1000))
        board.append(Pole(36, "Szansa"))
        board.append(Posiadlosc(37, "sala 0004", "granatowy", 3500, 350, 1750, 2000))
        board.append(PodatekDochodowy(38, 500))
        board.append(Posiadlosc(39, "sala 0089", "granatowy", 4000, 500, 2000, 2000))

        return board

    def __init__(self):
        self.plansza: [Pole] = self.inicializacja_planszy()
        self.karty = Karty()
        self.zagadki = Zagadki()
        self.wczytaj_grafiki()

    def pobierz_pole(self, numer_pola):
        if 0 <= numer_pola <= len(self.plansza):
            return self.plansza[numer_pola]
        else:
            raise Exception("Bledny numer pola")

    # def wysrodkuj_pionki(self):
    #
    # def wysrodkuj_plansze(self):

    # def update(self):

    def render(self, screen):
        for pole in self.plansza:
            pole.render(screen)

    def wczytaj_grafiki(self):
        i = 0
        path = "graphics/pola/pole_"
        extension = ".png"

        for pole in self.plansza:
            pole.sciezka_do_grafiki = (path + str(i) + extension) 
            i += 1



    


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\PodatekDochodowy.py
from src.Pole import Pole
from src.Gracz import Gracz
from numpy import random
from src.Odpowiedz import Odpowiedz


class Zagadka:
    def __init__(
        self,
        tresc_zagadki: str,
        odpowiedz_a: str,
        odpowiedz_b: str,
        odpowiedz_c: str,
        poprawna: Odpowiedz,
    ) -> None:
        self.tresc_zagadki = tresc_zagadki
        self.odpowiedz_a = odpowiedz_a
        self.odpowiedz_b = odpowiedz_b
        self.odpowiedz_c = odpowiedz_c
        self.poprawna = poprawna


class Zagadki:

    def __init__(self) -> None:
        self.lista_zagadek = self.wczytaj_zagadki("data/zagadki.txt")
        self.permutacja = random.permutation(self.lista_zagadek)
        self.ind = 0

    def nastepna_zagadka(self) -> Zagadka:
        curr = self.ind
        self.ind = (self.ind + 1) % len(self.lista_zagadek)
        return self.permutacja[curr]

    def wczytaj_zagadki(self, plik: str) -> list[Zagadka]:
        zagadki = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 4 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda zagadka powinna mieć 5 linii danych."
                    )
                tresc = lines[i].strip()
                odpowiedz_a = lines[i + 1].strip()
                odpowiedz_b = lines[i + 2].strip()
                odpowiedz_c = lines[i + 3].strip()
                poprawna = lines[i + 4].strip()
                zagadka = Zagadka(
                    tresc, odpowiedz_a, odpowiedz_b, odpowiedz_c, poprawna
                )
                zagadki.append(zagadka)
                i += 6
        return zagadki


class PodatekDochodowy(Pole):

    def __init__(self, numer: int, podatek: int) -> None:
        super().__init__(numer, "Podatek dochodowy")
        self.podatek = podatek

    def wyswietl_info(self) -> str:
        return f"Stanąłeś na polu podatek dochodowy. Musisz zapłacić podatek w wysokości {self.podatek}"

    def zaplac_podatek(self, gra, gracz: Gracz, czy_dobra: bool) -> None:
        do_zaplaty = self.podatek
        if czy_dobra:
            do_zaplaty /= 2

        if do_zaplaty > gracz.kwota:
            if gra.pobierz_info_tak_nie(
                "Nie masz wystarczająco dużo pieniędzy, aby zapłacić podatek. Czy chcesz zastawić którąś z nieruchmości? Jeśli tego nie zrobisz przegrywasz."
            ):
                gracz.zastaw_nieruchomosci()
        if do_zaplaty > gracz.kwota:
            gra.messages.append("Bankrutujesz")
        gracz.kwota -= do_zaplaty
        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            "Podatek został zapłacony, zapłacono: " + str(do_zaplaty)
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Pole.py
import pygame
from typing import NamedTuple
from enum import Enum


# TODO: Do usuniecia, korzystanie z jednego enuma z Pionka, problem z kolejnoscia wystepowania
# TODO: atrybutow w enumie w Pionku, zla kolejnosc, poprawna ponizej
class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pole:
    WYMIAR_NAGLOWKA: Vector2 = Vector2(30, 50)
    MALE_POLE_WYMIARY: Vector2 = Vector2(30, 50)
    # warning: najlepiej gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(50, 50)
    KOLOR_TLA = pygame.Color(28,28,30,255)
    OFF_SET: Vector2 = Vector2(100, 100)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    """
    numer_pola - nr. id pola [0, maksymalna_liczba_pol)
    dlugosc_sciany_w_polach - ilosc pol na jednym z czterech brzegow planszy, /*??odejmowana jest 1 do liczenia orientacji??*/, zakladamy ze plansza jest kwadratem 
    maksymalna_liczba_pol - ilosc pol na planszy
    """
    @staticmethod
    def oblicz_zwrot_naglowka_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> KierunekPol:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return KierunekPol((numer_pola % maksymalna_liczba_pol) // dlugosc_sciany_w_polach)

    @staticmethod
    def oblicz_rozmiar_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> Vector2:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return Pole.DUZE_POLE_WYMIARY if (numer_pola % dlugosc_sciany_w_polach) == 0 else Pole.MALE_POLE_WYMIARY

    @staticmethod
    def inicjalizacja_pozycji(numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pole.OFF_SET.x
        gora = Pole.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += ((Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING) if numer_pola % 10 != 0 else 0)
                lewo += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))

            case KierunekPol.Prawo:
                lewo += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING
                gora += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))
                gora += ((Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING) if numer_pola % 10 != 0 else 0)

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING)
                lewo += (Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING)       # Czemu dziala nie mam bladego pojecia
                gora += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

            case KierunekPol.Lewo:
                gora += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

        return Vector2(lewo, gora)

    def __init__(self, numer: int, typ: str):
        self.numer = numer
        self.typ = typ
        self.kolor_naglowka = pygame.color.THECOLORS["violet"]
        self.wymiary: Vector2 = self.oblicz_rozmiar_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.kierunek_sciany = self.oblicz_zwrot_naglowka_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.pozycja: Vector2 = self.inicjalizacja_pozycji(self.numer, self.kierunek_sciany)
        self.sciezka_do_grafiki = "..."

    def zwroc_info(self) -> str:
        return f"Nazwa: {self.typ}"

    def render(self, screen):
        szerokosc_aktualny_kierunek = self.wymiary.x if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.y
        wysokosc_aktualny_kierunek = self.wymiary.y if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.x
        
        if self.numer in (0, 10, 20, 30):
            pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), self.DUZE_POLE_WYMIARY)
        elif self.kierunek_sciany == KierunekPol.Dol:
            pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), self.MALE_POLE_WYMIARY)
        elif self.kierunek_sciany == KierunekPol.Lewo:
            pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), self.MALE_POLE_WYMIARY)
            pole_surface = pygame.transform.rotate(pole_surface, 270)
        elif self.kierunek_sciany == KierunekPol.Gora:
            pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), self.MALE_POLE_WYMIARY)
            pole_surface = pygame.transform.rotate(pole_surface, 180)
        elif self.kierunek_sciany == KierunekPol.Prawo:
            pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), self.MALE_POLE_WYMIARY)
            pole_surface = pygame.transform.rotate(pole_surface, 90)

        screen.blit(pole_surface, (self.pozycja.x, self.pozycja.y))
        
        pygame.draw.rect(screen, Pole.KOLOR_TLA, pygame.Rect(self.pozycja.x, self.pozycja.y, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek), width=1)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Posiadlosc.py
from src.Pole import Pole
from src.Gracz import Gracz

KOSZT_SPRZEDAZY = 0.8


class Posiadlosc(Pole):

    def __init__(self, numer, nazwa, kolor, cena, czynsz, zastaw, cena_domu=0):
        super().__init__(numer, "Posiadlosc")
        self.nazwa = nazwa
        self.kolor = kolor
        self.cena = cena
        self.czynsz = czynsz
        self.zastaw_kwota = zastaw
        self.cena_domu = cena_domu
        self.wlasciciel = None
        self.czy_zastawiona = False
        self.liczba_domow = 0
        self.liczba_hoteli = 0

    def zwroc_info(self):
        if self.liczba_domow:
            return f"Nazwa: {self.nazwa} \nCena: {self.cena}   Czynsz: {self.czynsz}  Zastaw: {self.zastaw_kwota} \nCena-dom: {self.cena_domu}  Liczba domkow: {self.liczba_domow}"
        return f"Nazwa: {self.nazwa} \nCena: {self.cena}   Czynsz: {self.czynsz}  Zastaw: {self.zastaw_kwota} \nCena-dom: {self.cena_domu}"

    def pobierz_id_wlasciciela(self):
        return self.IDwlasciciela

    def wyswietl_info(self, gra):
        czynsz = self.czynsz
        if self.wlasciciel:
            czynsz = self.oblicz_czynsz(gra)

        if self.kolor != "pozaWmii" and self.kolor != "kolo":
            gra._kontroler_wiadomosci.dodaj_wiadomosc(f"Nazwa: {self.nazwa}")
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena-dom: {self.cena_domu}  Liczba domkow: {self.liczba_domow}"
            )
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(f"Nazwa: {self.nazwa}")
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )

    def oblicz_czynsz(self, gra):
        liczba_w_kolorze = self.wlasciciel.ile_w_kolorze(self.kolor)
        if self.kolor == "pozaWmii":
            if liczba_w_kolorze == 2:
                return gra._suma_oczek * 10 * 10
            else:
                return gra._suma_oczek * 4 * 10
        elif self.kolor == "kolo":
            if liczba_w_kolorze == 1:
                return 250
            elif liczba_w_kolorze == 2:
                return 500
            elif liczba_w_kolorze == 3:
                return 1000
            else:
                return 2000
        else:
            if liczba_w_kolorze < 3:
                return self.czynsz
            if liczba_w_kolorze == 3 and self.liczba_domow == 0:
                return 2 * self.czynsz

            cena = 0
            if self.liczba_domow == 1:
                cena = 5 * self.czynsz
            elif self.liczba_domow == 2:
                cena = 15 * self.czynsz
            elif self.liczba_domow == 3:
                cena = 45 * self.czynsz
            elif self.liczba_domow == 4:
                cena = 80 * self.czynsz

            cena += self.czynsz * 125 * self.liczba_hoteli
            return cena

    def kup_posiadlosc(self, gra, gracz):
        x = gracz.wykonaj_oplate(gra, self.cena)
        if x == 1:
            gracz.lista_posiadlosci.append(self)
            self.wlasciciel = gracz
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gratulacje, dokonałeś zakupu {self.nazwa}!"
            )
            gracz.statystyka.dodaj_posiadlosc()
            gra.akcja_pola_okno.czy_akcja_pola = False
        elif not gra.akcja_zastaw_okno.czy_zastaw:
            gra._kontroler_wiadomosci.dodaj_wiadomosc("Wycofałeś się z zakupu")
            gra.akcja_pola_okno.czy_akcja_pola = False
        return

    def kup_dom(self, gra, gracz, ile_domow):
        if gracz.wykonaj_oplate(gra, self.cena_domu * ile_domow):
            self.liczba_domow += ile_domow
            gracz.statystyka.dodaj_dom(ile_domow)
            while self.liczba_domow >= 5:
                self.liczba_domow -= 5
                gracz.statystyka.odejmij_dom(5)
                self.liczba_hoteli += 1
                gracz.statystyka.dodaj_hotel(1)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Zakup domu się udał posiadasz {self.liczba_domow} domów i {self.liczba_hoteli} hoteli"
            )
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc("Wycofałeś się z zakupu")

    def sprzedaj_dom(self, gra, gracz):
        if self.liczba_domow > 0:
            gracz.kwota = gracz.kwota + self.cena_domu * KOSZT_SPRZEDAZY
            self.liczba_domow -= 1
            gracz.statystyka.odejmij_dom(1)

    def sprzedaj_hotel(self, gra, gracz):
        if self.liczba_hoteli > 0:
            gracz.kwota = (
                gracz.kwota
                + (self.liczba_hoteli * 5 * self.cena_domu) * KOSZT_SPRZEDAZY
            )
            self.liczba_hoteli -= 1
            gracz.statystyka.odejmij_hotel(1)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Przycisk.py
import pygame
from src.Wizualizator import Wizualizator


class Przycisk:
    def __init__(self, x, y, width, height, color, hover_color, text, text_color):
        self.rect = pygame.Rect(x, y, width, height)
        self.color: pygame.Color = color
        self.hover_color: pygame.Color = hover_color
        self.text = text
        self.text_color = text_color
        self.wizualizator = Wizualizator()
        self.font = pygame.font.Font(self.wizualizator.czcionka_przycisku, 36)

    def pobierz_wymiary(self) -> pygame.Rect:
        return self.rect

    def draw(self, screen):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(screen, color, self.rect)

        if self.text:
            text_surf = self.font.render(self.text, True, self.text_color)
            text_rect = text_surf.get_rect(center = self.rect.center)
            screen.blit(text_surf, text_rect)

    def is_clicked(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == pygame.BUTTON_LEFT and self.rect.collidepoint(event.pos):
                return True
        return False

    def updateSize(self, x, y, width, height):
        if width <= 0 or height <= 0:
            return

        self.rect = pygame.Rect(x, y, width, height)

    def czy_najechano(self):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        return is_hover

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\PrzyciskiMenu.py
from src.Przycisk import Przycisk
from src.Wizualizator import Wizualizator


class PrzyciskiMenu:

    def __init__(self, H, W, wizualizator):

        self.wizualizator = wizualizator

        self.nowa_gra = Przycisk(
            W * 0.35,
            H * 0.4,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Nowa gra",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.wczytaj_gre = Przycisk(
            W * 0.35,
            H * 0.52,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Wczytaj zapis",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.wyjscie = Przycisk(
            W * 0.35,
            H * 0.64,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Wyjscie",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.two = Przycisk(
            W * 0.3,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "2",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.three = Przycisk(
            W * 0.4,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "3",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.four = Przycisk(
            W * 0.5,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "4",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.five = Przycisk(
            W * 0.6,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "5",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

    def aktualizuj_rozmiar(self, W, H):
        # skalowanie do jakiejsc czesci, testowo
        MIN_W = 500
        MIN_H = 400
        W = max(W, MIN_W)
        H = max(H, MIN_H)

        self.nowa_gra.updateSize(W * 0.35,
            H * 0.4,
            W * 0.3,
            H * 0.1)
        self.wyjscie.updateSize(W * 0.35,
            H * 0.64,
            W * 0.3,
            H * 0.1)
        self.wczytaj_gre.updateSize(W * 0.35,
            H * 0.52,
            W * 0.3,
            H * 0.1)
        self.two.updateSize(W * 0.3,
            H * 0.5,
            H * 0.1,
            H * 0.1)
        self.three.updateSize(W * 0.4,
            H * 0.5,
            H * 0.1,
            H * 0.1)
        self.four.updateSize(W * 0.5,
            H * 0.5,
            H * 0.1,
            H * 0.1)
        self.five.updateSize(W * 0.6,
            H * 0.5,
            H * 0.1,
            H * 0.1)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Statystyka.py
class Statystyka:

    def __init__(self, kwota_startowa, nazwa_gracza):
        self.nazwa_gracza = nazwa_gracza
        self.pieniadze = kwota_startowa
        self.ilosc_posiadlosci = 0
        self.ilosc_domkow = 0
        self.ilosc_hoteli = 0

    def aktualizuj_stan_pieniedzy(self, pieniadze):
        self.pieniadze = pieniadze

    def dodaj_posiadlosc(self):
        self.ilosc_posiadlosci += 1

    def dodaj_hotel(self, ile):
        self.ilosc_hoteli += ile

    def dodaj_domek(self, ile):
        self.ilosc_domkow += ile

    def odejmij_domek(self, ile):
        self.ilosc_domkow -= ile

    

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\UJpoly.py
class Gra:
    def __init__(self):
        self.gracze = []
        
class Plansza:
    def __init__(self):
        self.Pola = []
        
class Gracz:
    def __init__(self, Id: int, pionek: Pionek, kartaSzansy: KartaSzansy, liczbaPostojow: int, uwiezienie: bool):
        self.Id = Id
        self.pionek = pionek
        self.kartaSzansy = kartaSzansy
        self.liczbaPostojow = liczbaPostojow
        self.uwiezienie = uwiezienie
        
class Posiadlosc(Pole):
    def __init__(self, cena: int, czynsz: int, cenaDomu: int, cenaHotelu: int, wlasciciel: Gracz):
        self.cena = cena
        self.czynsz = czynsz
        self.cenaDomu = cenaDomu
        self.cenaHotelu = cenaHotelu
        self.wlasciciel = wlasciciel        

class Pole:
    def __init__(self, numer: int, grafika: Graphic):
        self.numer = numer
        self.grafika = grafika

class PoleWykonywalne(Pole):
    def __init__(self):

class PoleSpecjalne(Pole):
    def __init__(self):
        
class KartaSzansy:
    def __init__(self, trescKarty: str):
        self.trescKarty = trescKarty
        
class Pionek:
    def __init__(self, numerPola: int, color: Color, grafika: Graphic):
        self.numerPola = numerPola
        self.color = color
        self.grafika = grafika

    def zmienGrafike(self) -> bool:

    def zmienPozycje(self, nowaPozycja: int) -> bool:

class Statystyki:
    def __init__(self):
        self.statystyki = []

    def zaktualizujStatystykiGracza(self, gracz: Gracz): 
        
class Statystyka:
    def __init__(self, IDgracza: int, majatek: int, iloscPosiadlosci: int, iloscDomow: int, iloscHoteli: int):
        self.IDgracza = IDgracza
        self.majatek = majatek
        self.iloscPosiadlosci = iloscPosiadlosci
        self.iloscDomow = iloscDomow
        self.iloscHoteli = iloscHoteli

    def zmienWartosc(self):       
        
class Tutorial:
    def __init__(self, ukonczony: bool):
        self.ukonczony = ukonczony

    def rozpocznij(self):        


class Czas:
    def __init__(self, czasGry: float, czasTury: float):
        self.czasGry = czasGry
        self.czasTury = czasTury


class Zagadki:
    def __init__(self, trescZagadki: str, poprawnaOdpowiedz: int):
        self.trescZagadki = trescZagadki
        self.poprawnaOdpowiedz = poprawnaOdpowiedz

    def sprawdzOdpowiedz(self) -> bool:


















C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Wizualizator.py
class Wizualizator:

    def __init__(self):

        # przycisk
        self.kolor_przycisku = (70, 70, 70)
        self.kolor_gdy_kursor = (150, 150, 150)
        self.kolor_czcionki_na_przycisku = (200, 200, 200)

        # inne kolory
        self.kolor_akceptacji_nazwy_gracza = (96, 247, 134)
        self.kolor_tla = (77, 77, 115)
        self.kolor_czcionki = (255, 255, 255)
        self.kolor_czcionki_tyl_karty = (255, 255, 255)
        self.kolor_nakladki = (77, 77, 115)
        self.przezroczystosc_nakladki = 100

        #kolory wypisywania komunikatow
        self.kolor_wiadomosci = (255, 255, 255)
        self.kolor_ostatniej_wiadomosci = (255, 255, 255)

        #czcionka
        #self.czcionka = "fonts/Lato-Black.ttf"
        self.czcionka = None
        self.czcionka_przycisku = "fonts/Gameplay.ttf"


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\interface\IGra.py
import pygame
from abc import abstractmethod


class IGra:
    @abstractmethod
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        pass

    @abstractmethod
    def aktualizacja(self):
        pass

    @abstractmethod
    def wyswietl(self):
        pass

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaKartOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaKartOkno(Okno):

    def __init__(self, gra):
        self.H = 800
        self.W = 1200
        self.gra = gra
        self.szansa_png = pygame.transform.scale(
            pygame.image.load("graphics/karta_szansy.png"), (0.6 * self.W, 0.5 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.42,
            self.H * 0.7,
            self.W * 0.2,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.czy_szansa = False

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.wyjscie.is_clicked(event):
            self.czy_szansa = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):

        self.wyjscie.updateSize(
                self.W * 0.42,
                self.H * 0.7,
                self.W * 0.2,
                self.H * 0.1
            )

        if self.czy_szansa:

            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.szansa_png = pygame.transform.scale(
                self.szansa_png, (0.64 * self.W, 0.5 * self.H)
            )
            screen.blit(self.szansa_png, (self.W * 0.2, self.H * 0.15))
            self.wyjscie.updateSize(
                self.W * 0.42, self.H * 0.7, self.W * 0.2, self.H * 0.1
            )
            self.wyjscie.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaNieruchomosciOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaNieruchomosciOkno(Okno):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.nieruchomosc = "brak"

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_hotel = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup hotel",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_domek = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup domek",
            self.gra.kolor_tekstu,
        )

        self.przycisk = self.wyjscie
        self.ktore_kupno = 0
        self.czy_kupno = False

    def ustaw_poprawny_przycisk_domek_hotel(self):

        if self.nieruchomosc == "domek":
            self.przycisk = self.przycisk_kup_domek
        elif self.nieruchomosc == "hotel":
            self.przycisk = self.przycisk_kup_hotel
        else:
            self.przycisk = self.wyjscie

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.przycisk.is_clicked(event) and self.nieruchomosc == "domek":
            self.kup_domek()
            self.czy_kupno = False
            self.zamknij()
        elif self.przycisk.is_clicked(event) and self.nieruchomosc == "hotel":
            self.kup_hotel()
            self.czy_kupno = False
            self.zamknij()
        elif self.wyjscie.is_clicked(event):
            self.czy_kupno = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):

        if self.czy_kupno:
            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.pole_png = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(self.pole_png, (self.W * 0.2, self.H * 0.15))
            self.przycisk.updateSize(
                self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
            )
            self.wyjscie.updateSize(
                self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
            )
            self.przycisk.draw(screen)
            self.wyjscie.draw(screen)

    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_gracza = posiadlosc
        self.gracz = gracz
        self.ustaw_poprawny_przycisk_domek_hotel()
        self.pole_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
            (0.28 * self.W, 0.64 * self.H),
        )

    def kup_domek(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 1)

    def kup_hotel(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 5)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaPolaOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame
from enum import Enum


class AkcjaPolaOkno(Okno):
    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zakup = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kupuję",
            self.gra.kolor_tekstu,
        )
        self.licytacja = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "licytacja",
            self.gra.kolor_tekstu,
        )
        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.6,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )
        self.karta = Przycisk(
            self.W * 0.6,
            self.H * 0.6,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "",
            self.gra.kolor_tekstu,
        )

        self.pole_png= None
        self.najechano_na_pole = False

        self.czy_akcja_pola = False
        self.gracz_majacy_mozliwosc_zakupu = None
        self.posiadlosc_do_zakupu = None

        self.skalar_czcionki = 60  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.zakup.is_clicked(event):
            self.kup_pole()
            self.czy_akcja_pola = False
            self.zamknij()
        elif self.licytacja.is_clicked(event):
            self.czy_akcja_pola = False
            self.zamknij()
            pass
        elif self.wyjscie.is_clicked(event):
            self.czy_akcja_pola = False
            self.zamknij()

        if self.czy_akcja_pola:
            if self.karta.czy_najechano():
                self.pole_png = pygame.transform.scale(
                pygame.image.load("graphics/pola/pole_tyl_karty.png"),
                (0.24 * self.W, 0.64 * self.H),
                )
                self.najechano_na_pole = True
            else:
                self.pole_png = pygame.transform.scale(
                pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
                (0.24 * self.W, 0.64 * self.H),
                )
                self.najechano_na_pole = False



    def wyswietl(self, screen: pygame.Surface):

        self.zaktualizuj_tekst_i_rozmiar()

        if self.czy_akcja_pola:
            self.zakup.updateSize(
                self.W * 0.6,
                self.H * 0.2,
                self.W * 0.2,
                self.H * 0.15
            )
            self.licytacja.updateSize(
                self.W * 0.6,
                self.H * 0.4,
                self.W * 0.2,
                self.H * 0.15,
            )
            self.wyjscie.updateSize(
                self.W * 0.6,
                self.H * 0.6,
                self.W * 0.2,
                self.H * 0.15,
            )

            self.karta.updateSize(
                self.W * 0.2,
                self.H * 0.15,
                0.24 * self.W, 
                0.64 * self.H
            )

            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))


            self.zakup.draw(screen)
            self.licytacja.draw(screen)
            self.wyjscie.draw(screen)

            pole_png_wyswietlane = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(pole_png_wyswietlane, (self.W * 0.2, self.H * 0.15))

            self.odleglosc_pionowa = 0.03
            self.wysokosc_napisow = 0.42
            if self.najechano_na_pole:
                screen.blit(self.czynsz_bez_nieruchomosci, (self.W * 0.23, self.H * (self.wysokosc_napisow + (0 * self.odleglosc_pionowa))))
                screen.blit(self.wzrost_czynszu_dom, (self.W * 0.23, self.H * (self.wysokosc_napisow + (1 * self.odleglosc_pionowa))))
                screen.blit(self.wzrost_czynszu_hotel, (self.W * 0.23, self.H * (self.wysokosc_napisow + (2 * self.odleglosc_pionowa))))


    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_do_zakupu = posiadlosc
        self.gracz_majacy_mozliwosc_zakupu = gracz
        self.pole_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
            (0.24 * self.W, 0.64 * self.H),
        )

    def kup_pole(self):
        self.posiadlosc_do_zakupu.kup_posiadlosc(
            self.gra, self.gracz_majacy_mozliwosc_zakupu
        )

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True

    def zaktualizuj_tekst_i_rozmiar(self):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

        self.czynsz_bez_nieruchomosci = self.font.render(
            "Czynsz bez nieruchomości: " + str(100), True, self.gra.kolor_czcionki_tyl_karty
        )
        self.wzrost_czynszu_dom = self.font.render(
            "Wzrost czynszu (domek +): " + str(70), True, self.gra.kolor_czcionki_tyl_karty
        )
        self.wzrost_czynszu_hotel = self.font.render(
            "Wzrost czynszu (hotel +): " + str(100), True, self.gra.kolor_czcionki_tyl_karty
        )

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaStatystykOkno.py
from src.okno.Okno import Okno
from src.Statystyka import Statystyka
import pygame


MAKSYMALNA_DLUGOSC_NAZWY_GRACZA = 12

class AkcjaStatystykOkno(Okno):
    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra
        self.czy_akcja_statystyk = True

        self.skalar_czcionki = 40 # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

        self.odleglosc_pionowa = 0.06
        self.mnoznik_wysokosci = 0.1
        self.mnoznik_szerokosci = 0.62

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        pass

    def wyswietl(self, screen: pygame.Surface):

        if self.czy_akcja_statystyk:
            
            i = 0
            self.ramka = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_statystyk.png"),
                (self.W * 0.45, self.H * 0.36)
            )
            screen.blit(self.ramka, (self.W * (self.mnoznik_szerokosci - 0.08), self.H * (self.mnoznik_wysokosci - 0.08)))

            self.tlo_wiad = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_wiadomosci.png"),
                (self.W * 0.45, self.H * 0.56)
            )
            screen.blit(self.tlo_wiad, (self.W * (self.mnoznik_szerokosci - 0.08), self.H * (self.mnoznik_wysokosci + 0.28)))

            self.tlo_glowna = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_glownej_wiadomosci.png"),
                (self.W * 0.45, self.H * 0.05)
            )
            screen.blit(self.tlo_glowna, (self.W * (self.mnoznik_szerokosci - 0.08), self.H * (self.mnoznik_wysokosci + 0.755)))
            for gracz in self.gra._gracze:

                nazwa_gracza = self.sprawdz_czy_nazwa_gracza_nie_za_dluga(gracz.id)
                self.zaktualizuj_tekst_i_rozmiar(gracz, nazwa_gracza)

                self.zdjecie_pionek = pygame.transform.scale(
                    pygame.image.load(gracz.pionek.sciezka_do_grafiki), (0.02 * self.W, 0.02 * self.W)
                )

                screen.blit(self.zdjecie_pionek, (self.W * (self.mnoznik_szerokosci - 0.03), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa - 0.005))))

                screen.blit(self.nazwa, (self.W * (self.mnoznik_szerokosci), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                screen.blit(self.pieniadze, (self.W * (self.mnoznik_szerokosci + 0.12), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                screen.blit(self.posiadlosci, (self.W * (self.mnoznik_szerokosci + 0.22), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                screen.blit(self.domki, (self.W * (self.mnoznik_szerokosci + 0.26), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                screen.blit(self.hotele, (self.W * (self.mnoznik_szerokosci + 0.3), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                i += 1


    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


    def sprawdz_czy_nazwa_gracza_nie_za_dluga(self, nazwa):
        if len(nazwa) > MAKSYMALNA_DLUGOSC_NAZWY_GRACZA:
            return (nazwa[:MAKSYMALNA_DLUGOSC_NAZWY_GRACZA - 3] + "...")
        else:
            return nazwa
        
    def zaktualizuj_tekst_i_rozmiar(self, gracz, nazwa_gracza):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

        self.nazwa = self.font.render(
            str(nazwa_gracza), True, self.gra.kolor_czcionki
        )
        self.pieniadze = self.font.render(
            str(gracz.statystyka.pieniadze), True, self.gra.kolor_czcionki
        )
        self.posiadlosci = self.font.render(
            str(gracz.statystyka.ilosc_posiadlosci), True, self.gra.kolor_czcionki
        )
        self.domki = self.font.render(
            str(gracz.statystyka.ilosc_domkow), True, self.gra.kolor_czcionki
        )
        self.hotele = self.font.render(
            str(gracz.statystyka.ilosc_hoteli), True, self.gra.kolor_czcionki
        )
        

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaWiezieniaOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaWiezieniaOkno(Okno):

    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zdjecie = pygame.transform.scale(
            pygame.image.load("graphics/wiezienie.png"), (0.45 * self.H, 0.45 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.3,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjście",
            self.gra.kolor_tekstu,
        )
        self.czy_wiezienie = False

        self.skalar_czcionki = 24  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.informacja_o_wiezeniu = "idziesz do więzienia, stoisz 2 tury"

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.wyjscie.is_clicked(event):
            self.czy_wiezienie = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        H = self.H
        W = self.W

        if self.czy_wiezienie:
            
            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.zaktualizuj_rozmiar_czcionki()
            self.wyswietl_teksty(screen)

            self.zdjecie = pygame.transform.scale(
                self.zdjecie, (0.45 * self.H, 0.45 * self.H)
            )
            screen.blit(self.zdjecie, (W * 0.2, H * 0.15))
            self.wyjscie.updateSize(W * 0.6, H * 0.3, W * 0.2, H * 0.15)
            self.wyjscie.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.tekst = self.font.render(self.informacja_o_wiezeniu, True, (0, 0, 0))

    def wyswietl_teksty(self, screen):
        screen.blit(self.tekst, (self.W * 0.18, self.H * 0.7))

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaZagadekOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
from src.Odpowiedz import Odpowiedz
import pygame


class AkcjaZagadekOkno(Okno):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.czy_zagadka = False

        self.A = Przycisk(
            self.W * 0.2,
            self.H * 0.5,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "A",
            self.gra.kolor_tekstu,
        )
        self.B = Przycisk(
            self.W * 0.2,
            self.H * 0.6,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "B",
            self.gra.kolor_tekstu,
        )
        self.C = Przycisk(
            self.W * 0.2,
            self.H * 0.7,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "C",
            self.gra.kolor_tekstu,
        )

        self.odpowiedz_A = "empty"
        self.odpowiedz_B = "empty"
        self.odpowiedz_C = "empty"

        self.skalar_czcionki = 28  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.informacja_o_podatku = "Zapłać podatek dochodowy o wartości "
        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + "x"
        self.informacja_o_zagadce = (
            "odpowiedz poprawnie na pytanie aby zmniejszyć opłatę"
        )
        self.tekst_zagadki = "empty"

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.A.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_A)
            )
            self.czy_zagadka = False
            self.zamknij()
        elif self.B.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_B)
            )
            self.czy_zagadka = False
            self.zamknij()
        elif self.C.is_clicked(event):
            self.pole.zaplac_podatek(
                self.gra, self.gracz, (self.poprawna_odpowiedz == Odpowiedz.Odpowiedz_C)
            )
            self.czy_zagadka = False
            self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        self.zaktualizuj_rozmiar_czcionki()

        if self.czy_zagadka:
            screen.fill(self.gra.kolor_tla)
            screen.blit(self.podatek, (self.W * 0.18, self.H * 0.2))
            screen.blit(self.info, (self.W * 0.19, self.H * 0.27))
            offset_height_percent = self.wyswietl_lamana_tresc_zagadki(screen, self.tekst_zagadki, self.W * 0.2, self.H * 0.4)

            # odpowiedzi
            offset_height_percent -= 0.05
            screen.blit(self.oA, (self.W * 0.3, self.H * (0.54 + offset_height_percent)))
            screen.blit(self.oB, (self.W * 0.3, self.H * (0.66 + offset_height_percent)))
            screen.blit(self.oC, (self.W * 0.3, self.H * (0.78 + offset_height_percent)))

            self.wyswietl_przyciski(screen, offset_height_percent)

    def przygotuj_zagadke(self):
        zagadka = self.gra._plansza.zagadki.nastepna_zagadka()
        self.tekst_zagadki = zagadka.tresc_zagadki

        self.odpowiedz_A = zagadka.odpowiedz_a
        self.odpowiedz_B = zagadka.odpowiedz_b
        self.odpowiedz_C = zagadka.odpowiedz_c
        self.poprawna_odpowiedz = zagadka.poprawna

        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + str(
            self.pole.podatek
        )

    def akcja_podatkowa(self, gracz, pole):
        self.gracz = gracz
        self.pole = pole

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.podatek = self.font.render(
            self.informacja_o_podatku_z_cena, True, self.gra.kolor_czcionki
        )
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki) - 15)
        self.info = self.font.render(self.informacja_o_zagadce, True, self.gra.kolor_czcionki)
        self.zagadka = self.font.render(self.tekst_zagadki, True, self.gra.kolor_czcionki)

        # odpowiedzi
        self.oA = self.font.render(self.odpowiedz_A, True, self.gra.kolor_czcionki)
        self.oB = self.font.render(self.odpowiedz_B, True, self.gra.kolor_czcionki)
        self.oC = self.font.render(self.odpowiedz_C, True, self.gra.kolor_czcionki)

    def wyswietl_lamana_tresc_zagadki(self, screen, tekst: str, start_x, start_y) -> float:
        """
            :param screen: ekran na ktory jest rysowany tekst
            :param tekst: tekst poddany lamaniu i wyswietleniu juz polamanym
            :param start_x: offset x do wyswietlania tekstu
            :param start_y: offset y do wyswietlania tekstu
            :return: procentowa ilosc zajetego ekranu przez linijki tekstu w porownaniu do calego ekranu
        """
        wyrazy = [wyraz.split(' ') for wyraz in tekst.splitlines()]
        szerokosc_spacji = self.font.size(' ')[0]

        maksymalna_szerokosc = self.gra.aktualna_szerokosc_ekranu
        x, y = start_x, start_y
        # ze stacka xD
        for line in wyrazy:
            for word in line:
                word_surface = self.font.render(word, 0, self.gra.kolor_czcionki)
                word_width, word_height = word_surface.get_size()
                if x + word_width >= maksymalna_szerokosc:
                    x = start_x         # Reset the x.
                    y += word_height    # Start on new row.
                screen.blit(word_surface, (x, y))
                x += word_width + szerokosc_spacji
            x = start_x         # Reset the x.
            y += word_height    # Start on new row.

        return (y - start_y) / self.gra.aktualna_wysokosc_ekranu

    def wyswietl_przyciski(self, screen, offset_height_percent):
        self.A.updateSize(self.W * 0.2, self.H * (0.5 + offset_height_percent), self.H * 0.1, self.H * 0.1)
        self.A.draw(screen)
        self.B.updateSize(self.W * 0.2, self.H * (0.62 + offset_height_percent), self.H * 0.1, self.H * 0.1)
        self.B.draw(screen)
        self.C.updateSize(self.W * 0.2, self.H * (0.74 + offset_height_percent), self.H * 0.1, self.H * 0.1)
        self.C.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaZastawOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaZastawOkno(Okno):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.pole_png = pygame.transform.scale(
            pygame.image.load("graphics/zastaw.jpg"), (0.28 * self.W, 0.64 * self.H)
        )

        self.kolor_przycisku = self.gra.kolor_przycisku
        self.kolor_hovera = self.gra.kolor_gdy_kursor

        self.przycisk_zastaw = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.kolor_przycisku,
            self.kolor_hovera,
            "zastaw",
            self.gra.kolor_tla,
        )
        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.kolor_przycisku,
            self.kolor_hovera,
            "wyjscie",
            self.gra.kolor_tla,
        )
        self.czy_zastaw = False

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.czy_zastaw:
            if self.przycisk_zastaw.is_clicked(event):
                self.zastaw()
                # self.czy_zastaw = False
            elif self.wyjscie.is_clicked(event):
                self.czy_zastaw = False

    def wyswietl(self, screen: pygame.Surface):

        if self.czy_zastaw:

            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))
            
            self.pole_png = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(self.pole_png, (self.W * 0.2, self.H * 0.15))
            self.przycisk_zastaw.updateSize(
                self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
            )
            self.wyjscie.updateSize(
                self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
            )
            self.przycisk_zastaw.draw(screen)
            self.wyjscie.draw(screen)

    def akcja_zastawiania(self, gracz):
        self.gracz = gracz

    def zastaw(self):
        self.gracz.zastaw_posiadlosci(self.gra)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\Okno.py
import pygame
from abc import abstractmethod


class Okno:
    @staticmethod
    def wysrodkuj_obraz(okno: pygame.Vector2, obraz: pygame.Vector2) -> pygame.Vector2:
        left = (okno.x // 2) - (obraz.x // 2)
        top = (okno.y // 2) - (obraz.y // 2)

        return pygame.Vector2(left, top)

    @abstractmethod
    def aktualizacja(self):
        pass

    @abstractmethod
    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        pass

    @abstractmethod
    def wyswietl(self, screen: pygame.Surface):
        pass

    @abstractmethod
    def aktualizuj_rozmiar_okna(self, width, height):
        pass

    @abstractmethod
    def zamknij(self):
        pass


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\proxy\GraProxy.py
import pygame
from src.interface.IGra import IGra
from src.Gra import Gra


class Kolejka:
    def __init__(self):
        self._kolejka: list[pygame.event.Event] = list()

    def rozmiar(self):
        return len(self._kolejka)

    def czy_pusta(self):
        return len(self._kolejka) == 0

    def dodaj(self, element: pygame.event.Event):
        self._kolejka.append(element)

    def pobierz(self) -> pygame.event.Event | None:
        if not self.czy_pusta():
            return self._kolejka.pop(0)

        return None


class GraProxy(IGra):
    def __init__(self, gra: Gra):
        self._kolejka_test_zdarzen: Kolejka = Kolejka()
        self._instancja_gra: Gra = gra
        self._czy_moze_wykonac_nastepne_zdarzenie = False
        print("HELLO from GraProxy")

    def _zablokuj_wykonywanie_zdarzen(self):
        self._czy_moze_wykonac_nastepne_zdarzenie = False

    # override
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        if self._czy_moze_wykonac_nastepne_zdarzenie is True:
            nastepne_zdarzenie = self._kolejka_test_zdarzen.pobierz()

            if nastepne_zdarzenie is not None:
                self._instancja_gra.wykonaj_zdarzenie(nastepne_zdarzenie)

            self._zablokuj_wykonywanie_zdarzen()

    # override
    def aktualizacja(self):
        pass

    # override
    def wyswietl(self):
        pass

    def wykonaj_wszystkie_zakolejkowane_wydarzenia(self):
        while not self._kolejka_test_zdarzen.czy_pusta():
            nastepne_zdarzenie = self._kolejka_test_zdarzen.pobierz()

            if nastepne_zdarzenie is not None:
                self._instancja_gra.wykonaj_zdarzenie(nastepne_zdarzenie)

    def pozwol_wykonac_zdarzenie_z_kolejki(self):
        self._czy_moze_wykonac_nastepne_zdarzenie = True

    def dodaj_zdarzenie_do_kolejki(self, event: pygame.event.Event):
        self._kolejka_test_zdarzen.dodaj(event)

    def pobierz_instancje_gry(self) -> Gra:
        return self._instancja_gra



C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_Gra.py
import os
import pytest
import pygame
from src.proxy.GraProxy import GraProxy
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci


# Komenda aby uruchomic testy: python -m pytest ./tests
class TestGra:
    def setup_method(self):
        pygame.init()
        pygame.font.init()
        os.environ["SDL_VIDEO_CENTERED"] = "1"
        self.font = pygame.font.Font(None, 20)
        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font)
        self._screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)
        self.gra = GraProxy(Gra(self._screen, self._kontroler_wiadomosci))

    # ten test powinien wyrzucić wyjątek, "out of index"
    # Podawany event w metodzie gra.aktualizacja_zdarzen(event), event= jest rowny None, poniewaz korzystamy z wewnetrznie zorganizowanej kolejki eventow
    # python -m pytest ./tests -k "test_no_players_quantity_given"
    def test_no_players_quantity_given(self):
        with pytest.raises(Exception):
            self.gra.dodaj_zdarzenie_do_kolejki(event=pygame.event.Event(pygame.KEYDOWN, {"unicode": 32, "key": pygame.K_SPACE}))
            self.gra.pozwol_wykonac_zdarzenie_z_kolejki()
            self.gra.aktualizacja_zdarzenia(event=None)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_pionek.py
import pytest
import pygame
from src.Pionek import Pionek


# Komenda aby uruchomic testy: python -m pytest ./tests
class TestPionek:
    def setup_method(self):
        self.pionek = Pionek(0, pygame.color.THECOLORS["black"], "graphics")
        # Pozniej dodaj "mock object"

    @pytest.mark.parametrize("liczba_pol", list(range(Pionek.MIN_LICZBA_OCZEK, Pionek.MAX_LICZBA_OCZEK)))
    def test_ruch_prawidlowa_ilosc_oczek(self, liczba_pol):
        assert self.pionek.przesun(liczba_pol) is True

    @pytest.mark.parametrize("liczba_pol", [-1, 0, 1, 13, 14])
    def test_ruch_nieprawidlowa_ilosc_oczek(self, liczba_pol):
        assert self.pionek.przesun(liczba_pol) is False


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_Pole.py
import pygame
import pytest

from src.Pole import Pole, Vector2, KierunekPol


class TestPole:
    DOMYSLNY_NUMER_POLA = 10

    def setup_method(self):
        self.typ_pole = "test_typ"
        self.pole = Pole(TestPole.DOMYSLNY_NUMER_POLA, self.typ_pole)

    @pytest.mark.parametrize("maksymalna_liczba_pol", list(range(0, len(KierunekPol) * Pole.DLUGOSC_SCIANY_W_POLACH)))
    def test_oblicz_zwrot_naglowka_pola_rzuca_wyjatek_niepoprawna_maksymalna_liczba_pol_za_mala(self, maksymalna_liczba_pol):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(TestPole.DOMYSLNY_NUMER_POLA, Pole.DLUGOSC_SCIANY_W_POLACH, maksymalna_liczba_pol)


    dodatkowa_sztuczna_ilosc_pol = 10

    @pytest.mark.parametrize("maksymalna_liczba_pol", list(range(len(KierunekPol) * Pole.DLUGOSC_SCIANY_W_POLACH + 1, (len(KierunekPol) + dodatkowa_sztuczna_ilosc_pol) * Pole.DLUGOSC_SCIANY_W_POLACH)))
    def test_oblicz_zwrot_naglowka_pola_rzuca_wyjatek_niepoprawna_maksymalna_liczba_pol_za_duza(self, maksymalna_liczba_pol):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(TestPole.DOMYSLNY_NUMER_POLA, Pole.DLUGOSC_SCIANY_W_POLACH, maksymalna_liczba_pol)

    def test_oblicz_zwrot_naglowka_pola_niepoprawna_maksymalna_liczba_pol_dzielnie_zero(self):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(10, dlugosc_sciany_w_polach=0, maksymalna_liczba_pol=Pole.MAKSYMALNA_LICZBA_POL)

    def test_oblicz_zwrot_naglowka_pola_poprawna_maksymalna_liczba_pol_duze_wymiary(self):
        pass

    def test_oblicz_zwrot_naglowka_pola_poprawna_maksymalna_liczba_pol_male_wymiary(self):
        # Aby zwrocilo duze wymiary pola, numer pola musi byc wielokrotnoscia dlugosc_sciany_w_polach
        wynikowe_wymiary = Pole.oblicz_zwrot_naglowka_pola(len(KierunekPol) * Pole.DLUGOSC_SCIANY_W_POLACH, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        pass

    def test_oblicz_rozmiar_pola(self):
        pass

    def test_inicjalizacja_pozycji(self):
        pass

    def test_typ_zmiennych_konstruktora(self):
        assert isinstance(self.pole.numer, int)
        assert isinstance(self.pole.typ, str)
        assert isinstance(self.pole.wymiary, Vector2)
        assert isinstance(self.pole.kierunek_sciany, KierunekPol)
        assert isinstance(self.pole.pozycja, Vector2)
        assert isinstance(self.pole.sciezka_do_grafiki, str)

    @pytest.mark.skip(reason="Not yet implemented path checking")
    def test_sciezka_do_grafiki(self):
        pass

    def test_zwroc_info(self):
        przewidywany_tekst = f"Nazwa: {self.typ_pole}"
        zwrocony_tekst = self.pole.zwroc_info()

        assert przewidywany_tekst == zwrocony_tekst



C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_Posiadlosc.py
import pygame
import pytest

from src.Posiadlosc import Posiadlosc
from src.Gracz import Gracz
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci


#TODO: Zmiana typu z kolor: str na pygame.Color

class TestPosiadlosc:
    NUMER = 0
    NAZWA = "test"
    KOLOR = "czarny"
    CENA = 500
    CZYNSZ = 500
    ZASTAW = 500
    CENA_DOMU = 0

    def setup_method(self):
        pygame.init()

            # przepisz na mocki
        self.font = pygame.font.Font(None, 20)
        self.screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)
        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font)
        self._gra = Gra(self.screen, self._kontroler_wiadomosci)

        self.posiadlosc = Posiadlosc(TestPosiadlosc.NUMER, TestPosiadlosc.NAZWA, TestPosiadlosc.KOLOR,
                                     TestPosiadlosc.CENA, TestPosiadlosc.CZYNSZ, TestPosiadlosc.ZASTAW,
                                     TestPosiadlosc.CENA_DOMU)


    def test_inicjalizacja_typow(self):
        assert isinstance(self.posiadlosc.nazwa, str)
        assert isinstance(self.posiadlosc.kolor, str)
        assert isinstance(self.posiadlosc.cena, int)
        assert isinstance(self.posiadlosc.zastaw_kwota, int)
        assert isinstance(self.posiadlosc.cena_domu, int)
        assert isinstance(self.posiadlosc.wlasciciel, (None | Gracz)) is True
        assert isinstance(self.posiadlosc.czy_zastawiona, bool)
        assert isinstance(self.posiadlosc.liczba_domow, int)
        assert isinstance(self.posiadlosc.liczba_hoteli, int)

    @pytest.mark.parametrize("liczba_domow", (0, 1, 2))
    def test_zwroc_info(self, liczba_domow):
        self.posiadlosc.liczba_domow = liczba_domow

        zwrocone_info = self.posiadlosc.zwroc_info()
        przewidywane_info = \
            (f"Nazwa: {TestPosiadlosc.NAZWA} \n"
             f"Cena: {TestPosiadlosc.CENA}   Czynsz: {TestPosiadlosc.CZYNSZ}  Zastaw: {TestPosiadlosc.ZASTAW} "
             f"\nCena-dom: {TestPosiadlosc.CENA_DOMU}  Liczba domkow: {liczba_domow}") \
            if liczba_domow > 0 \
            else \
            (f"Nazwa: {TestPosiadlosc.NAZWA} \n"
             f"Cena: {TestPosiadlosc.CENA}   Czynsz: {TestPosiadlosc.CZYNSZ}  Zastaw: {TestPosiadlosc.ZASTAW} "
             f"\nCena-dom: {TestPosiadlosc.CENA_DOMU}")

        assert zwrocone_info == przewidywane_info

    def test_kup_posiadlosc_udany(self):
        self.posiadlosc.kup_posiadlosc()

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_Przycisk.py
import copy
import pytest
import pygame
from typing import Collection

from src.Przycisk import Przycisk


class TestPrzycisk:
    PRZYCISK_POS_X = 100
    PRZYCISK_POS_Y = 100
    PRZYCISK_SZEROKOSC = 100
    PRZYCISK_WYSOKOSC = 100

    LEWO_GORA = (PRZYCISK_POS_X, PRZYCISK_POS_Y)
    LEWO_DOL = (PRZYCISK_POS_X, PRZYCISK_POS_Y + PRZYCISK_WYSOKOSC - 1)
    PRAWO_GORA = (PRZYCISK_POS_X + PRZYCISK_SZEROKOSC - 1, PRZYCISK_POS_Y)
    PRAWO_DOL = (PRZYCISK_POS_X + PRZYCISK_SZEROKOSC - 1, PRZYCISK_POS_Y + PRZYCISK_WYSOKOSC - 1)

    def setup_method(self):
        pygame.init()
        # pygame.font.init()

        self.screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        self.przycisk = Przycisk(TestPrzycisk.PRZYCISK_POS_X, TestPrzycisk.PRZYCISK_POS_Y,
                                 TestPrzycisk.PRZYCISK_SZEROKOSC, TestPrzycisk.PRZYCISK_WYSOKOSC,
                                 pygame.color.THECOLORS["green"],
                                 pygame.color.THECOLORS["violet"],
                                 "TestPrzycisk",
                                 pygame.color.THECOLORS["black"])

    def test_inicjalizacja_typow_zmiennych(self):
        assert type(self.przycisk.rect) is pygame.Rect
        assert isinstance(self.przycisk.color, (pygame.color.Color, Collection)) is True
        assert isinstance(self.przycisk.hover_color, (pygame.color.Color, Collection)) is True
        assert type(self.przycisk.font) is pygame.font.Font

    def test_is_clicked_wewnatrz_przycisku(self):
        pozycja_klikniecia = (TestPrzycisk.PRZYCISK_POS_X + TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                              TestPrzycisk.PRZYCISK_POS_Y + TestPrzycisk.PRZYCISK_WYSOKOSC // 2)
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is True

    def test_is_clicked_zewnatrz_przycisku(self):
        pozycja_klikniecia = (TestPrzycisk.PRZYCISK_POS_X - TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                              TestPrzycisk.PRZYCISK_POS_Y - TestPrzycisk.PRZYCISK_WYSOKOSC // 2)
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is False

    # odpowiednio: lewo-gora, prawo-dol, lewo-dol, prawo-gora
    @pytest.mark.parametrize("pozycja_klikniecia", [LEWO_GORA, LEWO_DOL, PRAWO_GORA, PRAWO_DOL])
    def test_is_clicked_na_granicach_przycisku(self, pozycja_klikniecia):
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is True

    # Zmiana w display na HIDDEN sprawia ze ten nie przechodzi, testowany na RESIZABLE
    def test_hover_kolor(self):
        kursor_pozycja_w_przycisku = (TestPrzycisk.PRZYCISK_POS_X + TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                                      TestPrzycisk.PRZYCISK_POS_Y + TestPrzycisk.PRZYCISK_WYSOKOSC // 2)

        pygame.mouse.set_pos(kursor_pozycja_w_przycisku)
        self.przycisk.draw(self.screen)

        przycisk_tlo_kolor = self.screen.get_at(kursor_pozycja_w_przycisku)

        assert (przycisk_tlo_kolor == self.przycisk.hover_color)

    @pytest.mark.parametrize("pozycja_kursora", [LEWO_GORA, LEWO_DOL, PRAWO_GORA, PRAWO_DOL])
    def test_kolor_brzegi_przycisku(self, pozycja_kursora: tuple):
        pygame.mouse.set_pos(pozycja_kursora)
        self.przycisk.draw(self.screen)

        przycisk_tlo_kolor = self.screen.get_at(pozycja_kursora)

        assert (przycisk_tlo_kolor == self.przycisk.hover_color)

    # Uwaga na wymiary, nie dawać wartości równych, defaultowych!
    @pytest.mark.parametrize("wymiary", [(10, 10), (110, 110)])
    def test_updateSize_zgodne_wymiary(self, wymiary: tuple):
        poprzednie_wymiary = self.przycisk.pobierz_wymiary()

        self.przycisk.updateSize(TestPrzycisk.PRZYCISK_POS_X,
                                 TestPrzycisk.PRZYCISK_POS_Y,
                                 wymiary[0], wymiary[1])

        nowe_wymiary = self.przycisk.pobierz_wymiary()

        assert poprzednie_wymiary.width != nowe_wymiary.width
        assert poprzednie_wymiary.height != nowe_wymiary.height
        assert wymiary[0] == nowe_wymiary.width
        assert wymiary[1] == nowe_wymiary.height

    @pytest.mark.parametrize("wymiary", [(0, 0), (-5, -10), (-2, 10), (20, -43)])
    def test_updateSize_niezgodne_wymiary(self, wymiary: tuple):
        poprzednie_wymiary = self.przycisk.pobierz_wymiary()

        self.przycisk.updateSize(TestPrzycisk.PRZYCISK_POS_X,
                                 TestPrzycisk.PRZYCISK_POS_Y,
                                 wymiary[0], wymiary[1])

        nowe_wymiary = self.przycisk.pobierz_wymiary()

        assert poprzednie_wymiary.width == nowe_wymiary.width
        assert poprzednie_wymiary.height == nowe_wymiary.height
        assert wymiary[0] != nowe_wymiary.width
        assert wymiary[1] != nowe_wymiary.height


