C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\Main.py
import os
import pygame
import shutil
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci
from src.Wizualizator import Wizualizator
from src.Menu import Menu


class Main:
    _SEC_TO_MS = 1000
    LIMIT_CZASU_GRY = 0
    LIMIT_CZASU_TURY = 0

    def __init__(self):
        pygame.init()  # Inicjalizacja pygame
        pygame.font.init()  # Inicjalizacja modułu fontów

        os.environ["SDL_VIDEO_CENTERED"] = "1"

        self.font = pygame.font.Font(None, 20)

        pygame.display.set_caption("Monopoly")
        self._screen = pygame.display.set_mode((1200, 660), pygame.RESIZABLE)

        self._screen_info = pygame.display.Info()
        self._screen_width = self._screen_info.current_w
        self._screen_height = self._screen_info.current_h

        self._gra = None
        self._clock = pygame.time.Clock()
        self._running = True
        self.wait_flag = 0
        self._delta_time = 0
        self.input_text = ""
        self.wizualizator = Wizualizator()
        self.menu = Menu(self.wizualizator, self)
        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font, self.wizualizator)

        self.uplyniety_czas_gry = 0
        self.uplyniety_czas_tury = 0
        self.turn_start_time = (
            pygame.time.get_ticks()
        )  # Inicjalizacja czasu startu tury

    def __del__(self):
        pygame.quit()
        # del self._gra

    def start(self):
        self._kontroler_wiadomosci.dodaj_wiadomosc("Witaj w UJpoly!")
        while self.menu.stan != "stop":

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self._running = False
                elif event.type == pygame.VIDEORESIZE:
                    self._screen_width = event.w
                    self._screen_height = event.h
                self.menu.handle_event(event, self._screen_width, self._screen_height)

            self._screen.fill(self.wizualizator.kolor_tla)
            if self.menu.stan != "stop":
                self.menu.draw(self._screen, self._screen_width, self._screen_height)
            elif self.menu.typ_stopu == "nowa":
                self._gra = Gra(
                    self._screen,
                    self._kontroler_wiadomosci,
                    self.menu.liczba_graczy,
                    self.menu.gracze,
                    self.wizualizator,
                    self._screen_width,
                    self._screen_height,
                    self,
                )
                self._petla_gry()
            else:
                self._gra = Gra(
                    self._screen,
                    self._kontroler_wiadomosci,
                    0,
                    [],
                    self.wizualizator,
                    self._screen_width,
                    self._screen_height,
                    self,
                )
                self._gra.wczytaj_gre()
                self._petla_gry()
            pygame.display.flip()

    def _petla_gry(self):
        while self._running:
            self._aktualizuj_delta_time()
            self.uplyniety_czas_gry += self._delta_time
            self._petla_zdarzen(pygame.event.get())
            if self.wait_flag == 1:
                self._aktualizuj_czas_gry()
            # self._petla_zdarzen(pygame.event.get())
            self._aktualizuj(delta_time=self._delta_time)
            self._wyswietlaj()

    def _aktualizuj_delta_time(self):
        self._clock.tick(60)
        self._delta_time = self._clock.get_time() / Main._SEC_TO_MS

    def _aktualizuj_czas_gry(self):
        self.uplyniety_czas_tury = (
            pygame.time.get_ticks() - self.turn_start_time
        ) / Main._SEC_TO_MS

        if self.LIMIT_CZASU_GRY != 999:
            if self.uplyniety_czas_gry >= self.LIMIT_CZASU_GRY:
                self._running = False
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Czas gry minął! Koniec gry."
                )

        if self.LIMIT_CZASU_TURY != 999:
            if self.uplyniety_czas_tury >= self.LIMIT_CZASU_TURY:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Czas tury minął! Przechodzimy do następnego gracza."
                )
                self._gra.zamknij_wszystkie_okna()
                self._wyswietlaj()
                self.wait_flag = 0
                self.turn_start_time = pygame.time.get_ticks()

    def _petla_zdarzen(self, events_list):
        for event in events_list:
            if event.type == pygame.QUIT:
                self._running = False
                break
            elif (
                event.type == pygame.KEYDOWN
                and event.key == pygame.K_SPACE
                and self.wait_flag == 0
            ):
                self._waiting_for_space = False
                self.wait_flag = 1
            elif event.type == pygame.MOUSEBUTTONDOWN and self.wait_flag == 0:
                self.wait_flag = 1
            elif event.type == pygame.MOUSEBUTTONDOWN and self.wait_flag == 1:
                self.wait_flag = 0

            elif event.type == pygame.VIDEORESIZE:
                self._screen_width = event.w
                self._screen_height = event.h
            self._gra.aktualizacja_zdarzenia(event)

    def _aktualizuj(self, delta_time):
        self._gra.aktualizuj(delta_time)

    def render_text(self, text, pos):
        text_surface = self.font.render(text, True, self.wizualizator.kolor_czcionki)
        self._screen.blit(text_surface, pos)

    def _wyswietlaj(self):
        self._screen.fill(self.wizualizator.kolor_tla)
        self._gra.wyswietl(self._screen, self._screen_width, self._screen_height)
        pygame.display.update()


def reset_pionki():
    pionek_default_dir = "graphics/pionek_default"
    pionek_dir = "graphics/pionek"

    for filename in os.listdir(pionek_dir):
        file_path = os.path.join(pionek_dir, filename)
        if os.path.isfile(file_path):
            os.remove(file_path)

    for filename in os.listdir(pionek_default_dir):
        src_path = os.path.join(pionek_default_dir, filename)
        dst_path = os.path.join(pionek_dir, filename)
        shutil.copy(src_path, dst_path)


if __name__ == "__main__":
    reset_pionki()
    game_runner = Main()
    game_runner.start()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\searcher.py
import os
from pathlib import Path


def get_all_python_files(directory):
    python_files = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(".py"):
                python_files.append(Path(root) / file)
    return python_files


def save_files_content_to_text(python_files, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for file in python_files:
            with open(file, "r", encoding="utf-8") as py_file:
                content = py_file.read()
                f.write(f"{file}\n{content}\n\n")


def main():
    directory = "C:/Users/barte/OneDrive/Pulpit/Studia/ROK II/Semestr 4/IO/ProjektFUN/Monopoly_IO_UJ"  # Zmień na właściwą ścieżkę do katalogu
    output_file = "output.txt"

    python_files = get_all_python_files(directory)
    save_files_content_to_text(python_files, output_file)
    print(f"Zapisano zawartość {len(python_files)} plików .py do {output_file}")


if __name__ == "__main__":
    main()


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Gra.py
import random
import pygame
import pickle

from src.okno.AkcjaPolaOkno import AkcjaPolaOkno
from src.okno.AkcjaNieruchomosciOkno import AkcjaNieruchomosciOkno
from src.okno.AkcjaKartOkno import AkcjaKartOkno
from src.okno.AkcjaZastawOkno import AkcjaZastawOkno
from src.okno.AkcjaZagadekOkno import AkcjaZagadekOkno
from src.okno.AkcjaWiezieniaOkno import AkcjaWiezieniaOkno
from src.okno.AkcjaStatystykOkno import AkcjaStatystykOkno
from src.Wizualizator import Wizualizator
from src.Plansza import Plansza
from src.Posiadlosc import *
from src.Pionek import Pionek
from src.KontrolerWiadomosci import KontrolerWiadomosci
from src.interface.IGra import IGra
from src.Przycisk import Przycisk


KWOTA_POCZATKOWA = 16000
MIN_LICZBA_GRACZY = 2
MAX_LICZBA_GRACZY = 5
LICZBA_POL = 40


# Dodajemy listę kolorów dla pionków jako obiekty pygame.Color
PIECE_COLORS: list[pygame.Color] = [
    pygame.Color("red"),
    pygame.Color("green"),
    pygame.Color("blue"),
    pygame.Color("yellow"),
    pygame.Color("purple"),
]

umiejetnosci = [
    "wiecej_pieniedzy_na_start",
    "porusza_sie_o_1_pole_wiecej",
    "karta_wyjscia_z_wiezienia",
    "sprzedaje_nieruchomosci_za_oryginalna_ceny",
    "dostaje_wiecej_za_przejscie_przez_start",
    "placi_mniejsze_czynsze",
]


class Gra:
    def __init__(
        self,
        glowne_okno: pygame.Surface,
        kontroler_wiadomosci: KontrolerWiadomosci,
        liczba_graczy: int,
        gracze: list[str],
        wizualizator,
        szerokosc_ekranu,
        wysokosc_ekranu,
        main_ref,
    ):
        random.shuffle(umiejetnosci)
        self._glowne_okno: pygame.Surface = glowne_okno
        self._kwota_poczatkowa = KWOTA_POCZATKOWA
        self._liczba_graczy = liczba_graczy
        self._suma_oczek = 0
        self._kolejny_rzut_kostka = False
        self._indeks_aktualnego_gracza = 0
        self.messages = []
        self.aktualna_szerokosc_ekranu = szerokosc_ekranu
        self.aktualna_wysokosc_ekranu = wysokosc_ekranu
        self._kontroler_wiadomosci = kontroler_wiadomosci
        self.wizualizator = wizualizator
        self._gracze = self.stworz_graczy(gracze)
        self.main = main_ref

        # sekcja wizualna
        self.kolor_przycisku = self.wizualizator.kolor_przycisku
        self.kolor_gdy_kursor = self.wizualizator.kolor_gdy_kursor
        self.kolor_tekstu = self.wizualizator.kolor_czcionki_na_przycisku
        self.kolor_tla = self.wizualizator.kolor_tla
        self.kolor_czcionki = self.wizualizator.kolor_czcionki
        self.kolor_czcionki_tyl_karty = self.wizualizator.kolor_czcionki_tyl_karty
        self.czcionka = self.wizualizator.czcionka
        self.kolor_nakladki = self.wizualizator.kolor_nakladki
        self.przezroczystosc_nakladki = self.wizualizator.przezroczystosc_nakladki
        self.font = pygame.font.Font(self.czcionka, 20)
        self.end_game_flag = 1

        # sekcja okien
        self._plansza = Plansza()
        self._plansza.aktualizacja_rozmiaru(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )

        self.akcja_pola_okno = AkcjaPolaOkno(self)
        self.akcja_nieruchomosci_okno = AkcjaNieruchomosciOkno(self)
        self.akcja_kart_okno = AkcjaKartOkno(self)
        self.akcja_zastaw_okno = AkcjaZastawOkno(self)
        self.akcja_zagadek_okno = AkcjaZagadekOkno(self)
        self.akcja_wiezienie_okno = AkcjaWiezieniaOkno(self)
        self.akcja_statystyk_okno = AkcjaStatystykOkno(self)
        self.czy_akcja_zakonczona = True

        # Załaduj obrazy kostek
        self.dice_images = []
        for i in range(1, 7):
            image_path = f"graphics/dice/dice{i}.png"
            image = pygame.image.load(image_path)
            self.dice_images.append(pygame.transform.scale(image, (100, 100)))

        # feature_testingMechanism
        self.input_text = ""
        print("HELLO from Gra")
        self._plansza.plansza[0].ilosc_graczy_na_polu = liczba_graczy

        # nowa tura
        self.nastepna_tura = Przycisk(
            szerokosc_ekranu * 0.3,
            wysokosc_ekranu * 0.7,
            szerokosc_ekranu * 0.2,
            wysokosc_ekranu * 0.15,
            self.wizualizator.kolor_przycisku_tury,
            self.wizualizator.kolor_przycisku_tury_gdy_kursor,
            "tura",
            self.wizualizator.kolor_czcionki,
            26,
        )
        self.zapisz_wyjdz = Przycisk(
            szerokosc_ekranu * 0.3,
            wysokosc_ekranu * 0.75,
            szerokosc_ekranu * 0.2,
            wysokosc_ekranu * 0.15,
            self.wizualizator.kolor_przycisku_tury,
            self.wizualizator.kolor_przycisku_tury_gdy_kursor,
            "Zapisz i wyjdz",
            self.wizualizator.kolor_czcionki,
            8,
        )

        self.gracz_poprzedniej_tury = -1
        self.zwyciezca = -1
        self.waiter = 4

    def stworz_graczy(self, nazwy_graczy) -> list[Gracz]:
        lista_graczy = [
            Gracz(
                name,
                KWOTA_POCZATKOWA,
                Pionek(
                    0,
                    PIECE_COLORS[i],
                    "graphics/pionek/PionekColor" + str(i + 1) + ".png",
                    self.aktualna_szerokosc_ekranu,
                    self.aktualna_wysokosc_ekranu,
                    self._liczba_graczy,
                ),
                umiejetnosci[i],
            )
            for i, name in enumerate(nazwy_graczy)
        ]

        return lista_graczy

    def analizuj_rzut(self, kostka_pierwsza, kostka_druga, bonus):
        self._kolejny_rzut_kostka = False

        if kostka_pierwsza + kostka_druga == 7:
            self._kolejny_rzut_kostka = True
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Siódemka, otrzymujesz dodatkową turę"
            )

        if self._suma_oczek == 21:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Uzyskałeś logarytmiczne przyspieszenie. Idziesz do więzienia"
            )
            self.przesun_gracza_bez_raportu(
                self._gracze[self._indeks_aktualnego_gracza], 10
            )
            self._gracze[self._indeks_aktualnego_gracza].tury_w_wiezieniu = 2
            self.akcja_wiezienie_okno.czy_wiezienie = True
            self._kolejny_rzut_kostka = False
        else:
            self.przesun_gracza(
                self._gracze[self._indeks_aktualnego_gracza],
                kostka_pierwsza + kostka_druga + bonus,
            )

    def wyswietl_kostki(self, screen, dice1, dice2):
        # im wieksze tym mniejszy odstep
        oddalenie_kostek_od_siebie = 8.1
        self.aktualizuj_rozmiar_kostek()
        dice_x = self.aktualna_szerokosc_ekranu * 0.213
        dice_y = self.aktualna_wysokosc_ekranu * 0.38
        screen.blit(self.dice_images[dice1 - 1], (dice_x, dice_y))
        screen.blit(
            self.dice_images[dice2 - 1],
            (
                dice_x + (self.aktualna_wysokosc_ekranu / oddalenie_kostek_od_siebie),
                dice_y,
            ),
        )

    def aktualizuj_rozmiar_kostek(self):
        # im wiekszy tym mniejsze kostki
        skalar_kostek = 10

        for i in range(1, 7):
            image_path = f"graphics/dice/dice{i}.png"
            image = pygame.image.load(image_path)
            self.dice_images[i - 1] = pygame.transform.scale(
                image,
                (
                    self.aktualna_wysokosc_ekranu / skalar_kostek,
                    self.aktualna_wysokosc_ekranu / skalar_kostek,
                ),
            )

    def symuluj_rzut(self):
        liczba_klatek = 5  # Liczba klatek animacji
        for _ in range(liczba_klatek):
            # Losowe wartości dla obu kostek
            dice1 = random.randint(1, 6)
            dice2 = random.randint(1, 6)
            self.wyswietl_kostki(self._glowne_okno, dice1, dice2)
            pygame.display.update()
            pygame.time.wait(75)  # Czas oczekiwania między klatkami animacji

        # Ostateczne wartości kostek
        kostka_1 = random.randint(1, 6)
        kostka_2 = random.randint(1, 6)
        return kostka_1, kostka_2

    def przesun_gracza(self, gracz, ruch):
        stara_pozycja = gracz.pionek.numer_pola
        nowa_pozycja = (stara_pozycja + ruch) % LICZBA_POL
        gracz.pionek.przesun(ruch, self)
        gracz.czy_przeszedl_przez_start(self, stara_pozycja)

        self._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {gracz.id} przesunął się z pozycji {stara_pozycja} na {nowa_pozycja}"
        )
        gracz.pionek.wyswietl(self._glowne_okno, self)
        pole = self._plansza.pobierz_pole(nowa_pozycja)
        self.wykonaj_akcje_na_polu(gracz, pole)

    def przesun_gracza_bez_raportu(self, gracz, nowa_pozycja):
        stara_pozycja = gracz.pionek.numer_pola
        gracz.pionek.przesun((nowa_pozycja - stara_pozycja) % LICZBA_POL, self)
        gracz.pionek.wyswietl(self._glowne_okno, self)

    def akcja_kupienia_nieruchomosci(self, gracz, posiadlosc, nr_pola=1):
        if posiadlosc.kolor == "kolo" or posiadlosc.kolor == "pozaWmii":
            return
        if not gracz.caly_kolor(posiadlosc.kolor):
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie posiadasz wszystkich kart z koloru"
            )
            return
        if posiadlosc.czy_zastawiona:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie można kupić domku lub hotelu na zastawionej posiadłości"
            )
            return

        nieruchomosc = gracz.czy_cztery_domki(posiadlosc)
        if nieruchomosc == "nie":
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Masz już 4 domki na tym polu. Kup domy na innych polach {posiadlosc.kolor}"
            )
            return

        self.akcja_nieruchomosci_okno.czy_kupno = True
        self.akcja_nieruchomosci_okno.nieruchomosc = nieruchomosc
        self.czy_akcja_zakonczona = False

    def wykup_z_wiezienia_rzutem(self):
        liczba_siodemek = 0
        for x in range(3):
            kostka_pierwsza, kostka_druga = self.symuluj_rzut()
            suma = kostka_pierwsza + kostka_druga
            if suma == 7:
                liczba_siodemek += 1
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}, Kostka druga: {kostka_druga}"
            )
            self.wyswietl_kostki(self._glowne_okno, kostka_pierwsza, kostka_druga)
            pygame.display.update()  # Aktualizuj ekran po wyświetleniu kostek
            pygame.time.wait(1000)

        if liczba_siodemek < 2:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Wyrzuciłeś {liczba_siodemek} siódemek. Idziesz do więzienia"
            )
            return False
        self._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Wyrzuciłeś {liczba_siodemek} siódemek. Unikasz więzienia"
        )
        return True

    def wykonaj_akcje_na_polu(self, gracz, pole):
        self._kontroler_wiadomosci.dodaj_wiadomosc(pole.zwroc_info())

        if pole.typ == "Podatek dochodowy":
            self.czy_akcja_zakonczona = False
            self.akcja_zagadek_okno.akcja_podatkowa(gracz, pole)
            self.akcja_zagadek_okno.przygotuj_zagadke()
            self.akcja_zagadek_okno.czy_zagadka = True

        elif pole.typ == "Szansa":
            self.czy_akcja_zakonczona = False
            self.akcja_kart_okno.czy_szansa = True
            self.akcja_kart_okno.przygotuj_karte(gracz)

        elif pole.typ == "Wiezienie":
            self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz odwiedza więzienie")

        elif pole.typ == "Idz do wiezienia":
            self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz idzie do więzienia")
            if self.wykup_z_wiezienia_rzutem():
                self.czy_akcja_zakonczona = True
                return
            if gracz.liczba_kart_wyjdz_z_wiezienia > 0:
                gracz.liczba_kart_wyjdz_z_wiezienia -= 1
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Wykorzystano kartę 'wyjdź bezpłatnie z więzienia'"
                )
            else:
                self.akcja_wiezienie_okno.czy_wiezienie = True
                self.czy_akcja_zakonczona = False
                gracz.tury_w_wiezieniu = 2
                self.przesun_gracza_bez_raportu(
                    self._gracze[self._indeks_aktualnego_gracza], 10
                )

        elif pole.typ == "Posiadlosc":
            if isinstance(pole, Posiadlosc):
                posiadlosc = pole
                # posiadlosc.wyswietl_info(self)
                if posiadlosc.wlasciciel is None:
                    self.czy_akcja_zakonczona = False
                    self.akcja_pola_okno.czy_akcja_pola = True
                    self.akcja_pola_okno.akcja_kupowania(posiadlosc, gracz)
                elif posiadlosc.wlasciciel == gracz:
                    self.akcja_kupienia_nieruchomosci(gracz, posiadlosc)
                    self.akcja_nieruchomosci_okno.akcja_kupowania(posiadlosc, gracz)
                else:
                    if posiadlosc.czy_zastawiona:
                        return
                    self._kontroler_wiadomosci.dodaj_wiadomosc("Gracz płaci czynsz")
                    gracz.zaplac_czynsz(self, posiadlosc)
            else:
                raise Exception("Błąd. Posiadłość jest innym polem")

    def tura(self):

        if self.gracz_poprzedniej_tury != self._indeks_aktualnego_gracza:
            self._kontroler_wiadomosci.usun_wszystkie_wiadomosci()
        self.gracz_poprzedniej_tury = self._indeks_aktualnego_gracza

        self._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Teraz tura gracza: {self._gracze[self._indeks_aktualnego_gracza].id}"
        )

        if self._gracze[self._indeks_aktualnego_gracza].tury_w_wiezieniu:
            self._gracze[self._indeks_aktualnego_gracza].tury_w_wiezieniu -= 1
            if self._gracze[self._indeks_aktualnego_gracza].tury_w_wiezieniu == 0:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"Gracz {self._indeks_aktualnego_gracza + 1} opuszcza więzienie"
                )
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"{self._gracze[self._indeks_aktualnego_gracza].id} jest w więzieniu. Zostało {self._gracze[self._indeks_aktualnego_gracza].tury_w_wiezieniu} tur."
                )

        else:
            kostka_pierwsza, kostka_druga = self.symuluj_rzut()

            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Kostka pierwsza: {kostka_pierwsza}"
            )
            self._kontroler_wiadomosci.dodaj_wiadomosc(f"Kostka druga: {kostka_druga}")

            #
            # kostka_druga = 6
            # kostka_pierwsza = 6
            #
            self._suma_oczek += kostka_pierwsza + kostka_druga
            umiejetnosc = 0
            if (
                self._gracze[self._indeks_aktualnego_gracza].umiejetnosc
                == "porusza_sie_o_1_pole_wiecej"
            ):
                umiejetnosc = 1
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"Korzystasz z umiejętności: ruch +1"
                )

            # Wyświetl kostki
            self.wyswietl_kostki(self._glowne_okno, kostka_pierwsza, kostka_druga)
            pygame.display.update()  # Aktualizuj ekran po wyświetleniu kostek
            pygame.time.wait(1000)

            self.analizuj_rzut(kostka_pierwsza, kostka_druga, umiejetnosc)

        # self._gracze[self._indeks_aktualnego_gracza].kwota -= 1000
        # self._gracze[self._indeks_aktualnego_gracza].statystyka.aktualizuj_stan_pieniedzy(self._gracze[self._indeks_aktualnego_gracza].kwota)
        self.kto_zbankrutowal()

        if self._gracze[self._indeks_aktualnego_gracza].czy_aktywny == False:
            self.zamknij_wszystkie_okna()

        if self.czy_zwyciezca():
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Zwycięża: {self._gracze[self.zwyciezca].id}"
            )

        if (not self._kolejny_rzut_kostka) and self.zwyciezca == -1:

            while True:
                self._indeks_aktualnego_gracza = (
                    self._indeks_aktualnego_gracza + 1
                ) % self._liczba_graczy
                self._suma_oczek = 0

                if self._gracze[self._indeks_aktualnego_gracza].czy_aktywny == True:
                    break
                # zapetla sie gdy bedzie 1 gracz i zbankrutuje (wtedy powinno sie pokazac info o wygranej)

        self.main.turn_start_time = pygame.time.get_ticks()

    def get_messages(self):
        messages = self.messages.copy()
        self.messages.clear()
        return messages

    # override
    def aktualizacja(self):
        pass
        # if not self._stos_otwartych_okien.czy_pusty():
        #     self._stos_otwartych_okien.gora().aktualizacja()

        # if not self.akcja_pola_okno.czy_koniec_zakupu():
        #     self._czy_gracz_ma_ture = False
        #     self._stos_otwartych_okien.usun()

    def process_input(self, input_text):
        self._kontroler_wiadomosci.dodaj_wiadomosc(f"Wprowadzono: {input_text}")
        if input_text.isdigit():
            liczba_graczy = int(input_text)
            if liczba_graczy >= 2 and liczba_graczy <= 5:
                self._liczba_graczy = liczba_graczy
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"Ustaw liczbe graczy na {liczba_graczy}"
                )
                self.przygotuj_graczy()
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Naciśnij spację, aby rzucić kostką"
                )
            else:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Nieprawidłowa liczba graczy."
                )
        else:
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Nieznana komenda: {input_text}"
            )

    # metoda pomocnicza w celu wykonania pojdynczego zdarzenia
    # oddzielona od aktualizacja_zdarzenia, na rzecz architektury i wykorzystania klasy GraProxy(event injection, tracking)
    def wykonaj_zdarzenie(self, event: pygame.event.Event):
        if (
            event.type == pygame.KEYDOWN
            and event.key == pygame.K_SPACE
            and self.czy_akcja_zakonczona
            and self.zwyciezca == -1
        ):
            self.tura()
        if (
            self.nastepna_tura.is_clicked(event)
            and self.czy_akcja_zakonczona
            and self.zwyciezca == -1
        ):
            self.tura()
        if (
            self.zapisz_wyjdz.is_clicked(event)
            and self.czy_akcja_zakonczona
            and self.zwyciezca == -1
        ):
            self.input_text = ""
            self.zapisz_gre()
            pygame.quit()
        elif event.type == pygame.KEYDOWN and self.zwyciezca == -1:
            if event.key == pygame.K_RETURN:
                # self.process_input(self.input_text)
                self.input_text = ""
            elif event.key == pygame.K_BACKSPACE:
                self.input_text = self.input_text[:-1]
            elif event.key == pygame.K_s:
                self.input_text = ""
                self.zapisz_gre()
                pygame.quit()
            else:
                self.input_text += event.unicode
        elif event.type == pygame.VIDEORESIZE:
            self.aktualna_szerokosc_ekranu = event.w
            self.aktualna_wysokosc_ekranu = event.h

            # Rozmiar nie moze byc mniejszy niz 500 na 500
            # if event.w > 1000 and event.h > 550:
            self._plansza.aktualizacja_rozmiaru(
                self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
            )

            for gracz in self._gracze:
                gracz.pionek.aktualizacja_rozmiaru(
                    self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
                )

        self.akcja_pola_okno.aktualizacja_zdarzen(event)
        self.akcja_nieruchomosci_okno.aktualizacja_zdarzen(event)
        self.akcja_kart_okno.aktualizacja_zdarzen(event)
        self.akcja_zastaw_okno.aktualizacja_zdarzen(event)
        self.akcja_zagadek_okno.aktualizacja_zdarzen(event)
        self.akcja_wiezienie_okno.aktualizacja_zdarzen(event)

    # override
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        self.wykonaj_zdarzenie(event)

    def zamknij_wszystkie_okna(self):
        self.akcja_pola_okno.czy_akcja_pola = False
        self.akcja_pola_okno.zamknij()

        self.akcja_nieruchomosci_okno.czy_kupno = False
        self.akcja_nieruchomosci_okno.zamknij()

        if self.akcja_kart_okno.czy_szansa:
            self._plansza.karty.aktualna_karta.wykonaj_akcje(
                self, self._gracze[self._indeks_aktualnego_gracza]
            )
        self.akcja_kart_okno.czy_szansa = False
        self.akcja_kart_okno.zamknij()

        self.akcja_zastaw_okno.czy_zastaw = False
        self.akcja_zastaw_okno.zamknij()

        if self.akcja_zagadek_okno.czy_zagadka:
            print(self._gracze[self._indeks_aktualnego_gracza].kwota)
            if 1500 > self._gracze[self._indeks_aktualnego_gracza].kwota:
                if self.pobierz_info_tak_nie(
                    "Nie masz wystarczająco dużo pieniędzy, aby zapłacić podatek. Czy chcesz zastawić którąś z nieruchmości? Jeśli tego nie zrobisz przegrywasz."
                ):
                    self._gracze[self._indeks_aktualnego_gracza].zastaw_nieruchomosci()
            if 1500 > self._gracze[self._indeks_aktualnego_gracza].kwota:
                self.messages.append("Bankrutujesz")
            self._gracze[self._indeks_aktualnego_gracza].kwota -= 1500
            self._kontroler_wiadomosci.dodaj_wiadomosc(
                "Kara za nie wybranie odpowiedzi, zapłacono: " + str(1500)
            )
            self._gracze[
                self._indeks_aktualnego_gracza
            ].statystyka.aktualizuj_stan_pieniedzy(
                self._gracze[self._indeks_aktualnego_gracza].kwota
            )
        self.akcja_zagadek_okno.czy_zagadka = False
        self.akcja_zagadek_okno.zamknij_bez_wiadomosci()

        self.akcja_wiezienie_okno.czy_wiezienie = False
        self.akcja_wiezienie_okno.zamknij()

    def render_text(self, text, pos):
        text_surface = self.font.render(text, True, (0, 0, 0))
        self._glowne_okno.blit(text_surface, pos)

    def render_game_time(self):

        self.font1 = pygame.font.Font(
            self.czcionka, int(self.aktualna_szerokosc_ekranu / 80)
        )

        pozostaly_czas_gry = self.main.LIMIT_CZASU_GRY - int(
            self.main.uplyniety_czas_gry
        )
        game_time_text = f"Czas gry: {int(self.main.uplyniety_czas_gry // 60):02}:{int(self.main.uplyniety_czas_gry % 60):02}"
        if pozostaly_czas_gry <= 300:
            text_color = pygame.Color("red")
            if self.end_game_flag == 1:
                self._kontroler_wiadomosci.dodaj_wiadomosc(
                    "Zostało mniej niż 5 minut do końca gry"
                )
                self.end_game_flag = 0
        else:
            text_color = self.wizualizator.kolor_napisu_gracz_tury

        tekst = self.font1.render(game_time_text, True, text_color)
        self._glowne_okno.blit(
            tekst,
            (
                self.aktualna_szerokosc_ekranu * 0.078,
                self.aktualna_wysokosc_ekranu * 0.85,
            ),
        )

    def render_turn_time(self):
        if self.main.LIMIT_CZASU_TURY != 999:
            self.font1 = pygame.font.Font(
                self.czcionka, int(self.aktualna_szerokosc_ekranu / 80)
            )

            pozostaly_czas_tury = self.main.LIMIT_CZASU_TURY - int(
                self.main.uplyniety_czas_tury
            )
            turn_time_text = f"Czas tury: {pozostaly_czas_tury:02}"
            if pozostaly_czas_tury <= 10:
                text_color = pygame.Color("red")
            else:
                text_color = self.wizualizator.kolor_napisu_gracz_tury

            tekst = self.font1.render(turn_time_text, True, text_color)
            self._glowne_okno.blit(
                tekst,
                (
                    self.aktualna_szerokosc_ekranu * 0.418,
                    self.aktualna_wysokosc_ekranu * 0.85,
                ),
            )

    # override
    def wyswietl(self, okno: pygame.Surface, W, H):

        self.aktualizuj_rozmiar_okien()

        if self.zwyciezca != -1 and self.waiter < 0:
            self.wyswietl_zwyciezce()
            return

        self.render_text(
            self.input_text,
            (self.aktualna_szerokosc_ekranu - 400, self.aktualna_wysokosc_ekranu - 50),
        )

        self._plansza.render(self._glowne_okno)
        self.nastepna_tura.draw(self._glowne_okno)
        self.zapisz_wyjdz.draw(self._glowne_okno)

        for gracz in self._gracze:
            if gracz.czy_aktywny:
                gracz.pionek.wyswietl(self._glowne_okno, self)

        self.wypisz_nazwe_gracza_tury()
        self.akcja_statystyk_okno.wyswietl(self._glowne_okno)
        self._kontroler_wiadomosci.wyswietl(okno, W, H)
        self.akcja_wiezienie_okno.wyswietl(self._glowne_okno)
        self.akcja_pola_okno.wyswietl(self._glowne_okno)
        self.akcja_nieruchomosci_okno.wyswietl(self._glowne_okno)
        self.akcja_kart_okno.wyswietl(self._glowne_okno)
        self.akcja_zastaw_okno.wyswietl(self._glowne_okno)
        self.akcja_zagadek_okno.wyswietl(self._glowne_okno)

    def aktualizuj_rozmiar_okien(self):
        self.akcja_pola_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_nieruchomosci_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_kart_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_zagadek_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_wiezienie_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_zastaw_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )
        self.akcja_statystyk_okno.aktualizuj_rozmiar_okna(
            self.aktualna_szerokosc_ekranu, self.aktualna_wysokosc_ekranu
        )

        self.nastepna_tura.updateSize(
            self.aktualna_szerokosc_ekranu * 0.218,
            self.aktualna_wysokosc_ekranu * 0.64,
            self.aktualna_szerokosc_ekranu * 0.12,
            self.aktualna_wysokosc_ekranu * 0.08,
        )

        self.zapisz_wyjdz.updateSize(
            self.aktualna_szerokosc_ekranu * 0.245,
            self.aktualna_wysokosc_ekranu * 0.74,
            self.aktualna_szerokosc_ekranu * 0.06,
            self.aktualna_wysokosc_ekranu * 0.05,
        )

    def wypisz_nazwe_gracza_tury(self):
        self.render_game_time()  # Wyświetlanie czasu gry
        self.render_turn_time()  # Wyświetlanie czasu tury

        napis = "Tura gracza:"
        sciezka_do_pionka = self._gracze[
            self._indeks_aktualnego_gracza
        ].pionek.sciezka_do_grafiki

        self.skalar_czcionki = 40  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.czcionka, int(self.aktualna_szerokosc_ekranu / self.skalar_czcionki)
        )

        self.zdjecie_pionek = pygame.transform.scale(
            pygame.image.load(sciezka_do_pionka),
            (
                0.03 * self.aktualna_szerokosc_ekranu,
                0.03 * self.aktualna_szerokosc_ekranu,
            ),
        )

        self._glowne_okno.blit(
            self.zdjecie_pionek,
            (
                self.aktualna_szerokosc_ekranu * 0.32,
                self.aktualna_wysokosc_ekranu * 0.285,
            ),
        )

        tekst = self.font.render(napis, True, self.wizualizator.kolor_napisu_gracz_tury)
        self._glowne_okno.blit(
            tekst,
            (
                self.aktualna_szerokosc_ekranu * 0.21,
                self.aktualna_wysokosc_ekranu * 0.3,
            ),
        )

    def zapisz_gre(self):
        with open("save/gracze.pickle", "wb") as handle:
            pickle.dump(self._gracze, handle, protocol=pickle.HIGHEST_PROTOCOL)

        with open("save/liczba_graczy.pickle", "wb") as handle:
            pickle.dump(self._liczba_graczy, handle, protocol=pickle.HIGHEST_PROTOCOL)

        with open("save/indeks_aktualnego_gracza.pickle", "wb") as handle:
            pickle.dump(
                self._indeks_aktualnego_gracza, handle, protocol=pickle.HIGHEST_PROTOCOL
            )

        with open("save/messages.pickle", "wb") as handle:
            pickle.dump(self.messages, handle, protocol=pickle.HIGHEST_PROTOCOL)

        with open("save/plansza.pickle", "wb") as handle:
            pickle.dump(self._plansza, handle, protocol=pickle.HIGHEST_PROTOCOL)

        with open("save/gracz_poprzedniej_tury.pickle", "wb") as handle:
            pickle.dump(
                self.gracz_poprzedniej_tury, handle, protocol=pickle.HIGHEST_PROTOCOL
            )
        with open("save/zwyciezca.pickle", "wb") as handle:
            pickle.dump(self.zwyciezca, handle, protocol=pickle.HIGHEST_PROTOCOL)
        with open("save/waiter.pickle", "wb") as handle:
            pickle.dump(self.waiter, handle, protocol=pickle.HIGHEST_PROTOCOL)
        with open("save/czas_gry.pickle", "wb") as handle:
            pickle.dump(
                self.main.uplyniety_czas_gry, handle, protocol=pickle.HIGHEST_PROTOCOL
            )
        with open("save/limit_gra.pickle", "wb") as handle:
            pickle.dump(
                self.main.LIMIT_CZASU_GRY, handle, protocol=pickle.HIGHEST_PROTOCOL
            )
        with open("save/limit_tura.pickle", "wb") as handle:
            pickle.dump(
                self.main.LIMIT_CZASU_TURY, handle, protocol=pickle.HIGHEST_PROTOCOL
            )

    def wczytaj_gre(self):
        with open("save/gracze.pickle", "rb") as handle:
            self._gracze = pickle.load(handle)
        with open("save/liczba_graczy.pickle", "rb") as handle:
            self._liczba_graczy = pickle.load(handle)
        with open("save/indeks_aktualnego_gracza.pickle", "rb") as handle:
            self._indeks_aktualnego_gracza = pickle.load(handle)
        with open("save/messages.pickle", "rb") as handle:
            self.messages = pickle.load(handle)
        with open("save/plansza.pickle", "rb") as handle:
            self._plansza = pickle.load(handle)
        with open("save/gracz_poprzedniej_tury.pickle", "rb") as handle:
            self.gracz_poprzedniej_tury = pickle.load(handle)
        with open("save/zwyciezca.pickle", "rb") as handle:
            self.zwyciezca = pickle.load(handle)
        with open("save/waiter.pickle", "rb") as handle:
            self.waiter = pickle.load(handle)
        with open("save/czas_gry.pickle", "rb") as handle:
            self.main.uplyniety_czas_gry = pickle.load(handle)
        with open("save/limit_gra.pickle", "rb") as handle:
            self.main.LIMIT_CZASU_GRY = pickle.load(handle)
        with open("save/limit_tura.pickle", "rb") as handle:
            self.main.LIMIT_CZASU_TURY = pickle.load(handle)

    def kto_zbankrutowal(self):
        for gracz in self._gracze:
            if gracz.kwota > 0:
                continue
            else:
                if (
                    len(gracz.lista_posiadlosci) == 0
                    or len(gracz.lista_posiadlosci) == gracz.liczba_zastawionych
                ) and gracz.czy_aktywny == True:
                    gracz.czy_aktywny = False
                    self._kontroler_wiadomosci.dodaj_wiadomosc(
                        f"Gracz {gracz.id} bankrutuje"
                    )

    def czy_zwyciezca(self):
        licznik = 0
        licznik_indeksu = 0
        zwyciezca = -1
        for gracz in self._gracze:
            if gracz.czy_aktywny:
                licznik += 1
                zwyciezca = licznik_indeksu
            licznik_indeksu += 1

        if licznik == 1:
            self.zwyciezca = zwyciezca
            return True
        else:
            return False

    def wyswietl_zwyciezce(self):

        self.skalar_czcionki = 15  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.czcionka, int(self.aktualna_szerokosc_ekranu / self.skalar_czcionki)
        )
        zwyciezca_tekst = self.font.render(
            f"Zwycięstwo", True, self.wizualizator.kolor_zlotego_napisu
        )

        self.font = pygame.font.Font(
            self.czcionka,
            int(self.aktualna_szerokosc_ekranu / (self.skalar_czcionki + 5)),
        )
        nazwa_gracza = self.font.render(
            self._gracze[self.zwyciezca].id, True, self.kolor_czcionki
        )

        grafika_zwyciezcy = pygame.transform.scale(
            pygame.image.load(self._gracze[self.zwyciezca].pionek.sciezka_do_grafiki),
            (
                0.15 * self.aktualna_szerokosc_ekranu,
                0.15 * self.aktualna_szerokosc_ekranu,
            ),
        )

        self._glowne_okno.fill(self.wizualizator.kolor_tla)
        self._glowne_okno.blit(
            zwyciezca_tekst,
            (
                self.aktualna_szerokosc_ekranu * 0.25,
                self.aktualna_wysokosc_ekranu * 0.3,
            ),
        )
        self._glowne_okno.blit(
            grafika_zwyciezcy,
            (
                self.aktualna_szerokosc_ekranu * 0.55,
                self.aktualna_wysokosc_ekranu * 0.2,
            ),
        )
        self._glowne_okno.blit(
            nazwa_gracza,
            (
                self.aktualna_szerokosc_ekranu * 0.35,
                self.aktualna_wysokosc_ekranu * 0.5,
            ),
        )

    def aktualizuj(self, czas):
        if self.zwyciezca != -1:
            self.waiter -= czas


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Gracz.py
from src.Statystyka import Statystyka

UMIEJETNOSC_ZMIEJSZENIA_CZYNSZU_O = 20

class Gracz:
    def __init__(self, id, kwota, pionek, umiejetnosc):
        self.id = id
        self.kwota = kwota
        self.pionek = pionek
        self.pozycja = 0
        self.tury_w_wiezieniu = 0  # Licznik tur w więzieniu
        self.liczba_kart_wyjdz_z_wiezienia = 0
        self.lista_posiadlosci = []
        self.liczba_zastawionych = 0
        self.statystyka = Statystyka(kwota, self.id)
        self.umiejetnosc = umiejetnosc
        self.czy_aktywny = True
        print(umiejetnosc)

        if umiejetnosc == "wiecej_pieniedzy_na_start":
            self.kwota += 2000
            self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)

        if umiejetnosc == "karta_wyjscia_z_wiezienia":
            self.liczba_kart_wyjdz_z_wiezienia += 1

        

    def zastaw_posiadlosci(self, gra, nr_posiadlosci):      
        
        self.lista_posiadlosci[nr_posiadlosci].czy_zastawiona = True
        self.liczba_zastawionych += 1
        self.kwota += self.lista_posiadlosci[nr_posiadlosci].zastaw_kwota
        gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Zastawiłeś posiadłość {self.lista_posiadlosci[nr_posiadlosci].nazwa}"
        )
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)
        gra.kto_zbankrutowal()

    def zdejmij_zastaw_posiadlosci(self, gra):
        if self.liczba_zastawionych == 0:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz zastawionych posiadlosci"
            )
            gra.akcja_zastaw_okno.czy_zdejmij_zastaw = False
            return

        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            "To wszystkie Twoje posiadłości, które masz zastawione:"
        )
        for posiadlosc in self.lista_posiadlosci:
            if posiadlosc.czy_zastawiona:
                # posiadlosc.wyswietl_info(gra)
                gra._kontroler_wiadomosci.dodaj_wiadomosc(
                    f"({posiadlosc.nazwa}")

        # wczytanie numeru, sprawdzenie czy numer jest dobry
        x = 0
        cena = self.lista_posiadlosci[x].zastaw_kwota * 1.2
        if self.kwota >= cena:
            self.lista_posiadlosci[x].czy_zastawiona = False
            self.liczba_zastawionych -= 1
            self.kwota -= cena
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz wystarczająco dużo pieniędzy, aby zdjąć zastaw z posiadłości"
            )
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)
        gra.kto_zbankrutowal()

    def zaplac_czynsz(self, gra, posiadlosc):
        if self.umiejetnosc == "placi_mniejsze_czynsze":
            czynsz = (posiadlosc.oblicz_czynsz(gra) - UMIEJETNOSC_ZMIEJSZENIA_CZYNSZU_O)
        else:
            czynsz = posiadlosc.oblicz_czynsz(gra)
        self.wykonaj_oplate(gra, czynsz)
        posiadlosc.wlasciciel.dodaj_pieniadze(gra, czynsz)
        gra.kto_zbankrutowal()

    def ile_w_kolorze(self, kolor):
        liczba_w_kolorze = 0
        for posiadlosc in self.lista_posiadlosci:
            if posiadlosc.kolor == kolor:
                liczba_w_kolorze += 1
        return liczba_w_kolorze

    def caly_kolor(self, kolor):
        if kolor == "brazowy" or kolor == "granatowy" or kolor == "pozaWmii":
            return self.ile_w_kolorze(kolor) == 2
        else:
            return self.ile_w_kolorze(kolor) == 3

    def czy_cztery_domki(self, posiadlosc):
        if posiadlosc.liczba_domow < 4:
            return "domek"

        liczba_domkow_w_kolorze = 0
        for pole in self.lista_posiadlosci:
            if not pole.kolor == pole.kolor:
                liczba_domkow_w_kolorze += pole.liczba_domow

        if posiadlosc.kolor == "brazowy" or posiadlosc.kolor == "granatowy":
            if liczba_domkow_w_kolorze < 8:
                return "nie"
            return "hotel"
        else:
            if liczba_domkow_w_kolorze < 12:
                return "nie"
            return "hotel"

    def wykonaj_oplate(self, gra, cena):
        if cena > self.kwota:
            gra.akcja_zastaw_okno.czy_zastaw = True
            gra.czy_akcja_zakonczona = False
            gra.akcja_zastaw_okno.ustaw_gracza(self, cena)
        else:
            self.kwota -= cena
            self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)
            gra.kto_zbankrutowal()
            return 1
        gra.kto_zbankrutowal()
        return 0

    def dodaj_pieniadze(self, gra, cena):
        self.kwota += cena
        gra._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Gracz {self.id} otrzymał {cena} pieniędzy"
        )
        self.statystyka.aktualizuj_stan_pieniedzy(self.kwota)

    def czy_przeszedl_przez_start(self, gra, stara_pozycja):
        if self.pionek.numer_pola < stara_pozycja and self.tury_w_wiezieniu == 0:
            if self.umiejetnosc == "dostaje_wiecej_za_przejscie_przez_start":
                self.dodaj_pieniadze(gra, 2200)
            else:
                self.dodaj_pieniadze(gra, 2000)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\KartaSzansy.py
import random


class KartaSzansy:
    def __init__(self, typ, tresc, wartosc=0):
        self.typ = typ
        self.tresc = tresc
        self.wartosc = wartosc

    def wyswietl_tresc(self, gra):
        gra._kontroler_wiadomosci.dodaj_wiadomosc(self.tresc)

    def wykonaj_akcje(self, gra, gracz):
        if self.typ == "pobierz":
            gracz.dodaj_pieniadze(gra, self.wartosc)

        elif self.typ == "pobierz_od_graczy":
            for g in gra._gracze:
                if g.id != gracz.id:
                    g.wykonaj_oplate(gra, self.wartosc)
                    gracz.dodaj_pieniadze(gra, self.wartosc)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} otrzymuje {self.wartosc} zł od każdego gracza"
            )

        elif self.typ == "oplata":
            gracz.wykonaj_oplate(gra, self.wartosc)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} zapłacił {self.wartosc}"
            )

        elif self.typ == "oplata_za_domki":
            liczba_domkow = 0
            liczba_hoteli = 0
            for pole in gracz.lista_posiadlosci:
                liczba_domkow += pole.liczba_domow
                liczba_hoteli += pole.liczba_hoteli
            cena = liczba_domkow * self.wartosc
            cena += liczba_hoteli * self.wartosc * 3
            gracz.wykonaj_oplate(gra, cena)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} zapłacił {self.cena} za wszystkie domki i hotele"
            )

        elif self.typ == "przejdz_na_pole":
            stara_pozycja = gracz.pionek.numer_pola
            gra.przesun_gracza_bez_raportu(gracz, self.wartosc)
            gracz.czy_przeszedl_przez_start(gra, stara_pozycja)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} został przesunięty na inne pole"
            )

        # brak poboru oplaty za przejscie przez start
        elif self.typ == "cofnij_na_pole":
            gra.przesun_gracza_bez_raportu(gracz, self.wartosc)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} został cofnięty na inne pole"
            )

        elif self.typ == "cofnij_do_wiezienia":
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Nie masz mozliwości wykupić się rzutami lub kartą"
            )
            gracz.tury_w_wiezieniu = 2
            gra._kolejny_rzut_kostka = False
            gra.akcja_wiezienie_okno.czy_wiezienie = True
            gra.przesun_gracza_bez_raportu(gracz, 10)

        elif self.typ == "karta_wyjscie_z_wiezienia":
            gracz.liczba_kart_wyjdz_z_wiezienia += 1
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gracz {gracz.id} otrzymał kartę wyjście z więzienia"
            )


class Karty:
    def __init__(self):
        self.karty = self.wczytaj_karty("data/karty.txt")
        random.shuffle(self.karty)
        self.current_index = 0
        self.aktualna_karta = self.karty[self.current_index]

    def wczytaj_karty(self, plik: str) -> list[KartaSzansy]:
        karty = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 2 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda karta powinna mieć 3 linie danych."
                    )
                typ = lines[i].strip()
                tresc = lines[i + 1].strip()
                wartosc = int(lines[i + 2].strip())
                karta = KartaSzansy(typ, tresc, wartosc)
                karty.append(karta)
                i += 4
        return karty

    def nastepna_karta(self):
        karta = self.karty[self.current_index]
        self.aktualna_karta = karta
        self.current_index = (self.current_index + 1) % len(self.karty)
        return karta


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\KontrolerWiadomosci.py
import pygame
from src.Wizualizator import Wizualizator


class KontrolerWiadomosci:
    MAKSYMALNA_ILOSC_WIADOMOSCI = 8

    def __init__(self, font, wizualizator):
        self.wiadomosci: list[str] = list()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0
        # self.font: pygame.font.Font = font
        self.wizualizator = wizualizator
        self.W = 1200
        self.H = 800
        self.skalar_czcionki = 60 # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / self.skalar_czcionki))
        self.koordynaty_ostatniej_wiadomosci = 0

    def _render_text(self, text: str, pos, okno: pygame.Surface, ostatnia_wiadomosc):

        if ostatnia_wiadomosc:
            self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki - 15)))
            text_surface = self.font.render(text, True, self.wizualizator.kolor_ostatniej_wiadomosci)
        else:
            self.font = pygame.font.Font(self.wizualizator.czcionka, int(self.W / self.skalar_czcionki))
            text_surface = self.font.render(text, True, self.wizualizator.kolor_wiadomosci)
        okno.blit(text_surface, pos)

    def dodaj_wiadomosc(self, tresc: str):

        if self.ilosc_wiadomosci < KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI:
            self.ilosc_wiadomosci += 1
            self.wiadomosci.append(tresc)
        else:
            self.wiadomosci[self.ostatnia_pozycyjnie_wiadomosc_index] = tresc
            self.ostatnia_pozycyjnie_wiadomosc_index = (
                self.ostatnia_pozycyjnie_wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI

    def usun_wszystkie_wiadomosci(self):
        self.wiadomosci.clear()
        self.ilosc_wiadomosci = 0
        self.ostatnia_pozycyjnie_wiadomosc_index = 0

    def wyswietl(self, okno: pygame.Surface, W, H):

        self.H = H
        self.W = W

        y_offset = 0.06

        wiadomosc_index = self.ostatnia_pozycyjnie_wiadomosc_index
        wiadomosc_index_end = (
            (self.ostatnia_pozycyjnie_wiadomosc_index - 1)
            % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            if self.ilosc_wiadomosci == KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            else self.ilosc_wiadomosci - 1
        )

        wiadomosc_number = 0
        i = 0
        ostatnia_wiadomosc = False
        while wiadomosc_number < self.ilosc_wiadomosci:
            if wiadomosc_number == self.ilosc_wiadomosci - 1:
                ostatnia_wiadomosc = True

            # while wiadomosc_index != wiadomosc_index_end:
            wiadomosc = self.wiadomosci[wiadomosc_index]

            if isinstance(wiadomosc, str | bytes):
                self._render_text(wiadomosc, (W * 0.595, H * (0.48 + (i * y_offset))), okno, ostatnia_wiadomosc)
                if ostatnia_wiadomosc:
                    self.koordynaty_ostatniej_wiadomosci = (H * (0.467 + (i * y_offset)))

            wiadomosc_index = (
                wiadomosc_index + 1
            ) % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI
            wiadomosc_number += 1
            i += 1

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Menu.py
import shutil
import pygame
from src.PrzyciskiMenu import PrzyciskiMenu
from src.Wizualizator import Wizualizator


class Menu:
    def __init__(self, wizualizator, main_ref):
        self.stan = "witaj"
        self.typ_stopu = "nowa"
        self.liczba_graczy = 0
        self.gracze = []
        self.wizualizator: Wizualizator = wizualizator
        self.font = pygame.font.Font(self.wizualizator.czcionka, 32)
        self.H = 660
        self.W = 1200

        self.main = main_ref

        self.przyciski = PrzyciskiMenu(self.H, self.W, self.wizualizator)

        self.logo = pygame.transform.scale(
            pygame.image.load("graphics/logo.png"), (0.5 * self.W, 0.5 * self.H)
        )

        self.strona1 = pygame.transform.scale(
            pygame.image.load("graphics/tutorial/strona1.png"),
            (0.5 * self.W, 0.5 * self.H),
        )
        self.strona2 = pygame.transform.scale(
            pygame.image.load("graphics/tutorial/strona2.png"),
            (0.5 * self.W, 0.5 * self.H),
        )
        self.pionek1_path = "graphics/pionek/PionekColor1.png"
        self.pionek2_path = "graphics/pionek/PionekColor2.png"
        self.pionek3_path = "graphics/pionek/PionekColor3.png"
        self.pionek4_path = "graphics/pionek/PionekColor4.png"
        self.pionek5_path = "graphics/pionek/PionekColor5.png"

        self.pionek1 = pygame.transform.scale(
            pygame.image.load(self.pionek1_path),
            (0.2 * self.W, 0.2 * self.H),
        )

        self.pionek2 = pygame.transform.scale(
            pygame.image.load(self.pionek2_path),
            (0.2 * self.W, 0.2 * self.H),
        )

        self.pionek3 = pygame.transform.scale(
            pygame.image.load(self.pionek3_path),
            (0.2 * self.W, 0.2 * self.H),
        )

        self.pionek4 = pygame.transform.scale(
            pygame.image.load(self.pionek4_path),
            (0.2 * self.W, 0.2 * self.H),
        )

        self.pionek5 = pygame.transform.scale(
            pygame.image.load(self.pionek5_path),
            (0.2 * self.W, 0.2 * self.H),
        )

        self.skalar_czcionki = 22  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / self.skalar_czcionki)
        )
        self.font_gracze = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 5))
        )
        self.font_wpisywanie = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 5))
        )

        self.typ_karty = ""
        self.tresc_karty = ""
        self.wartosc_karty = ""

    def handle_event(self, event, W, H):

        self.W = W
        self.H = H
        self.przyciski.aktualizuj_rozmiar(self.W, self.H)

        if event.type == pygame.QUIT:
            pygame.quit()

        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.stan == "witaj":
                if self.przyciski.nowa_gra.is_clicked(event):
                    self.stan = "czas_gry"
                    # self.reset_pionki()
                elif self.przyciski.wyjscie.is_clicked(event):
                    pygame.quit()
                elif self.przyciski.wczytaj_gre.is_clicked(event):
                    self.stan = "stop"
                    self.typ_stopu = "wczytana"

            elif self.stan == "czas_gry":
                if self.przyciski.trzydziesci_minut.is_clicked(event):
                    self.main.LIMIT_CZASU_GRY = 1800
                elif self.przyciski.szescdziesiat_minut.is_clicked(event):
                    self.main.LIMIT_CZASU_GRY = 3600
                elif self.przyciski.dziewiecdziesiat_minut.is_clicked(event):
                    self.main.LIMIT_CZASU_GRY = 5400
                elif self.przyciski.bez_ograniczen.is_clicked(event):
                    self.main.LIMIT_CZASU_GRY = 9999

                if self.main.LIMIT_CZASU_GRY != 0:
                    self.stan = "czas_tury"

            elif self.stan == "czas_tury":
                if self.przyciski.jedna_minuta.is_clicked(event):
                    self.main.LIMIT_CZASU_TURY = 60
                elif self.przyciski.dwie_minuty.is_clicked(event):
                    self.main.LIMIT_CZASU_TURY = 120
                elif self.przyciski.trzy_minuty.is_clicked(event):
                    self.main.LIMIT_CZASU_TURY = 180
                elif self.przyciski.bez_ograniczen.is_clicked(event):
                    self.main.LIMIT_CZASU_TURY = 999

                if self.main.LIMIT_CZASU_TURY != 0:
                    self.stan = "liczba_graczy"

            elif self.stan == "liczba_graczy":
                if self.przyciski.two.is_clicked(event):
                    self.liczba_graczy = 2
                elif self.przyciski.three.is_clicked(event):
                    self.liczba_graczy = 3
                elif self.przyciski.four.is_clicked(event):
                    self.liczba_graczy = 4
                elif self.przyciski.five.is_clicked(event):
                    self.liczba_graczy = 5

                if self.liczba_graczy > 1:
                    self.stan = "nazwy_graczy"
                    self.gracze.append("")

            elif self.stan == "wybor_pionkow":
                if self.przyciski.graj.is_clicked(event):
                    self.stan = "stop"
                elif self.przyciski.personalizacja.is_clicked(event):
                    self.stan = "personalizacja"
                elif self.przyciski.nastepny.is_clicked(event):
                    self.stan = "gracz_1"

            elif self.stan == "gracz_1":
                if self.przyciski.nastepny.is_clicked(event):
                    self.stan = "gracz_2"

            elif self.stan == "gracz_2":
                if self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "gracz_1"
                elif (
                    self.przyciski.nastepny.is_clicked(event) and self.liczba_graczy > 2
                ):
                    self.stan = "gracz_3"
                elif (
                    self.przyciski.nastepny.is_clicked(event)
                    and self.liczba_graczy == 2
                ):
                    self.stan = "tutorial1"

            elif self.stan == "gracz_3":
                if self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "gracz_2"
                elif (
                    self.przyciski.nastepny.is_clicked(event) and self.liczba_graczy > 3
                ):
                    self.stan = "gracz_4"
                elif (
                    self.przyciski.nastepny.is_clicked(event)
                    and self.liczba_graczy == 3
                ):
                    self.stan = "tutorial1"

            elif self.stan == "gracz_4":
                if self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "gracz_3"
                elif (
                    self.przyciski.nastepny.is_clicked(event) and self.liczba_graczy > 4
                ):
                    self.stan = "gracz_5"
                elif (
                    self.przyciski.nastepny.is_clicked(event)
                    and self.liczba_graczy == 4
                ):
                    self.stan = "tutorial1"

            elif self.stan == "gracz_5":
                if self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "gracz_4"
                elif self.przyciski.nastepny.is_clicked(event):
                    self.stan = "tutorial1"

            elif self.stan == "tutorial1":
                if self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "gracz_" + str(self.liczba_graczy)
                elif self.przyciski.graj.is_clicked(event):
                    self.stan = "stop"
                elif self.przyciski.personalizacja.is_clicked(event):
                    self.stan = "personalizacja"
                elif self.przyciski.nastepny.is_clicked(event):
                    self.stan = "tutorial2"
            elif self.stan == "tutorial2":
                if self.przyciski.graj.is_clicked(event):
                    self.stan = "stop"
                elif self.przyciski.personalizacja.is_clicked(event):
                    self.stan = "personalizacja"
                elif self.przyciski.poprzedni.is_clicked(event):
                    self.stan = "tutorial1"

            elif self.stan == "personalizacja":
                if self.przyciski.pobierz.is_clicked(event):
                    self.typ_karty = "pobierz"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.pobierz_od_graczy.is_clicked(event):
                    self.typ_karty = "pobierz_od_graczy"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.oplata.is_clicked(event):
                    self.typ_karty = "oplata"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.oplata_za_domki.is_clicked(event):
                    self.typ_karty = "oplata_za_domki"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.przejdz_na_pole.is_clicked(event):
                    self.typ_karty = "przejdz_na_pole"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.cofnij_do_wiezienia.is_clicked(event):
                    self.typ_karty = "cofnij_do_wiezienia"
                    self.stan = "wczytaj_tresc_karty"
                elif self.przyciski.powrot.is_clicked(event):
                    self.typ_karty = ""
                    self.tresc_karty = ""
                    self.wartosc_karty = ""
                    self.stan = "tutorial2"

            elif self.stan == "zaakceptuj":
                if self.przyciski.zaakceptuj.is_clicked(event):
                    self.zapisz_karte_do_pliku()
                    self.stan = "tutorial2"
                if self.przyciski.powrot.is_clicked(event):
                    self.typ_karty = ""
                    self.tresc_karty = ""
                    self.wartosc_karty = ""
                    self.stan = "tutorial2"

            elif self.stan == "wczytaj_tresc_karty":
                if self.przyciski.powrot.is_clicked(event):
                    self.typ_karty = ""
                    self.tresc_karty = ""
                    self.wartosc_karty = ""
                    self.stan = "tutorial2"
            elif self.stan == "wczytaj_wartosc_karty":
                if self.przyciski.powrot.is_clicked(event):
                    self.typ_karty = ""
                    self.tresc_karty = ""
                    self.wartosc_karty = ""
                    self.stan = "tutorial2"

        elif event.type == pygame.KEYDOWN:

            if event.key == pygame.K_ESCAPE:
                pygame.quit()

            if self.stan == "nazwy_graczy":
                if event.key == pygame.K_RETURN:
                    if len(self.gracze) < self.liczba_graczy:
                        self.gracze.append("")
                    else:
                        self.stan = "wybor_pionkow"
                elif event.key == pygame.K_BACKSPACE:
                    self.gracze[-1] = self.gracze[-1][:-1]
                else:
                    if event.key == pygame.K_SPACE:
                        if len(self.gracze[-1]) != 0 and self.gracze[-1][-1] != " ":
                            self.gracze[-1] += event.unicode
                    else:
                        self.gracze[-1] += event.unicode
            elif self.stan == "wczytaj_tresc_karty":
                if event.key == pygame.K_RETURN:
                    self.stan = "wczytaj_wartosc_karty"
                elif event.key == pygame.K_BACKSPACE:
                    self.tresc_karty = self.tresc_karty[:-1]
                else:
                    if event.key == pygame.K_SPACE:
                        if len(self.tresc_karty) != 0 and self.tresc_karty[-1] != " ":
                            self.tresc_karty += event.unicode
                    else:
                        self.tresc_karty += event.unicode
            elif self.stan == "wczytaj_wartosc_karty":
                if event.key == pygame.K_RETURN:
                    if self.wartosc_karty == "":
                        self.stan = "blad"
                    else:
                        self.stan = "zaakceptuj"
                elif event.key == pygame.K_BACKSPACE:
                    if len(self.wartosc_karty) > 0:
                        self.wartosc_karty = self.wartosc_karty[:-1]
                elif event.unicode.isdigit():
                    self.wartosc_karty += event.unicode

            elif self.stan == "blad":
                self.stan = "wczytaj_wartosc_karty"
                self.typ_karty = ""
                self.tresc_karty = ""
                self.wartosc_karty = ""

        elif event.type == pygame.DROPFILE:
            self.handle_drop_file(event.file)

    def handle_drop_file(self, file_path):
        if file_path.endswith(".png"):
            try:
                new_image = pygame.image.load(file_path)
                new_image = pygame.transform.scale(
                    new_image, (0.2 * self.W, 0.2 * self.H)
                )
                self.update_pionek(file_path, new_image)
            except pygame.error as e:
                print(f"Cannot load image: {file_path}, {e}")

    def update_pionek(self, file_path, new_image):
        if self.stan == "gracz_1":
            shutil.copy(file_path, self.pionek1_path)
            self.pionek1 = new_image
        elif self.stan == "gracz_2":
            shutil.copy(file_path, self.pionek2_path)
            self.pionek2 = new_image
        elif self.stan == "gracz_3":
            shutil.copy(file_path, self.pionek3_path)
            self.pionek3 = new_image
        elif self.stan == "gracz_4":
            shutil.copy(file_path, self.pionek4_path)
            self.pionek4 = new_image
        elif self.stan == "gracz_5":
            shutil.copy(file_path, self.pionek5_path)
            self.pionek5 = new_image

    def draw(self, screen, W, H):
        self.font = pygame.font.Font(
            self.wizualizator.czcionka, int(W / self.skalar_czcionki)
        )
        self.font_gracze = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 5))
        )
        self.font_wpisywanie = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / (self.skalar_czcionki + 15))
        )

        if self.stan == "witaj":
            self.logo = pygame.transform.scale(self.logo, (0.5 * W, 0.45 * H))
            screen.blit(self.logo, (W * 0.25, H * 0.05))

            self.przyciski.nowa_gra.draw(screen)
            self.przyciski.wczytaj_gre.draw(screen)
            self.przyciski.wyjscie.draw(screen)

        elif self.stan == "tutorial1":
            screen.fill(self.wizualizator.kolor_tla)
            self.przyciski.graj.draw(screen)
            self.przyciski.personalizacja.draw(screen)
            self.przyciski.poprzedni_szary.draw(screen)
            self.przyciski.nastepny.draw(screen)
            self.strona1_temp = pygame.transform.scale(self.strona1, (0.6 * W, 0.7 * H))
            screen.blit(self.strona1_temp, (W * 0.20, H * 0.05))
        elif self.stan == "tutorial2":
            screen.fill(self.wizualizator.kolor_tla)
            self.przyciski.graj.draw(screen)
            self.przyciski.personalizacja.draw(screen)
            self.przyciski.poprzedni.draw(screen)
            self.przyciski.nastepny_szary.draw(screen)
            self.strona2_temp = pygame.transform.scale(self.strona2, (0.6 * W, 0.7 * H))
            screen.blit(self.strona2_temp, (W * 0.20, H * 0.05))

        elif self.stan == "zaakceptuj":
            screen.fill(self.wizualizator.kolor_tla)
            self.przyciski.zaakceptuj.draw(screen)
            self.przyciski.powrot.draw(screen)

        elif self.stan == "czas_gry":
            self.przyciski.trzydziesci_minut.draw(screen)
            self.przyciski.szescdziesiat_minut.draw(screen)
            self.przyciski.dziewiecdziesiat_minut.draw(screen)
            self.przyciski.bez_ograniczen.draw(screen)

            text = self.font.render(
                "Wybierz czas gry w minutach", True, self.wizualizator.kolor_czcionki
            )

            screen.blit(text, (W * 0.255, H * 0.3))

        elif self.stan == "czas_tury":
            self.przyciski.jedna_minuta.draw(screen)
            self.przyciski.dwie_minuty.draw(screen)
            self.przyciski.trzy_minuty.draw(screen)
            self.przyciski.bez_ograniczen.draw(screen)

            text = self.font.render(
                "Wybierz czas tury w sekundach", True, self.wizualizator.kolor_czcionki
            )

            screen.blit(text, (W * 0.255, H * 0.3))

        elif self.stan == "liczba_graczy":
            self.przyciski.two.draw(screen)
            self.przyciski.three.draw(screen)
            self.przyciski.four.draw(screen)
            self.przyciski.five.draw(screen)

            text = self.font.render(
                "Wybierz liczbę graczy",
                True,
                self.wizualizator.kolor_czcionki,
            )

            screen.blit(text, (W * 0.305, H * 0.3))

        elif self.stan == "nazwy_graczy":
            text = self.font.render(
                "Wprowadź nazwę gracza: " + str(len(self.gracze)),
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (W * 0.28, H * 0.25))

            odstep = 0.05
            ile_wpisanych = len(self.gracze)

            for i in range(0, len(self.gracze)):

                if i < ile_wpisanych - 1:
                    kolor_czcionki = self.wizualizator.kolor_akceptacji_nazwy_gracza
                else:
                    kolor_czcionki = self.wizualizator.kolor_czcionki

                gracz = self.font_gracze.render(
                    str(self.gracze[i]), True, kolor_czcionki
                )
                screen.blit(gracz, (W * 0.45, H * (0.45 + (i * odstep))))

        elif self.stan == "wybor_pionkow":
            self.przyciski.poprzedni_szary.draw(screen)
            self.przyciski.graj.draw(screen)
            self.przyciski.personalizacja.draw(screen)
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                "Przegląd pionków i możliwość personalizacji",
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (W * 0.17, H * 0.13))

            # Wyświetlanie pionków w linii z odpowiednim odstępem
            pionki = [
                self.pionek1,
                self.pionek2,
                self.pionek3,
                self.pionek4,
                self.pionek5,
            ]
            for i, pionek in enumerate(pionki):
                pionek_wyswietlany = pygame.transform.scale(
                    pionek, (0.12 * self.W, 0.12 * self.W)
                )
                screen.blit(pionek_wyswietlany, (W * (0.2 + 0.12 * i), H * 0.4))

        elif self.stan == "gracz_1":
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                f"Gracz: {self.gracze[0]}", True, self.wizualizator.kolor_czcionki
            )
            self.wyswietl_napis_pionek(screen, self.pionek1, text)

        elif self.stan == "gracz_2":
            self.przyciski.poprzedni.draw(screen)
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                f"Gracz: {self.gracze[1]}", True, self.wizualizator.kolor_czcionki
            )
            self.wyswietl_napis_pionek(screen, self.pionek2, text)

        elif self.stan == "gracz_3":
            self.przyciski.poprzedni.draw(screen)
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                "Gracz: " + str(self.gracze[2]),
                True,
                self.wizualizator.kolor_czcionki,
            )
            self.wyswietl_napis_pionek(screen, self.pionek3, text)

        elif self.stan == "gracz_4":
            self.przyciski.poprzedni.draw(screen)
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                "Gracz: " + str(self.gracze[3]),
                True,
                self.wizualizator.kolor_czcionki,
            )
            self.wyswietl_napis_pionek(screen, self.pionek4, text)

        elif self.stan == "gracz_5":
            self.przyciski.poprzedni.draw(screen)
            self.przyciski.nastepny.draw(screen)

            text = self.font.render(
                "Gracz: " + str(self.gracze[4]),
                True,
                self.wizualizator.kolor_czcionki,
            )
            self.wyswietl_napis_pionek(screen, self.pionek5, text)

        elif self.stan == "personalizacja":
            screen.fill(self.wizualizator.kolor_tla)
            self.przyciski.pobierz.draw(screen)
            self.przyciski.pobierz_od_graczy.draw(screen)
            self.przyciski.oplata.draw(screen)
            self.przyciski.oplata_za_domki.draw(screen)
            self.przyciski.przejdz_na_pole.draw(screen)
            self.przyciski.cofnij_do_wiezienia.draw(screen)
            self.przyciski.powrot.draw(screen)

            text = self.font.render(
                "Wybierz typ Karty Szansy którą chcesz dodać",
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.15, self.H * 0.15))

        elif self.stan == "wczytaj_tresc_karty":
            self.przyciski.powrot.draw(screen)
            text = self.font.render(
                f"Wpisz treść karty",
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.37, self.H * 0.1))
            text = self.font_wpisywanie.render(
                str(self.tresc_karty),
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.1, self.H * (0.5)))

        elif self.stan == "wczytaj_wartosc_karty":
            self.przyciski.powrot.draw(screen)
            text = self.font.render(
                f"Wpisz wartość karty",
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.35, self.H * 0.1))
            text = self.font.render(
                str(self.wartosc_karty),
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.47, self.H * (0.5)))

        elif self.stan == "blad":
            text = self.font.render(
                f"Wpisano złą wartość karty. Musisz wprowadzić liczbę naturalną",
                True,
                self.wizualizator.kolor_czcionki,
            )
            screen.blit(text, (self.W * 0.1, self.H * 0.1))

    def zapisz_karte_do_pliku(self):
        with open("data/karty.txt", "a", encoding="utf-8") as plik:
            # Zapisz dane karty
            plik.write(
                f"\n{self.typ_karty}\n{self.tresc_karty}\n{self.wartosc_karty}\n"
            )
        self.typ_karty = ""
        self.tresc_karty = ""
        self.wartosc_karty = ""

    def wyswietl_napis_pionek(self, screen, pionek, tekst):
        screen.blit(tekst, (self.W * 0.1, self.H * 0.12))
        pionek_wyswietlany = pygame.transform.scale(
            pionek, (0.12 * self.W, 0.12 * self.W)
        )
        screen.blit(pionek_wyswietlany, (self.W * 0.44, self.H * 0.35))


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Pionek.py
import pygame
from enum import Enum
from typing import NamedTuple


class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pionek:
    MIN_LICZBA_OCZEK = 2
    MAX_LICZBA_OCZEK = 12
    DLUGOSC_SCIANKI_W_POLACH = 10
    LICZBA_POL = 40

    MALE_POLE_WYMIARY: Vector2 = Vector2(44, 70)
    # warning: najlepiej, gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(70, 70)
    OFF_SET: Vector2 = Vector2(12, 12)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    def __init__(self, numer_pola: int, color: pygame.color, grafika: str, W, H, il):
        self.numer_pola = numer_pola
        self.color = color
        self.sciezka_do_grafiki = grafika
        self.szerokosc_ratio = 1
        self.wysokosc_ratio = 1
        self.W = W 
        self.H = H
        self.kierunek: KierunekPol = KierunekPol.Gora
        self.wymiary: Vector2 = Vector2(20, 20)
        self.pozycja: Vector2 = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)
        
        self.aktualizacja_rozmiaru(W, H)
        self.ilosc_graczy_na_polu = il

        
    def oblicz_nowa_pozycje(self, numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pionek.OFF_SET.x
        gora = Pionek.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += ((Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING) if numer_pola % 10 != 0 else 0)
                lewo += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING))

            case KierunekPol.Prawo:
                lewo += 9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING
                gora += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING))
                gora += ((Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING) if numer_pola % 10 != 0 else 0)

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING)
                lewo += (Pionek.DUZE_POLE_WYMIARY.x + Pionek.SPACING)       # Czemu dziala nie mam bladego pojecia
                gora += 9 * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING

            case KierunekPol.Lewo:
                gora += (9 - (numer_pola % 10)) * (Pionek.MALE_POLE_WYMIARY.x + Pionek.SPACING) + Pionek.DUZE_POLE_WYMIARY.y + Pionek.SPACING

        return Vector2(lewo * self.szerokosc_ratio, gora * self.wysokosc_ratio)

    def przesun(self, liczba_pol: int, gra) -> bool:
        if liczba_pol <= 0:
            return False
        gra._plansza.plansza[self.numer_pola].ilosc_graczy_na_polu -= 1
        self.numer_pola = (self.numer_pola + liczba_pol) % Pionek.LICZBA_POL
        gra._plansza.plansza[self.numer_pola].ilosc_graczy_na_polu += 1
        self.kierunek = KierunekPol(self.numer_pola // Pionek.DLUGOSC_SCIANKI_W_POLACH)
        self.pozycja = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)

        return True


    def aktualizacja_rozmiaru(self, szerokosc, wysokosc):
        szerokosc_ekranu = 1200
        wysokosc_ekranu = 660
        self.W = szerokosc
        self.H = wysokosc

        self.szerokosc_ratio = szerokosc / szerokosc_ekranu
        self.wysokosc_ratio = wysokosc / wysokosc_ekranu
        self.pozycja = self.oblicz_nowa_pozycje(self.numer_pola, self.kierunek)


    def wyswietl(self, okno: pygame.Surface, gra):
        skalar = 35
        
        zdjecie_pionek = pygame.transform.scale(
            pygame.image.load(self.sciezka_do_grafiki), (self.W / skalar, self.W / skalar)
        )
        self.ilosc_graczy_na_polu = gra._plansza.plansza[self.numer_pola].ilosc_graczy_na_polu
        if self.ilosc_graczy_na_polu > 1:
            maska = pygame.transform.scale(
                pygame.image.load(f"graphics/pionek/pionek{self.ilosc_graczy_na_polu}mask.png"), (self.W / skalar, self.W / skalar)
            )
        # zdjecie_pionek_transformed = pygame.transform.scale(self.zdjecie_pionek, (self.wymiary.x * self.szerokosc_ratio, self.wymiary.y * self.wysokosc_ratio))
        okno.blit(zdjecie_pionek, (self.pozycja.x, self.pozycja.y))
        if self.ilosc_graczy_na_polu > 1:
            okno.blit(maska, (self.pozycja.x, self.pozycja.y))


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Plansza.py
import pygame.color

from src.Pole import Pole
from src.Pionek import Pionek
from src.Posiadlosc import Posiadlosc
from src.KartaSzansy import *
from src.PodatekDochodowy import Zagadki
from src.PodatekDochodowy import PodatekDochodowy


class Plansza:
    @staticmethod
    def inicializacja_planszy() -> list[Pole]:
        board: list[Pole] = list()
        board.append(Pole(0, "Start"))
        board.append(Posiadlosc(1, "Automat z kawą", "brazowy", 600, 20, 300, 500))
        board.append(Pole(2, "Szansa"))
        board.append(Posiadlosc(3, 'Bistro "Świetlica"', "brazowy", 600, 40, 300, 500))
        board.append(PodatekDochodowy(4, 1000))
        board.append(Posiadlosc(5, "KNRSI", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(6, "Parking", "niebieski", 1000, 60, 500, 500))
        board.append(Pole(7, "Szansa"))
        board.append(Posiadlosc(8, "Winda", "niebieski", 1000, 60, 500, 500))
        board.append(Posiadlosc(9, "Szatnia", "niebieski", 1200, 80, 500, 500))
        board.append(Pole(10, "Wiezienie"))
        board.append(
            Posiadlosc(11, "Sala 1073 (sieci)", "rozowy", 1400, 100, 700, 1000)
        )
        board.append(Posiadlosc(12, "Drążki za wydziałem", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(13, "Sala 0056 (laby)", "rozowy", 1400, 100, 700, 1000))
        board.append(
            Posiadlosc(14, "Sala 1072 (macbooki)", "rozowy", 1600, 120, 800, 1000)
        )
        board.append(Posiadlosc(15, "KNMF", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(16, "Ślimak", "pomaranczowy", 1800, 140, 900, 1000))
        board.append(Pole(17, "Szansa"))
        board.append(
            Posiadlosc(18, "Serwerownia", "pomaranczowy", 1800, 140, 900, 1000)
        )
        board.append(
            Posiadlosc(19, "Pokój samorządu", "pomaranczowy", 2000, 160, 1000, 1000)
        )
        board.append(Pole(20, "Parking"))
        board.append(Posiadlosc(21, "Recepcja", "czerwony", 2200, 180, 1100, 1500))
        board.append(Pole(22, "Szansa"))
        board.append(Posiadlosc(23, "Dziekanat", "czerwony", 2200, 180, 1100, 1500))
        board.append(
            Posiadlosc(24, "Muzeum komputerów", "czerwony", 2400, 200, 1200, 1500)
        )
        board.append(Posiadlosc(25, "KMS", "kolo", 2000, 250, 1000))
        board.append(Posiadlosc(26, "Mural", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(27, "Pomnik Kopernika", "zolty", 2600, 220, 1300, 1500))
        board.append(Posiadlosc(28, "Przejście przez WZIKS", "pozaWmii", 1500, 0, 750))
        board.append(Posiadlosc(29, "Fontanna", "zolty", 2800, 240, 1400, 1500))
        board.append(Pole(30, "Idz do wiezienia"))
        board.append(Posiadlosc(31, "Ping-pong", "zielony", 3000, 260, 1500, 2000))
        board.append(Posiadlosc(32, "Bilard", "zielony", 3000, 260, 1500, 2000))
        board.append(Pole(33, "Szansa"))
        board.append(Posiadlosc(34, "Piłkarzyki", "zielony", 3200, 280, 1600, 2000))
        board.append(Posiadlosc(35, "KSI", "kolo", 2000, 250, 1000))
        board.append(Pole(36, "Szansa"))
        board.append(Posiadlosc(37, "sala 0004", "granatowy", 3500, 350, 1750, 2000))
        board.append(PodatekDochodowy(38, 500))
        board.append(Posiadlosc(39, "sala 0089", "granatowy", 4000, 500, 2000, 2000))

        return board

    def __init__(self):
        self.plansza: [Pole] = self.inicializacja_planszy()
        self.karty = Karty()
        self.zagadki = Zagadki()
        self.wczytaj_grafiki()

    def pobierz_pole(self, numer_pola):
        if 0 <= numer_pola <= len(self.plansza):
            return self.plansza[numer_pola]
        else:
            raise Exception("Bledny numer pola")

    # def wysrodkuj_pionki(self):
    #
    # def wysrodkuj_plansze(self):

    def aktualizacja_rozmiaru(self, szerokosc, wysokosc):
        for pole in self.plansza:
            pole.aktualizacja_rozmiaru(szerokosc, wysokosc)

    def render(self, screen):
        for pole in self.plansza:
            pole.render(screen)

    def wczytaj_grafiki(self):
        i = 0
        path = "graphics/pola/pole_"
        extension = ".png"

        for pole in self.plansza:
            pole.sciezka_do_grafiki = path + str(i) + extension
            i += 1


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\PodatekDochodowy.py
from src.Pole import Pole
from src.Gracz import Gracz
from numpy import random


class Zagadka:
    def __init__(
        self,
        tresc_zagadki: str,
        odpowiedz_a: str,
        odpowiedz_b: str,
        odpowiedz_c: str,
        poprawna: str,
    ) -> None:
        self.tresc_zagadki = tresc_zagadki
        self.odpowiedz_a = odpowiedz_a
        self.odpowiedz_b = odpowiedz_b
        self.odpowiedz_c = odpowiedz_c
        self.poprawna = poprawna


class Zagadki:

    def __init__(self) -> None:
        self.lista_zagadek = self.wczytaj_zagadki("data/zagadki.txt")
        self.permutacja = random.permutation(self.lista_zagadek)
        self.ind = 0

    def nastepna_zagadka(self) -> Zagadka:
        curr = self.ind
        self.ind = (self.ind + 1) % len(self.lista_zagadek)
        return self.permutacja[curr]

    def wczytaj_zagadki(self, plik: str) -> list[Zagadka]:
        zagadki = []
        with open(plik, "r", encoding="utf-8") as file:
            lines = file.readlines()
            i = 0
            while i < len(lines):
                if i + 4 >= len(lines):
                    raise ValueError(
                        f"Problem w linii {i}. Każda zagadka powinna mieć 5 linii danych."
                    )
                tresc = lines[i].strip()
                odpowiedz_a = lines[i + 1].strip()
                odpowiedz_b = lines[i + 2].strip()
                odpowiedz_c = lines[i + 3].strip()
                poprawna = lines[i + 4].strip()
                zagadka = Zagadka(
                    tresc, odpowiedz_a, odpowiedz_b, odpowiedz_c, poprawna
                )
                zagadki.append(zagadka)
                i += 6
        return zagadki


class PodatekDochodowy(Pole):

    def __init__(self, numer: int, podatek: int) -> None:
        super().__init__(numer, "Podatek dochodowy")
        self.podatek = podatek

    def zaplac_podatek(self, gra, gracz: Gracz, czy_dobra: bool) -> None:
        do_zaplaty = self.podatek
        if czy_dobra:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Udzieliłeś/aś poprawnej odpowiedzi, koszt zostaje pomniejszony")
            do_zaplaty //= 2

        if gracz.wykonaj_oplate(gra, do_zaplaty):
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                "Podatek został zapłacony, zapłacono: " + str(do_zaplaty)
            )
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc("Bankrutujesz")


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Pole.py
import pygame
from typing import NamedTuple
from enum import Enum


# TODO: Do usuniecia, korzystanie z jednego enuma z Pionka, problem z kolejnoscia wystepowania
# TODO: atrybutow w enumie w Pionku, zla kolejnosc, poprawna ponizej
class KierunekPol(Enum):
    Gora = 0
    Prawo = 1
    Dol = 2
    Lewo = 3


class Vector2(NamedTuple):
    x: int
    y: int


class Pole:
    WYMIAR_NAGLOWKA: Vector2 = Vector2(30, 50)
    MALE_POLE_WYMIARY: Vector2 = Vector2(44, 70)
    # warning: najlepiej, gdy DUZE_POLE_WYMIARY ma oba wymiary z MALE_POLE_WYMIARY.y
    DUZE_POLE_WYMIARY: Vector2 = Vector2(70, 70)
    KOLOR_TLA = pygame.Color(28,28,30,255)
    OFF_SET: Vector2 = Vector2(12, 12)
    SPACING: int = 10
    MAKSYMALNA_LICZBA_POL: int = 40
    # dla sciany = ilosc malych pol + jedno duze pole
    DLUGOSC_SCIANY_W_POLACH = 10

    """
    numer_pola - nr. id pola [0, maksymalna_liczba_pol)
    dlugosc_sciany_w_polach - ilosc pol na jednym z czterech brzegow planszy, /*??odejmowana jest 1 do liczenia orientacji??*/, zakladamy ze plansza jest kwadratem 
    maksymalna_liczba_pol - ilosc pol na planszy
    """
    @staticmethod
    def oblicz_zwrot_naglowka_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> KierunekPol:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return KierunekPol((numer_pola % maksymalna_liczba_pol) // dlugosc_sciany_w_polach)

    @staticmethod
    def oblicz_rozmiar_pola(numer_pola, dlugosc_sciany_w_polach, maksymalna_liczba_pol) -> Vector2:
        if abs(maksymalna_liczba_pol / dlugosc_sciany_w_polach) != len(KierunekPol):
            raise "Podano niepoprawne wymiary planszy!"

        return Pole.DUZE_POLE_WYMIARY if (numer_pola % dlugosc_sciany_w_polach) == 0 else Pole.MALE_POLE_WYMIARY

    def inicjalizacja_pozycji(self, numer_pola, kierunek_sciany) -> Vector2:
        lewo = Pole.OFF_SET.x
        gora = Pole.OFF_SET.y

        # Uwaga na orientacje dlugosci i szerokosci pola, jako x i y, zawsze os pozioma to x, os pionowa to y, niezaleznie od orientacji pola, nieintuicyjne!
        match kierunek_sciany:
            case KierunekPol.Gora:
                lewo += ((Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING) if numer_pola % 10 != 0 else 0)
                lewo += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))

            case KierunekPol.Prawo:
                lewo += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING
                gora += 0 if (numer_pola % 10 == 0) else (((numer_pola % 10) - 1) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING))
                gora += ((Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING) if numer_pola % 10 != 0 else 0)

            case KierunekPol.Dol:
                lewo += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING)
                lewo += (Pole.DUZE_POLE_WYMIARY.x + Pole.SPACING)       # Czemu dziala nie mam bladego pojecia
                gora += 9 * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

            case KierunekPol.Lewo:
                gora += (9 - (numer_pola % 10)) * (Pole.MALE_POLE_WYMIARY.x + Pole.SPACING) + Pole.DUZE_POLE_WYMIARY.y + Pole.SPACING

        return Vector2(lewo * self.szerokosc_ratio, gora * self.wysokosc_ratio)

    def __init__(self, numer: int, typ: str):
        self.numer = numer
        self.typ = typ
        self.szerokosc_ratio = 1
        self.wysokosc_ratio = 1
        self.kupione_przez = 0 #jesli 0 to nie kupione
        self.kolor_naglowka = pygame.color.THECOLORS["violet"]
        self.wymiary: Vector2 = self.oblicz_rozmiar_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.kierunek_sciany = self.oblicz_zwrot_naglowka_pola(self.numer, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)
        self.pozycja: Vector2 = self.inicjalizacja_pozycji(self.numer, self.kierunek_sciany)
        self.sciezka_do_grafiki = "..."
        self.ilosc_graczy_na_polu = 0
        self.czy_zastawiona = False

    def zwroc_info(self) -> str:
        return f"Nazwa: {self.typ}"

    def aktualizacja_rozmiaru(self, szerokosc, wysokosc):
        szerokosc_ekranu = 1200
        wysokosc_ekranu = 660

        self.szerokosc_ratio = szerokosc / szerokosc_ekranu
        self.wysokosc_ratio = wysokosc / wysokosc_ekranu

        # print((szerokosc, wysokosc))

        self.pozycja = self.inicjalizacja_pozycji(self.numer, self.kierunek_sciany)

    def render(self, screen):
        szerokosc_aktualny_kierunek = self.wymiary.x if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.y
        wysokosc_aktualny_kierunek = self.wymiary.y if self.kierunek_sciany in (KierunekPol.Gora, KierunekPol.Dol) else self.wymiary.x

        szerokosc_aktualny_kierunek *= self.szerokosc_ratio
        wysokosc_aktualny_kierunek *= self.wysokosc_ratio

        test_wymiary = Pole.DUZE_POLE_WYMIARY if self.numer in (0, 10, 20, 30) else Pole.MALE_POLE_WYMIARY
        nowa_szerokosc = test_wymiary.x
        nowa_wysokosc = test_wymiary.y

        obrot = 0
        match self.kierunek_sciany:
            case KierunekPol.Dol:
                nowa_szerokosc *= self.szerokosc_ratio
                nowa_wysokosc *= self.wysokosc_ratio
                obrot = 0
            case KierunekPol.Lewo:
                nowa_szerokosc *= self.wysokosc_ratio
                nowa_wysokosc *= self.szerokosc_ratio
                obrot = 270
            case KierunekPol.Gora:
                nowa_szerokosc *= self.szerokosc_ratio
                nowa_wysokosc *= self.wysokosc_ratio
                obrot = 180
            case KierunekPol.Prawo:
                nowa_szerokosc *= self.wysokosc_ratio
                nowa_wysokosc *= self.szerokosc_ratio
                obrot = 90

        pole_surface = pygame.transform.scale(pygame.image.load(self.sciezka_do_grafiki), (nowa_szerokosc, nowa_wysokosc))
        pole_surface = pygame.transform.rotate(pole_surface, obrot)

        if self.czy_zastawiona:
            screen.blit(pole_surface, (self.pozycja.x, self.pozycja.y))
            self.renderuj_zastaw(screen, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek)
        else:
            self.renderuj_otoczke(screen, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek)
            screen.blit(pole_surface, (self.pozycja.x, self.pozycja.y))
        

    def renderuj_otoczke(self, screen, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek):

        if self.kupione_przez == 0:
            return
        elif self.kupione_przez == 1:
            color = (255, 0, 0)
        elif self.kupione_przez == 2:
            color = (0, 255, 0)
        elif self.kupione_przez == 3:
            color = (0, 0, 255)
        elif self.kupione_przez == 4:
            color = (255, 255, 0)
        elif self.kupione_przez == 5:
            color = (184, 3, 255)

        pygame.draw.rect(screen, color, pygame.Rect(self.pozycja.x- 2.5, self.pozycja.y - 2.5, szerokosc_aktualny_kierunek + 5, wysokosc_aktualny_kierunek + 5), width = 100)


    def renderuj_zastaw(self, screen, szerokosc_aktualny_kierunek, wysokosc_aktualny_kierunek):
        
        nakladka = pygame.Surface((szerokosc_aktualny_kierunek + 5, wysokosc_aktualny_kierunek + 5))
        nakladka.set_alpha(100)  

        if self.kupione_przez == 0:
            return
        elif self.kupione_przez == 1:
            color = (183, 132, 132 )
        elif self.kupione_przez == 2:
            color = (140, 183, 132 )
        elif self.kupione_przez == 3:
            color = (132, 151, 183 )
        elif self.kupione_przez == 4:
            color = (180, 183, 132 )
        elif self.kupione_przez == 5:
            color = (178, 132, 183 )

        nakladka.fill(color)
        screen.blit(nakladka, (self.pozycja.x- 2.5, self.pozycja.y - 2.5))

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Posiadlosc.py
from src.Pole import Pole
from src.Gracz import Gracz
import math

KOSZT_SPRZEDAZY = 0.8


class Posiadlosc(Pole):

    def __init__(self, numer, nazwa, kolor, cena, czynsz, zastaw, cena_domu=0):
        super().__init__(numer, "Posiadlosc")
        self.nazwa = nazwa
        self.kolor = kolor
        self.cena = cena
        self.czynsz = czynsz
        self.zastaw_kwota = zastaw
        self.cena_domu = cena_domu
        self.wlasciciel = None
        self.liczba_domow = 0
        self.liczba_hoteli = 0

    def zwroc_info(self):
        if self.liczba_domow:
            return f"Nazwa: {self.nazwa},  Cena: {self.cena}"
        return f"Nazwa: {self.nazwa},  Cena: {self.cena}"

    def pobierz_id_wlasciciela(self):
        return self.wlasciciel

    def wyswietl_info(self, gra):
        czynsz = self.czynsz
        if self.wlasciciel:
            czynsz = self.oblicz_czynsz(gra)

        if self.kolor != "pozaWmii" and self.kolor != "kolo":
            gra._kontroler_wiadomosci.dodaj_wiadomosc(f"Nazwa: {self.nazwa}")
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena-dom: {self.cena_domu}  Liczba domkow: {self.liczba_domow}"
            )
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc(f"Nazwa: {self.nazwa}")
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Cena: {self.cena}   Czynsz: {czynsz}  Zastaw: {self.zastaw_kwota}"
            )

    def oblicz_czynsz(self, gra):
        liczba_w_kolorze = self.wlasciciel.ile_w_kolorze(self.kolor)
        if self.kolor == "pozaWmii":
            if liczba_w_kolorze == 2:
                return gra._suma_oczek * 10 * 10
            else:
                return gra._suma_oczek * 4 * 10
        elif self.kolor == "kolo":
            if liczba_w_kolorze == 1:
                return 250
            elif liczba_w_kolorze == 2:
                return 500
            elif liczba_w_kolorze == 3:
                return 1000
            else:
                return 2000
        else:
            if liczba_w_kolorze < 3:
                return self.czynsz
            if liczba_w_kolorze == 3 and self.liczba_domow == 0:
                return 2 * self.czynsz

            cena = 0
            if self.liczba_domow == 1:
                cena = 5 * self.czynsz
            elif self.liczba_domow == 2:
                cena = 15 * self.czynsz
            elif self.liczba_domow == 3:
                cena = 45 * self.czynsz
            elif self.liczba_domow == 4:
                cena = 80 * self.czynsz

            cena += self.czynsz * 125 * self.liczba_hoteli
            return cena

    def aktualizuj_czynsz(self):
        if self.wlasciciel:
            liczba_posiadlosci = len(self.wlasciciel.lista_posiadlosci)
            self.czynsz *= 1 + 0.05  # * liczba_posiadlosci
            self.czynsz = math.ceil(self.czynsz)

    def kup_posiadlosc(self, gra, gracz):
        x = gracz.wykonaj_oplate(gra, self.cena)
        if x == 1:
            gracz.lista_posiadlosci.append(self)
            self.wlasciciel = gracz
            self.kupione_przez = int(gracz.pionek.sciezka_do_grafiki[27])
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Gratulacje, dokonałeś zakupu {self.nazwa}!"
            )
            gracz.statystyka.dodaj_posiadlosc()
            gra.akcja_pola_okno.czy_akcja_pola = False
            gra.czy_akcja_zakonczona = True

            for posiadlosc in gracz.lista_posiadlosci:
                posiadlosc.aktualizuj_czynsz()
        elif not gra.akcja_zastaw_okno.czy_zastaw and gracz.kwota < self.cena:
            gra._kontroler_wiadomosci.dodaj_wiadomosc("Wycofałeś się z zakupu")
            gra.akcja_pola_okno.czy_akcja_pola = False
            gra.czy_akcja_zakonczona = True

        return

    def kup_dom(self, gra, gracz, ile_domow):
        if gracz.wykonaj_oplate(gra, self.cena_domu * ile_domow):
            if ile_domow == 1 and self.liczba_domow == 4:
                self.liczba_domow = 0
                self.liczba_hoteli += 1
                gracz.statystyka.dodaj_hotel(1)
                gracz.statystyka.odejmij_domek(4)
            elif ile_domow == 1:
                self.liczba_domow += 1
                gracz.statystyka.dodaj_domek(1)
            elif ile_domow == 5:
                self.liczba_hoteli += 1
                gracz.statystyka.dodaj_hotel(1)
            gra._kontroler_wiadomosci.dodaj_wiadomosc(
                f"Zakup domu się udał posiadasz {self.liczba_domow} domów i {self.liczba_hoteli} hoteli"
            )           
        else:
            gra._kontroler_wiadomosci.dodaj_wiadomosc("Wycofałeś się z zakupu")

    def sprzedaj_dom(self, gra, gracz):
        if self.liczba_domow > 0:

            if gracz.umiejetnosc == "sprzedaje_nieruchomosci_za_oryginalna_ceny":
                gracz.kwota = gracz.kwota + self.cena_domu
            else:
                gracz.kwota = gracz.kwota + self.cena_domu * KOSZT_SPRZEDAZY

            self.liczba_domow -= 1
            gracz.statystyka.odejmij_dom(1)

    def sprzedaj_hotel(self, gra, gracz):
        if self.liczba_hoteli > 0:

            if gracz.umiejetnosc == "sprzedaje_nieruchomosci_za_oryginalna_ceny":
                gracz.kwota = gracz.kwota + \
                    (self.liczba_hoteli * 5 * self.cena_domu)
            else:
                gracz.kwota = (
                    gracz.kwota
                    + (self.liczba_hoteli * 5 * self.cena_domu) * KOSZT_SPRZEDAZY
                )
            self.liczba_hoteli -= 1
            gracz.statystyka.odejmij_hotel(1)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Przycisk.py
import pygame
from src.Wizualizator import Wizualizator


class Przycisk:
    def __init__(self, x, y, width, height, color, hover_color, text, text_color, rozmiar_czcionki = 36):
        self.rect = pygame.Rect(x, y, width, height)
        self.color: pygame.Color = color
        self.hover_color: pygame.Color = hover_color
        self.text = text
        self.text_color = text_color
        self.wizualizator = Wizualizator()
        self.font = pygame.font.Font(self.wizualizator.czcionka_przycisku, rozmiar_czcionki)

    def pobierz_wymiary(self) -> pygame.Rect:
        return self.rect

    def draw(self, screen):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        color = self.hover_color if is_hover else self.color
        pygame.draw.rect(screen, color, self.rect)

        if self.text:
            text_surf = self.font.render(self.text, True, self.text_color)
            text_rect = text_surf.get_rect(center = self.rect.center)
            screen.blit(text_surf, text_rect)

    def is_clicked(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == pygame.BUTTON_LEFT and self.rect.collidepoint(event.pos):
                return True
        return False

    def updateSize(self, x, y, width, height):
        if width <= 0 or height <= 0:
            return

        self.rect = pygame.Rect(x, y, width, height)

    def czy_najechano(self):
        mouse_pos = pygame.mouse.get_pos()
        is_hover = self.rect.collidepoint(mouse_pos)
        return is_hover

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\PrzyciskiMenu.py
from src.Przycisk import Przycisk
from src.Wizualizator import Wizualizator


class PrzyciskiMenu:

    def __init__(self, H, W, wizualizator):

        self.wizualizator = wizualizator

        self.nowa_gra = Przycisk(
            W * 0.35,
            H * 0.4,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Nowa gra",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.wczytaj_gre = Przycisk(
            W * 0.35,
            H * 0.52,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Wczytaj zapis",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.wyjscie = Przycisk(
            W * 0.35,
            H * 0.64,
            W * 0.3,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Wyjscie",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.trzydziesci_minut = Przycisk(
            W * 0.25,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "30",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.szescdziesiat_minut = Przycisk(
            W * 0.35,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "60",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.dziewiecdziesiat_minut = Przycisk(
            W * 0.45,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "90",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.jedna_minuta = Przycisk(
            W * 0.25,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "60",
            self.wizualizator.kolor_czcionki_na_przycisku,
            28
        )

        self.dwie_minuty = Przycisk(
            W * 0.35,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "120",
            self.wizualizator.kolor_czcionki_na_przycisku,
            28
        )

        self.trzy_minuty = Przycisk(
            W * 0.45,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "180",
            self.wizualizator.kolor_czcionki_na_przycisku,
            28
        )

        self.bez_ograniczen = Przycisk(
            W * 0.55,
            H * 0.5,
            W * 0.2,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Bez limitu",
            self.wizualizator.kolor_czcionki_na_przycisku,
            25,
        )

        self.two = Przycisk(
            W * 0.3,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "2",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.three = Przycisk(
            W * 0.4,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "3",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.four = Przycisk(
            W * 0.5,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "4",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.five = Przycisk(
            W * 0.6,
            H * 0.5,
            H * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "5",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.poprzedni = Przycisk(
            W * 0.2,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "poprzedni",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.nastepny = Przycisk(
            W * 0.3,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "nastepny",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.poprzedni_szary = Przycisk(
            W * 0.2,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_niedzialajcego_przycisku,
            self.wizualizator.kolor_niedzialajcego_przycisku,
            "poprzedni",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.nastepny_szary = Przycisk(
            W * 0.3,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_niedzialajcego_przycisku,
            self.wizualizator.kolor_niedzialajcego_przycisku,
            "nastepny",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.graj = Przycisk(
            W * 0.4,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku_graj,
            self.wizualizator.kolor_gdy_kursor_przycisku_graj,
            "graj",
            (40, 40, 40),
        )

        self.personalizacja = Przycisk(
            W * 0.5,
            H * 0.5,
            W * 0.1,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Dodaj karte",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )

        # cofnij na pole. karta wyjście z więznienia

        self.pobierz = Przycisk(
            W * 0.15,
            H * 0.3,
            W * 0.2,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "pobierz",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )
        self.pobierz_od_graczy = Przycisk(
            W * 0.15,
            H * 0.5,
            W * 0.25,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "pobierz od graczy",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )
        self.oplata = Przycisk(
            W * 0.15,
            H * 0.7,
            W * 0.25,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "oplata",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )
        self.oplata_za_domki = Przycisk(
            W * 0.5,
            H * 0.3,
            W * 0.25,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "oplata za domki",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )
        self.przejdz_na_pole = Przycisk(
            W * 0.5,
            H * 0.5,
            W * 0.25,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "przejdz na pole",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )
        self.cofnij_do_wiezienia = Przycisk(
            W * 0.5,
            H * 0.7,
            W * 0.25,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "cofnij do wiezienia",
            self.wizualizator.kolor_czcionki_na_przycisku,
            20,
        )

        self.powrot = Przycisk(
            W * 0.8,
            H * 0.8,
            W * 0.2,
            H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "powrot",
            self.wizualizator.kolor_czcionki_na_przycisku,
        )

        self.zaakceptuj = Przycisk(
            W * 0.8,
            H * 0.8,
            W * 0.2,
            H * 0.1,
            self.wizualizator.kolor_akceptacji_nazwy_gracza,
            self.wizualizator.kolor_gdy_kursor_przycisku_graj,
            "zaakceptuj",
            (40, 40, 40)
        )

    def aktualizuj_rozmiar(self, W, H):
        # skalowanie do jakiejsc czesci, testowo
        MIN_W = 500
        MIN_H = 400
        W = max(W, MIN_W)
        H = max(H, MIN_H)

        self.nowa_gra.updateSize(W * 0.35, H * 0.5, W * 0.3, H * 0.1)
        self.wczytaj_gre.updateSize(W * 0.35, H * 0.62, W * 0.3, H * 0.1)
        self.wyjscie.updateSize(W * 0.35, H * 0.74, W * 0.3, H * 0.1)
        self.two.updateSize(W * 0.3, H * 0.5, H * 0.1, H * 0.1)
        self.three.updateSize(W * 0.4, H * 0.5, H * 0.1, H * 0.1)
        self.four.updateSize(W * 0.5, H * 0.5, H * 0.1, H * 0.1)
        self.five.updateSize(W * 0.6, H * 0.5, H * 0.1, H * 0.1)

        self.trzydziesci_minut.updateSize(W * 0.25, H * 0.5, H * 0.1, H * 0.1)
        self.szescdziesiat_minut.updateSize(W * 0.35, H * 0.5, H * 0.1, H * 0.1)
        self.dziewiecdziesiat_minut.updateSize(W * 0.45, H * 0.5, H * 0.1, H * 0.1)

        self.jedna_minuta.updateSize(W * 0.25, H * 0.5, H * 0.1, H * 0.1)
        self.dwie_minuty.updateSize(W * 0.35, H * 0.5, H * 0.1, H * 0.1)
        self.trzy_minuty.updateSize(W * 0.45, H * 0.5, H * 0.1, H * 0.1)

        self.bez_ograniczen.updateSize(W * 0.55, H * 0.5, W * 0.2, H * 0.1)

        self.nastepny.updateSize(W * 0.4, H * 0.8, W * 0.2, H * 0.1)
        self.poprzedni.updateSize(W * 0.15, H * 0.8, W * 0.2, H * 0.1)
        self.graj.updateSize(W * 0.65, H * 0.8, W * 0.2, H * 0.1)
        self.nastepny_szary.updateSize(W * 0.4, H * 0.8, W * 0.2, H * 0.1)
        self.poprzedni_szary.updateSize(W * 0.15, H * 0.8, W * 0.2, H * 0.1)
        self.nowa_gra.updateSize(W * 0.35, H * 0.5, W * 0.3, H * 0.1)
        self.wczytaj_gre.updateSize(W * 0.35, H * 0.62, W * 0.3, H * 0.1)
        self.wyjscie.updateSize(W * 0.35, H * 0.74, W * 0.3, H * 0.1)
        self.two.updateSize(W * 0.3, H * 0.5, H * 0.1, H * 0.1)
        self.three.updateSize(W * 0.4, H * 0.5, H * 0.1, H * 0.1)
        self.four.updateSize(W * 0.5, H * 0.5, H * 0.1, H * 0.1)
        self.five.updateSize(W * 0.6, H * 0.5, H * 0.1, H * 0.1)

        self.nastepny.updateSize(W * 0.28, H * 0.8, W * 0.2, H * 0.1)
        self.poprzedni.updateSize(W * 0.05, H * 0.8, W * 0.2, H * 0.1)
        self.graj.updateSize(W * 0.51, H * 0.8, W * 0.2, H * 0.1)
        self.personalizacja.updateSize(
            W * 0.75,
            H * 0.8,
            W * 0.2,
            H * 0.1,
        )
        self.nastepny_szary.updateSize(W * 0.28, H * 0.8, W * 0.2, H * 0.1)
        self.poprzedni_szary.updateSize(W * 0.05, H * 0.8, W * 0.2, H * 0.1)

        #karty szansy
        self.pobierz.updateSize(W * 0.2, H * 0.3, W * 0.25, H * 0.1)
        self.pobierz_od_graczy.updateSize(W * 0.2, H * 0.45, W * 0.25, H * 0.1)
        self.oplata.updateSize(W * 0.2, H * 0.6, W * 0.25, H * 0.1)

        self.oplata_za_domki.updateSize(W * 0.55, H * 0.3, W * 0.25, H * 0.1)
        self.przejdz_na_pole.updateSize(W * 0.55, H * 0.45, W * 0.25, H * 0.1)
        self.cofnij_do_wiezienia.updateSize(W * 0.55, H * 0.6, W * 0.25, H * 0.1)

        self.powrot.updateSize(W * 0.4, H * 0.77, W * 0.2, H * 0.1)
        self.zaakceptuj.updateSize(W * 0.378, H * 0.4, W * 0.25, H * 0.15)


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Statystyka.py
class Statystyka:

    def __init__(self, kwota_startowa, nazwa_gracza):
        self.nazwa_gracza = nazwa_gracza
        self.pieniadze = kwota_startowa
        self.ilosc_posiadlosci = 0
        self.ilosc_domkow = 0
        self.ilosc_hoteli = 0

    def aktualizuj_stan_pieniedzy(self, pieniadze):
        self.pieniadze = pieniadze

    def dodaj_posiadlosc(self):
        self.ilosc_posiadlosci += 1

    def dodaj_hotel(self, ile):
        self.ilosc_hoteli += ile

    def dodaj_domek(self, ile):
        self.ilosc_domkow += ile

    def odejmij_domek(self, ile):
        self.ilosc_domkow -= ile

    

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\UJpoly.py
class Gra:
    def __init__(self):
        self.gracze = []
        
class Plansza:
    def __init__(self):
        self.Pola = []
        
class Gracz:
    def __init__(self, Id: int, pionek: Pionek, kartaSzansy: KartaSzansy, liczbaPostojow: int, uwiezienie: bool):
        self.Id = Id
        self.pionek = pionek
        self.kartaSzansy = kartaSzansy
        self.liczbaPostojow = liczbaPostojow
        self.uwiezienie = uwiezienie
        
class Posiadlosc(Pole):
    def __init__(self, cena: int, czynsz: int, cenaDomu: int, cenaHotelu: int, wlasciciel: Gracz):
        self.cena = cena
        self.czynsz = czynsz
        self.cenaDomu = cenaDomu
        self.cenaHotelu = cenaHotelu
        self.wlasciciel = wlasciciel        

class Pole:
    def __init__(self, numer: int, grafika: Graphic):
        self.numer = numer
        self.grafika = grafika

class PoleWykonywalne(Pole):
    def __init__(self):

class PoleSpecjalne(Pole):
    def __init__(self):
        
class KartaSzansy:
    def __init__(self, trescKarty: str):
        self.trescKarty = trescKarty
        
class Pionek:
    def __init__(self, numerPola: int, color: Color, grafika: Graphic):
        self.numerPola = numerPola
        self.color = color
        self.grafika = grafika

    def zmienGrafike(self) -> bool:

    def zmienPozycje(self, nowaPozycja: int) -> bool:

class Statystyki:
    def __init__(self):
        self.statystyki = []

    def zaktualizujStatystykiGracza(self, gracz: Gracz): 
        
class Statystyka:
    def __init__(self, IDgracza: int, majatek: int, iloscPosiadlosci: int, iloscDomow: int, iloscHoteli: int):
        self.IDgracza = IDgracza
        self.majatek = majatek
        self.iloscPosiadlosci = iloscPosiadlosci
        self.iloscDomow = iloscDomow
        self.iloscHoteli = iloscHoteli

    def zmienWartosc(self):       
        
class Tutorial:
    def __init__(self, ukonczony: bool):
        self.ukonczony = ukonczony

    def rozpocznij(self):        


class Czas:
    def __init__(self, czasGry: float, czasTury: float):
        self.czasGry = czasGry
        self.czasTury = czasTury


class Zagadki:
    def __init__(self, trescZagadki: str, poprawnaOdpowiedz: int):
        self.trescZagadki = trescZagadki
        self.poprawnaOdpowiedz = poprawnaOdpowiedz

    def sprawdzOdpowiedz(self) -> bool:


















C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\Wizualizator.py
class Wizualizator:

    def __init__(self):

        # przycisk
        self.kolor_przycisku = (70, 70, 70)
        self.kolor_gdy_kursor = (110, 110, 110)
        self.kolor_czcionki_na_przycisku = (200, 200, 200)
        self.kolor_przycisku_graj = (96, 247, 134)
        self.kolor_gdy_kursor_przycisku_graj = (76, 227, 114)
        self.kolor_niedzialajcego_przycisku = (50, 50, 50)
        self.kolor_przycisku_tury = (77, 77, 115)
        self.kolor_przycisku_tury_gdy_kursor = (87, 87, 125)

        # inne kolory
        self.kolor_akceptacji_nazwy_gracza = (96, 247, 134)
        self.kolor_tla = (119, 119, 175)
        self.kolor_napisu_gracz_tury = (255, 255, 255)
        self.kolor_czcionki = (255, 255, 255)
        self.kolor_czcionki_tyl_karty = (255, 255, 255)
        self.kolor_nakladki = (77, 77, 115)
        self.przezroczystosc_nakladki = 100
        self.kolor_zlotego_napisu = (255, 198, 26)

        #kolory wypisywania komunikatow
        self.kolor_wiadomosci = (255, 255, 255)
        self.kolor_ostatniej_wiadomosci = (255, 255, 255)

        #czcionka
        #self.czcionka = "fonts/Lato-Black.ttf"
        self.czcionka = None
        self.czcionka_przycisku = "fonts/Gameplay.ttf"


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\interface\IGra.py
import pygame
from abc import abstractmethod


class IGra:
    @abstractmethod
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        pass

    @abstractmethod
    def aktualizacja(self):
        pass

    @abstractmethod
    def wyswietl(self):
        pass

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaKartOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaKartOkno(Okno):

    def __init__(self, gra):
        self.H = 660
        self.W = 1200
        self.gra = gra
        self.czy_szansa = False
        self.szansa_png = pygame.transform.scale(
            pygame.image.load("graphics/karta_szansy.png"), (0.6 * self.W, 0.5 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.42,
            self.H * 0.7,
            self.W * 0.2,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )

        self.skalar_czcionki = 28  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )
        self.karta = None
        self.tresc_karty = "empty"
        self.gracz = None

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.czy_szansa:
            if self.wyjscie.is_clicked(event):
                if self.karta:
                    self.gra._plansza.karty.aktualna_karta.wykonaj_akcje(
                        self.gra, self.gracz
                    )
                self.czy_szansa = False
                self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        self.zaktualizuj_rozmiar_czcionki()

        self.wyjscie.updateSize(self.W * 0.42, self.H * 0.7, self.W * 0.2, self.H * 0.1)

        if self.czy_szansa:
            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(
                self.gra.przezroczystosc_nakladki
            )  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.wyjscie.draw(screen)

            szansa_png_wyswietlane = pygame.transform.scale(
                self.szansa_png, (0.64 * self.W, 0.5 * self.H)
            )
            screen.blit(szansa_png_wyswietlane, (self.W * 0.2, self.H * 0.15))
            self.wyswietl_lamana_tresc_karty(
                screen, self.tresc_karty, self.W * 0.5, self.H * 0.3
            )

    def przygotuj_karte(self, gracz):
        self.karta = self.gra._plansza.karty.nastepna_karta()
        self.tresc_karty = self.karta.tresc
        self.gracz = gracz

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki) - 15
        )
        self.karta = self.font.render(self.tresc_karty, True, self.gra.kolor_czcionki)

    def wyswietl_lamana_tresc_karty(
        self, screen, tekst: str, start_x, start_y
    ) -> float:
        """
        :param screen: ekran na ktory jest rysowany tekst
        :param tekst: tekst poddany lamaniu i wyswietleniu juz polamanym
        :param start_x: offset x do wyswietlania tekstu
        :param start_y: offset y do wyswietlania tekstu
        :return: procentowa ilosc zajetego ekranu przez linijki tekstu w porownaniu do calego ekranu
        """
        wyrazy = [wyraz.split(" ") for wyraz in tekst.splitlines()]
        szerokosc_spacji = self.font.size(" ")[0]

        maksymalna_szerokosc = int(self.gra.aktualna_szerokosc_ekranu * 0.8)
        x, y = start_x, start_y
        # ze stacka xD
        for line in wyrazy:
            for word in line:
                word_surface = self.font.render(word, 0, self.gra.kolor_czcionki)
                word_width, word_height = word_surface.get_size()
                if x + word_width >= maksymalna_szerokosc:
                    x = start_x  # Reset the x.
                    y += word_height  # Start on new row.
                screen.blit(word_surface, (x, y))
                x += word_width + szerokosc_spacji
            x = start_x  # Reset the x.
            y += word_height  # Start on new row.

        return (y - start_y) / self.gra.aktualna_wysokosc_ekranu

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaNieruchomosciOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaNieruchomosciOkno(Okno):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.nieruchomosc = "brak"

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_hotel = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup hotel",
            self.gra.kolor_tekstu,
        )
        self.przycisk_kup_domek = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kup domek",
            self.gra.kolor_tekstu,
        )

        self.karta = Przycisk(
            self.W * 0.6,
            self.H * 0.6,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "",
            self.gra.kolor_tekstu,
        )

        self.pole_png = None
        self.najechano_na_pole = False

        self.przycisk = self.wyjscie
        self.ktore_kupno = 0
        self.czy_kupno = False

        self.skalar_czcionki = 60  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )

    def ustaw_poprawny_przycisk_domek_hotel(self):

        if self.nieruchomosc == "domek":
            self.przycisk = self.przycisk_kup_domek
        elif self.nieruchomosc == "hotel":
            self.przycisk = self.przycisk_kup_hotel
        else:
            self.przycisk = self.wyjscie

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.czy_kupno:
            if self.przycisk.is_clicked(event) and self.nieruchomosc == "domek":
                self.kup_domek()
                self.czy_kupno = False
                self.zamknij()
            elif self.przycisk.is_clicked(event) and self.nieruchomosc == "hotel":
                self.kup_hotel()
                self.czy_kupno = False
                self.zamknij()
            elif self.wyjscie.is_clicked(event):
                self.czy_kupno = False
                self.zamknij()

            if self.czy_kupno:
                if self.karta.czy_najechano():
                    self.pole_png = pygame.transform.scale(
                        pygame.image.load("graphics/pola/pole_tyl_karty.png"),
                        (0.24 * self.W, 0.64 * self.H),
                    )
                    self.najechano_na_pole = True
                else:
                    self.pole_png = pygame.transform.scale(
                        pygame.image.load(self.posiadlosc_gracza.sciezka_do_grafiki),
                        (0.24 * self.W, 0.64 * self.H),
                    )
                    self.najechano_na_pole = False

    def wyswietl(self, screen: pygame.Surface):


        if self.czy_kupno:
            self.zaktualizuj_tekst_i_rozmiar()
            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(self.gra.przezroczystosc_nakladki)  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.pole_png = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(self.pole_png, (self.W * 0.2, self.H * 0.15))
            self.przycisk.updateSize(
                self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
            )
            self.wyjscie.updateSize(
                self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
            )
            self.karta.updateSize(
                self.W * 0.2, self.H * 0.15, 0.24 * self.W, 0.64 * self.H
            )
            self.przycisk.draw(screen)
            self.wyjscie.draw(screen)

            pole_png_wyswietlane = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(pole_png_wyswietlane, (self.W * 0.2, self.H * 0.15))

            self.odleglosc_pionowa = 0.03
            self.wysokosc_napisow = 0.42
            if self.najechano_na_pole:
                screen.blit(
                    self.czynsz_bez_nieruchomosci,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (0 * self.odleglosc_pionowa)),
                    ),
                )
                screen.blit(
                    self.wzrost_czynszu_dom,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (1 * self.odleglosc_pionowa)),
                    ),
                )
                screen.blit(
                    self.wzrost_czynszu_hotel,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (2 * self.odleglosc_pionowa)),
                    ),
                )

    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_gracza = posiadlosc
        self.gracz = gracz
        self.ustaw_poprawny_przycisk_domek_hotel()
        self.pole_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_gracza.sciezka_do_grafiki),
            (0.28 * self.W, 0.64 * self.H),
        )

    def kup_domek(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 1)

    def kup_hotel(self):
        self.posiadlosc_gracza.kup_dom(self.gra, self.gracz, 5)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True

    def zaktualizuj_tekst_i_rozmiar(self):
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )

        if self.posiadlosc_gracza is None:
            self.czynsz_bez_nieruchomosci = self.font.render(
                "Czynsz bez nieruchomości: " + str(100),
                True,
                self.gra.kolor_czcionki_tyl_karty,
            )
        else:
            self.czynsz_bez_nieruchomosci = self.font.render(
                "Czynsz bez nieruchomości: " + str(self.posiadlosc_gracza.czynsz),
                True,
                self.gra.kolor_czcionki_tyl_karty,
            )
        self.wzrost_czynszu_dom = self.font.render(
            "Wzrost czynszu (domek +): " + str(70),
            True,
            self.gra.kolor_czcionki_tyl_karty,
        )
        self.wzrost_czynszu_hotel = self.font.render(
            "Wzrost czynszu (hotel +): " + str(100),
            True,
            self.gra.kolor_czcionki_tyl_karty,
        )

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaPolaOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame
from enum import Enum


class AkcjaPolaOkno(Okno):
    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zakup = Przycisk(
            self.W * 0.6,
            self.H * 0.2,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "kupuje",
            self.gra.kolor_tekstu,
        )
        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.4,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )
        self.karta = Przycisk(
            self.W * 0.6,
            self.H * 0.6,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "",
            self.gra.kolor_tekstu,
        )

        self.pole_png = None
        self.najechano_na_pole = False

        self.czy_akcja_pola = False
        self.gracz_majacy_mozliwosc_zakupu = None
        self.posiadlosc_do_zakupu = None

        self.skalar_czcionki = 60  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.czy_akcja_pola:

            if self.zakup.is_clicked(event):
                self.kup_pole()
                # self.zamknij()
            elif self.wyjscie.is_clicked(event):
                self.zamknij()
                pass

            if self.czy_akcja_pola:
                if self.karta.czy_najechano():
                    self.pole_png = pygame.transform.scale(
                        pygame.image.load("graphics/pola/pole_tyl_karty.png"),
                        (0.24 * self.W, 0.64 * self.H),
                    )
                    self.najechano_na_pole = True
                else:
                    self.pole_png = pygame.transform.scale(
                        pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
                        (0.24 * self.W, 0.64 * self.H),
                    )
                    self.najechano_na_pole = False

    def wyswietl(self, screen: pygame.Surface):

        self.zaktualizuj_tekst_i_rozmiar()

        if self.czy_akcja_pola:
            self.zakup.updateSize(
                self.W * 0.6, self.H * 0.3, self.W * 0.2, self.H * 0.15
            )

            self.wyjscie.updateSize(
                self.W * 0.6,
                self.H * 0.5,
                self.W * 0.2,
                self.H * 0.15,
            )

            self.karta.updateSize(
                self.W * 0.2, self.H * 0.15, 0.24 * self.W, 0.64 * self.H
            )

            nakladka = pygame.Surface(screen.get_size())
            nakladka.set_alpha(
                self.gra.przezroczystosc_nakladki
            )  # Ustaw przezroczystość (0-255)
            nakladka.fill(self.gra.kolor_nakladki)
            screen.blit(nakladka, (0, 0))

            self.zakup.draw(screen)
            self.wyjscie.draw(screen)

            pole_png_wyswietlane = pygame.transform.scale(
                self.pole_png, (0.24 * self.W, 0.64 * self.H)
            )
            screen.blit(pole_png_wyswietlane, (self.W * 0.2, self.H * 0.15))

            self.odleglosc_pionowa = 0.03
            self.wysokosc_napisow = 0.42
            if self.najechano_na_pole:
                screen.blit(
                    self.czynsz_bez_nieruchomosci,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (0 * self.odleglosc_pionowa)),
                    ),
                )
                screen.blit(
                    self.wzrost_czynszu_dom,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (1 * self.odleglosc_pionowa)),
                    ),
                )
                screen.blit(
                    self.wzrost_czynszu_hotel,
                    (
                        self.W * 0.23,
                        self.H * (self.wysokosc_napisow + (2 * self.odleglosc_pionowa)),
                    ),
                )

    def akcja_kupowania(self, posiadlosc, gracz):
        self.posiadlosc_do_zakupu = posiadlosc
        self.gracz_majacy_mozliwosc_zakupu = gracz
        self.pole_png = pygame.transform.scale(
            pygame.image.load(self.posiadlosc_do_zakupu.sciezka_do_grafiki),
            (0.24 * self.W, 0.64 * self.H),
        )

    def kup_pole(self):
        self.posiadlosc_do_zakupu.kup_posiadlosc(
            self.gra, self.gracz_majacy_mozliwosc_zakupu
        )

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.czy_akcja_pola = False
        self.gra.czy_akcja_zakonczona = True

    def zaktualizuj_tekst_i_rozmiar(self):
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )

        if self.posiadlosc_do_zakupu is None:
            self.czynsz_bez_nieruchomosci = self.font.render(
                "Czynsz bez nieruchomości: " + str(100),
                True,
                self.gra.kolor_czcionki_tyl_karty,
            )
        else:
            self.czynsz_bez_nieruchomosci = self.font.render(
                "Czynsz bez nieruchomości: " + str(self.posiadlosc_do_zakupu.czynsz),
                True,
                self.gra.kolor_czcionki_tyl_karty,
            )
        self.wzrost_czynszu_dom = self.font.render(
            "Wzrost czynszu (domek +): " + str(70),
            True,
            self.gra.kolor_czcionki_tyl_karty,
        )
        self.wzrost_czynszu_hotel = self.font.render(
            "Wzrost czynszu (hotel +): " + str(100),
            True,
            self.gra.kolor_czcionki_tyl_karty,
        )


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaStatystykOkno.py
from src.okno.Okno import Okno
from src.Statystyka import Statystyka
import pygame


MAKSYMALNA_DLUGOSC_NAZWY_GRACZA = 12

class AkcjaStatystykOkno(Okno):
    def __init__(self, gra):
        self.W = 1200
        self.H = 660
        self.gra = gra
        self.czy_akcja_statystyk = True

        self.skalar_czcionki = 40 # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

        self.odleglosc_pionowa = 0.06
        self.mnoznik_wysokosci = 0.1
        self.mnoznik_szerokosci = 0.62
        self.miejsce_na_zdjecie = 0.04

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        pass

    def wyswietl(self, screen: pygame.Surface):

        if self.czy_akcja_statystyk:
            
            self.bankrut = pygame.transform.scale(
                pygame.image.load("graphics/bankrut.png"),
                (0.02 * self.W, 0.022 * self.W)
            )

            i = 0
            self.ramka = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_statystyk.png"),
                (self.W * 0.43, self.H * 0.36)
            )
            screen.blit(self.ramka, (self.W * (self.mnoznik_szerokosci - 0.06), self.H * (self.mnoznik_wysokosci - 0.08)))

            self.tlo_wiad = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_wiadomosci.png"),
                (self.W * 0.43, self.H * 0.583)
            )
            screen.blit(self.tlo_wiad, (self.W * (self.mnoznik_szerokosci - 0.06), self.H * (self.mnoznik_wysokosci + 0.3)))

            self.tlo_glowna = pygame.transform.scale(
                pygame.image.load("graphics/tlo_do_glownej_wiadomosci.png"),
                (self.W * 0.43, self.H * 0.05)
            )
            screen.blit(self.tlo_glowna, (self.W * (self.mnoznik_szerokosci - 0.06), self.gra._kontroler_wiadomosci.koordynaty_ostatniej_wiadomosci))

            for gracz in self.gra._gracze:

                self.umiejetnosc = pygame.transform.scale(
                    pygame.image.load("graphics/umiejetnosci/" + gracz.umiejetnosc + ".png"),
                    (0.02 * self.W, 0.02 * self.W)
                )

                nazwa_gracza = self.sprawdz_czy_nazwa_gracza_nie_za_dluga(gracz.id)
                self.zaktualizuj_tekst_i_rozmiar(gracz, nazwa_gracza)

                self.zdjecie_pionek = pygame.transform.scale(
                    pygame.image.load(gracz.pionek.sciezka_do_grafiki), (0.02 * self.W, 0.02 * self.W)
                )

                screen.blit(self.umiejetnosc, (self.W * (self.mnoznik_szerokosci), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa - 0.005))))
                if gracz.czy_aktywny:
                    screen.blit(self.zdjecie_pionek, (self.W * (self.mnoznik_szerokosci - 0.03), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa - 0.005))))
                else:
                    screen.blit(self.bankrut, (self.W * (self.mnoznik_szerokosci - 0.03), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa - 0.002))))

                screen.blit(self.nazwa, (self.W * (self.mnoznik_szerokosci + self.miejsce_na_zdjecie), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                if gracz.czy_aktywny:
                    screen.blit(self.pieniadze, (self.W * (self.mnoznik_szerokosci + 0.17), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                    screen.blit(self.posiadlosci, (self.W * (self.mnoznik_szerokosci + 0.22 + self.miejsce_na_zdjecie), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                    screen.blit(self.domki, (self.W * (self.mnoznik_szerokosci + 0.26 + self.miejsce_na_zdjecie), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                    screen.blit(self.hotele, (self.W * (self.mnoznik_szerokosci + 0.3 + self.miejsce_na_zdjecie), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))
                else:
                    screen.blit(self.bankrut_tekst, (self.W * (self.mnoznik_szerokosci + 0.17), self.H * (self.mnoznik_wysokosci + (i * self.odleglosc_pionowa))))

                
                i += 1


    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


    def sprawdz_czy_nazwa_gracza_nie_za_dluga(self, nazwa):
        if len(nazwa) > MAKSYMALNA_DLUGOSC_NAZWY_GRACZA:
            return (nazwa[:MAKSYMALNA_DLUGOSC_NAZWY_GRACZA - 3] + "...")
        else:
            return nazwa
        
    def zaktualizuj_tekst_i_rozmiar(self, gracz, nazwa_gracza):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))

        self.bankrut_tekst = self.font.render(
            "BANKRUT", True, (255, 77, 77)
        )
        self.nazwa = self.font.render(
            str(nazwa_gracza), True, self.gra.kolor_czcionki
        )
        self.pieniadze = self.font.render(
            str(gracz.statystyka.pieniadze), True, self.gra.kolor_czcionki
        )
        self.posiadlosci = self.font.render(
            str(gracz.statystyka.ilosc_posiadlosci), True, self.gra.kolor_czcionki
        )
        self.domki = self.font.render(
            str(gracz.statystyka.ilosc_domkow), True, self.gra.kolor_czcionki
        )
        self.hotele = self.font.render(
            str(gracz.statystyka.ilosc_hoteli), True, self.gra.kolor_czcionki
        )
        

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaWiezieniaOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaWiezieniaOkno(Okno):

    def __init__(self, gra):
        self.W = 1200
        self.H = 800
        self.gra = gra

        self.zdjecie = pygame.transform.scale(
            pygame.image.load("graphics/wiezienie.png"), (0.45 * self.H, 0.45 * self.H)
        )

        self.wyjscie = Przycisk(
            self.W * 0.6,
            self.H * 0.3,
            self.W * 0.2,
            self.H * 0.15,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "wyjscie",
            self.gra.kolor_tekstu,
        )
        self.czy_wiezienie = False

        self.skalar_czcionki = 24  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.informacja_o_wiezeniu = "Idziesz do więzienia, stoisz 2 tury."

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.czy_wiezienie:
            if self.wyjscie.is_clicked(event):
                self.zamknij()
                self.czy_wiezienie = False

    def wyswietl(self, screen: pygame.Surface):
        H = self.H
        W = self.W

        if self.czy_wiezienie:
            screen.fill(self.gra.kolor_tla)

            self.zaktualizuj_rozmiar_czcionki()
            self.wyswietl_teksty(screen)

            self.zdjecie = pygame.transform.scale(
                self.zdjecie, (0.6 * self.H, 0.6 * self.H)
            )
            screen.blit(self.zdjecie, (W * 0.15, H * 0.08))
            self.wyjscie.updateSize(W * 0.6, H * 0.3, W * 0.2, H * 0.15)
            self.wyjscie.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(self.gra.czcionka, int(self.W / self.skalar_czcionki))
        self.tekst = self.font.render(self.informacja_o_wiezeniu, True, self.gra.kolor_czcionki)

    def wyswietl_teksty(self, screen):
        screen.blit(self.tekst, (self.W * 0.18, self.H * 0.7))

    def zamknij(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaZagadekOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
import pygame


class AkcjaZagadekOkno(Okno):

    def __init__(self, gra):

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.czy_zagadka = False

        self.A = Przycisk(
            self.W * 0.2,
            self.H * 0.5,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "A",
            self.gra.kolor_tekstu,
        )
        self.B = Przycisk(
            self.W * 0.2,
            self.H * 0.6,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "B",
            self.gra.kolor_tekstu,
        )
        self.C = Przycisk(
            self.W * 0.2,
            self.H * 0.7,
            self.H * 0.1,
            self.H * 0.1,
            self.gra.kolor_przycisku,
            self.gra.kolor_gdy_kursor,
            "C",
            self.gra.kolor_tekstu,
        )

        self.odpowiedz_A = "empty"
        self.odpowiedz_B = "empty"
        self.odpowiedz_C = "empty"
        self.poprawna_odpowiedz = "empty"

        self.skalar_czcionki = 28  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )
        self.informacja_o_podatku = "Zapłać podatek dochodowy o wartości "
        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + "x"
        self.informacja_o_zagadce = ""
        self.tekst_zagadki = "empty"

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):

        if self.czy_zagadka:

            if self.A.is_clicked(event):
                self.pole.zaplac_podatek(
                    self.gra, self.gracz, (self.poprawna_odpowiedz == "A")
                )
                self.czy_zagadka = False
                self.zamknij()
            elif self.B.is_clicked(event):
                self.pole.zaplac_podatek(
                    self.gra, self.gracz, (self.poprawna_odpowiedz == "B")
                )
                self.czy_zagadka = False
                self.zamknij()
            elif self.C.is_clicked(event):
                self.pole.zaplac_podatek(
                    self.gra, self.gracz, (self.poprawna_odpowiedz == "C")
                )
                self.czy_zagadka = False
                self.zamknij()

    def wyswietl(self, screen: pygame.Surface):
        self.zaktualizuj_rozmiar_czcionki()

        if self.czy_zagadka:
            screen.fill(self.gra.kolor_tla)
            screen.blit(self.podatek, (self.W * 0.18, self.H * 0.2))
            screen.blit(self.info, (self.W * 0.19, self.H * 0.27))
            offset_height_percent = self.wyswietl_lamana_tresc_zagadki(
                screen, self.tekst_zagadki, self.W * 0.2, self.H * 0.4
            )

            # odpowiedzi
            offset_height_percent -= 0.05
            screen.blit(
                self.oA, (self.W * 0.3, self.H * (0.54 + offset_height_percent))
            )
            screen.blit(
                self.oB, (self.W * 0.3, self.H * (0.66 + offset_height_percent))
            )
            screen.blit(
                self.oC, (self.W * 0.3, self.H * (0.78 + offset_height_percent))
            )

            self.wyswietl_przyciski(screen, offset_height_percent)

    def przygotuj_zagadke(self):
        zagadka = self.gra._plansza.zagadki.nastepna_zagadka()
        self.tekst_zagadki = zagadka.tresc_zagadki

        self.odpowiedz_A = zagadka.odpowiedz_a
        self.odpowiedz_B = zagadka.odpowiedz_b
        self.odpowiedz_C = zagadka.odpowiedz_c
        self.poprawna_odpowiedz = zagadka.poprawna

        self.informacja_o_podatku_z_cena = self.informacja_o_podatku + str(
            self.pole.podatek
        )
        self.informacja_o_zagadce = (
            "Odpowiedz poprawnie na pytanie aby zmniejszyć opłatę i zapłacić tylko "
            + str((self.pole.podatek // 2))
        )

    def akcja_podatkowa(self, gracz, pole):
        self.gracz = gracz
        self.pole = pole

    def zaktualizuj_rozmiar_czcionki(self):
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )
        self.podatek = self.font.render(
            self.informacja_o_podatku_z_cena, True, self.gra.kolor_czcionki
        )
        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki) - 15
        )
        self.info = self.font.render(
            self.informacja_o_zagadce, True, self.gra.kolor_czcionki
        )
        self.zagadka = self.font.render(
            self.tekst_zagadki, True, self.gra.kolor_czcionki
        )

        # odpowiedzi
        self.oA = self.font.render(self.odpowiedz_A, True, self.gra.kolor_czcionki)
        self.oB = self.font.render(self.odpowiedz_B, True, self.gra.kolor_czcionki)
        self.oC = self.font.render(self.odpowiedz_C, True, self.gra.kolor_czcionki)

    def wyswietl_lamana_tresc_zagadki(
        self, screen, tekst: str, start_x, start_y
    ) -> float:
        """
        :param screen: ekran na ktory jest rysowany tekst
        :param tekst: tekst poddany lamaniu i wyswietleniu juz polamanym
        :param start_x: offset x do wyswietlania tekstu
        :param start_y: offset y do wyswietlania tekstu
        :return: procentowa ilosc zajetego ekranu przez linijki tekstu w porownaniu do calego ekranu
        """
        wyrazy = [wyraz.split(" ") for wyraz in tekst.splitlines()]
        szerokosc_spacji = self.font.size(" ")[0]

        maksymalna_szerokosc = self.gra.aktualna_szerokosc_ekranu
        x, y = start_x, start_y
        # ze stacka xD
        for line in wyrazy:
            for word in line:
                word_surface = self.font.render(word, 0, self.gra.kolor_czcionki)
                word_width, word_height = word_surface.get_size()
                if x + word_width >= maksymalna_szerokosc:
                    x = start_x  # Reset the x.
                    y += word_height  # Start on new row.
                screen.blit(word_surface, (x, y))
                x += word_width + szerokosc_spacji
            x = start_x  # Reset the x.
            y += word_height  # Start on new row.

        return (y - start_y) / self.gra.aktualna_wysokosc_ekranu

    def wyswietl_przyciski(self, screen, offset_height_percent):
        self.A.updateSize(
            self.W * 0.2,
            self.H * (0.5 + offset_height_percent),
            self.H * 0.1,
            self.H * 0.1,
        )
        self.A.draw(screen)
        self.B.updateSize(
            self.W * 0.2,
            self.H * (0.62 + offset_height_percent),
            self.H * 0.1,
            self.H * 0.1,
        )
        self.B.draw(screen)
        self.C.updateSize(
            self.W * 0.2,
            self.H * (0.74 + offset_height_percent),
            self.H * 0.1,
            self.H * 0.1,
        )
        self.C.draw(screen)

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.gra._kontroler_wiadomosci.dodaj_wiadomosc(
            f"Poprawna odpowiedz to: {self.poprawna_odpowiedz}"
        )
        self.gra.czy_akcja_zakonczona = True

    def zamknij_bez_wiadomosci(self):
        self.gra.czy_akcja_zakonczona = True


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\AkcjaZastawOkno.py
from src.okno.Okno import Okno
from src.Przycisk import Przycisk
from src.Wizualizator import Wizualizator
import pygame


class AkcjaZastawOkno(Okno):

    def __init__(self, gra):
        self.stan = "czy_chcesz_zastawic"
        self.wizualizator: Wizualizator = gra.wizualizator
        self.font = pygame.font.Font(self.wizualizator.czcionka, 32)

        self.H = 800
        self.W = 1200
        self.gra = gra
        self.gracz = None
        self.cena = 0
        self.czy_zastaw = False
        self.wczytana_posiadlosc = ""
        self.ile_do_zastawienia = 0

        self.przycisk_zastaw = Przycisk(
            self.W * 0.35,
            self.H * 0.4,
            self.W * 0.3,
            self.H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Zastaw",
            self.wizualizator.kolor_czcionki_na_przycisku,
            )
        self.przycisk_wyjscie = Przycisk(
            self.W * 0.35,
            self.H * 0.64,
            self.W * 0.3,
            self.H * 0.1,
            self.wizualizator.kolor_przycisku,
            self.wizualizator.kolor_gdy_kursor,
            "Wyjscie",
            self.wizualizator.kolor_czcionki_na_przycisku,
            )

        self.skalar_czcionki = 40  # im wiekszy tym mniejsza czcionka
        self.font = pygame.font.Font(
            self.wizualizator.czcionka, int(self.W / self.skalar_czcionki)
        )

    def aktualizacja(self):
        pass

    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        if self.czy_zastaw:
            if event.type == pygame.MOUSEBUTTONDOWN:
                if self.stan == "czy_chcesz_zastawic":
                    if self.przycisk_zastaw.is_clicked(event):
                        self.stan = "wybierz_numer"
                        self.wczytana_posiadlosc = ""
                if self.przycisk_wyjscie.is_clicked(event):
                    self.zamknij()

            elif event.type == pygame.KEYDOWN:

                if event.key == pygame.K_ESCAPE:
                    self.zamknij()

                if self.stan == "wybierz_numer":
                    if event.key == pygame.K_RETURN:
                        if self.wczytana_posiadlosc == "":
                            self.stan = "blad"
                            self.wczytana_posiadlosc = ""
                        else:
                            self.wczytana_posiadlosc = int(self.wczytana_posiadlosc)
                            if (
                                self.wczytana_posiadlosc > 0
                                and self.wczytana_posiadlosc <= self.ile_do_zastawienia
                            ):
                                self.gracz.zastaw_posiadlosci(
                                    self.gra, self.wczytana_posiadlosc - 1
                                )
                                self.stan = "zastawiono"
                            else:
                                self.stan = "blad"
                                self.wczytana_posiadlosc = ""
                    elif event.key == pygame.K_BACKSPACE:
                        if len(self.wczytana_posiadlosc) > 0:
                            self.wczytana_posiadlosc = self.wczytana_posiadlosc[:-1]
                    elif event.unicode.isdigit():
                        self.wczytana_posiadlosc += event.unicode
                elif self.stan == "zastawiono":
                    self.stan = "czy_chcesz_zastawic"
                elif self.stan == "blad":
                    self.stan = "wybierz_numer"
                    self.wczytana_posiadlosc = ""
                elif self.stan == "wyjscie":
                    self.zamknij()

    def wyswietl(self, screen: pygame.Surface):

        self.font = pygame.font.Font(
            self.gra.czcionka, int(self.W / self.skalar_czcionki)
        )

        if self.czy_zastaw:
            screen.fill(self.gra.kolor_tla)

            if (
                    self.stan == "czy_chcesz_zastawic"
                    and self.gracz.liczba_zastawionych >= len(self.gracz.lista_posiadlosci)
            ):
                self.przycisk_wyjscie.updateSize(
                    self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
                )

                text = self.font.render(
                    "Nie masz już posiadłości, które mógłbyś zastawić",
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.1))
                self.stan = "wyjscie"
                pygame.display.update()
                pygame.time.wait(2000)
                self.zamknij()

            elif self.stan == "czy_chcesz_zastawic":
                self.przycisk_zastaw.updateSize(
                    self.W * 0.6, self.H * 0.2, self.W * 0.2, self.H * 0.15
                )
                self.przycisk_wyjscie.updateSize(
                    self.W * 0.6, self.H * 0.4, self.W * 0.2, self.H * 0.15
                )
                self.przycisk_zastaw.draw(screen)
                self.przycisk_wyjscie.draw(screen)

                if self.cena - self.gracz.kwota <= 0:
                    tekst = "Masz już wystarczającą ilość pieniędzy. Czy chcesz zastawić posiadłość? Masz poniższe do wyboru"
                else:
                    tekst = f"Brakuje Ci {self.cena - self.gracz.kwota}. Czy chcesz zastawić jakąś posiadłość? Masz poniższe do wyboru"

                text = self.font.render(
                    tekst,
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.1))
                self.wyswietl_do_zastawu(screen)

            elif self.stan == "wybierz_numer":
                text = self.font.render(
                    f"Wpisz numer posiadłości",
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.1))
                self.wyswietl_do_zastawu(screen)
                text = self.font.render(
                    str(self.wczytana_posiadlosc),
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.8))

            elif self.stan == "blad":
                text = self.font.render(
                    f"Wpisano zły numer",
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.1))

            elif self.stan == "zastawiono":
                text = self.font.render(
                    f"Zastawiono posiadłość",
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * 0.1))

    def wyswietl_do_zastawu(self, screen):
        odstep = 0.25
        x = 1
        for posiadlosc in self.gracz.lista_posiadlosci:
            if not posiadlosc.czy_zastawiona:
                text = self.font.render(
                    f"{x}: {posiadlosc.nazwa}, kwota zastawu: {posiadlosc.zastaw_kwota}",
                    True,
                    self.wizualizator.kolor_czcionki,
                )
                screen.blit(text, (self.W * 0.1, self.H * odstep))
                odstep += 0.05
            x += 1
        self.ile_do_zastawienia = x - 1

    def ustaw_gracza(self, gracz, cena):
        self.stan = "czy_chcesz_zastawic"
        self.wczytana_posiadlosc = ""
        self.gracz = gracz
        self.cena = cena

    def aktualizuj_rozmiar_okna(self, width, height):
        self.W = width
        self.H = height

    def zamknij(self):
        self.wczytana_posiadlosc = ""
        self.czy_zastaw = False


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\okno\Okno.py
import pygame
from abc import abstractmethod


class Okno:
    @staticmethod
    def wysrodkuj_obraz(okno: pygame.Vector2, obraz: pygame.Vector2) -> pygame.Vector2:
        left = (okno.x // 2) - (obraz.x // 2)
        top = (okno.y // 2) - (obraz.y // 2)

        return pygame.Vector2(left, top)

    @abstractmethod
    def aktualizacja(self):
        pass

    @abstractmethod
    def aktualizacja_zdarzen(self, event: pygame.event.Event):
        pass

    @abstractmethod
    def wyswietl(self, screen: pygame.Surface):
        pass

    @abstractmethod
    def aktualizuj_rozmiar_okna(self, width, height):
        pass

    @abstractmethod
    def zamknij(self):
        pass


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\src\proxy\GraProxy.py
import pygame
from src.interface.IGra import IGra
from src.Gra import Gra


class Kolejka:
    def __init__(self):
        self._kolejka: list[pygame.event.Event] = list()

    def rozmiar(self):
        return len(self._kolejka)

    def czy_pusta(self):
        return len(self._kolejka) == 0

    def dodaj(self, element: pygame.event.Event):
        self._kolejka.append(element)

    def pobierz(self) -> pygame.event.Event | None:
        if not self.czy_pusta():
            return self._kolejka.pop(0)

        return None


class GraProxy(IGra):
    def __init__(self, gra: Gra):
        self._kolejka_test_zdarzen: Kolejka = Kolejka()
        self._instancja_gra: Gra = gra
        self._czy_moze_wykonac_nastepne_zdarzenie = False
        print("HELLO from GraProxy")

    def _zablokuj_wykonywanie_zdarzen(self):
        self._czy_moze_wykonac_nastepne_zdarzenie = False

    # override
    def aktualizacja_zdarzenia(self, event: pygame.event.Event):
        if self._czy_moze_wykonac_nastepne_zdarzenie is True:
            nastepne_zdarzenie = self._kolejka_test_zdarzen.pobierz()

            if nastepne_zdarzenie is not None:
                self._instancja_gra.wykonaj_zdarzenie(nastepne_zdarzenie)

            self._zablokuj_wykonywanie_zdarzen()

    # override
    def aktualizacja(self):
        pass

    # override
    def wyswietl(self):
        pass

    def wykonaj_wszystkie_zakolejkowane_wydarzenia(self):
        while not self._kolejka_test_zdarzen.czy_pusta():
            nastepne_zdarzenie = self._kolejka_test_zdarzen.pobierz()

            if nastepne_zdarzenie is not None:
                self._instancja_gra.wykonaj_zdarzenie(nastepne_zdarzenie)

    def pozwol_wykonac_zdarzenie_z_kolejki(self):
        self._czy_moze_wykonac_nastepne_zdarzenie = True

    def dodaj_zdarzenie_do_kolejki(self, event: pygame.event.Event):
        self._kolejka_test_zdarzen.dodaj(event)

    def pobierz_instancje_gry(self) -> Gra:
        return self._instancja_gra



C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\test_scenariuszowy.py
import pytest
import pygame
import os
import itertools

from Main import Main
from src.Gracz import Gracz
from src.Gra import Gra
from src.interface.IGra import IGra
from src.proxy.GraProxy import GraProxy
from src.Wizualizator import Wizualizator
from src.KontrolerWiadomosci import KontrolerWiadomosci

from unittest.mock import MagicMock


class MockMain(Main):
    def __init__(self):
        super()


class TestScenariuszowy:
    def setup_method(self):
        pygame.init()
        pygame.font.init()
        os.environ["SDL_VIDEO_CENTERED"] = "1"

        self.font = pygame.font.Font(None, 20)
        self.wizualizator = Wizualizator()

        self.kontroler_wiadomosci = KontrolerWiadomosci(self.font, self.wizualizator)
        self.okno = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        self.liczba_graczy = 2
        self.lista_nazw_graczy = ["test1", "test2"]

        self.szerokosc = 1200
        self.wysokosc = 800

        self.mock_main = MockMain()

        self.gra = GraProxy(
            Gra(
                self.okno,
                self.kontroler_wiadomosci,
                self.liczba_graczy,
                self.lista_nazw_graczy,
                self.wizualizator,
                self.szerokosc,
                self.wysokosc,
                self.mock_main
            )
        )

    def test_kolejnosc_gracz(self):
        lista_graczy_z_gry: Gracz = self.gra.pobierz_instancje_gry()._gracze
        lista_graczy_z_konstruktora: [str] = self.lista_nazw_graczy

        for (gracz_z_gry, gracz_z_listy) in zip(lista_graczy_z_gry, lista_graczy_z_konstruktora):
            assert gracz_z_gry.id is gracz_z_listy


    # Scenariusz 1
    # def test_scenariusz_jeden(self):
    #     self.gra.dodaj_zdarzenie_do_kolejki()

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\smoke\test_smoke.py
import time

import pytest
import pygame

from Main import Main
from src.KontrolerWiadomosci import KontrolerWiadomosci
from src.Wizualizator import Wizualizator
from src.Gra import Gra


class MockMain(Main):
    def __init__(self):
        super()


class TestSmoke:
    def setup_method(self):
        pygame.init()
        pygame.font.init()

        time.sleep(3)

        self.wizualizator = Wizualizator()
        self._screen = pygame.display.set_mode((1200, 660), pygame.RESIZABLE)
        self._screen_info = pygame.display.Info()
        self._screen_width = self._screen_info.current_w
        self._screen_height = self._screen_info.current_h
        self.kontroler_wiadomosci = KontrolerWiadomosci(None, self.wizualizator)
        self.liczba_graczy = 2
        self.gracze = ["test_1", "test_2"]
        self.mock_main = MockMain()

        self.gra = Gra(self._screen, self.kontroler_wiadomosci, self.liczba_graczy, self.gracze, self.wizualizator, self._screen_width, self._screen_height, self.mock_main)

    def test_inicjalizacji(self):
        assert isinstance(self.gra._glowne_okno, (pygame.Surface, pygame.SurfaceType))
        assert isinstance(self.gra._gracze, list)
        assert isinstance(self.gra.wizualizator, Wizualizator)
        assert isinstance(self.gra._kontroler_wiadomosci, KontrolerWiadomosci)

    MIN_LICZBA_GRACZY = 2
    MAX_LICZBA_GRACZY_PRAWOSTRONNIE_OTWARTY = 6

    @pytest.mark.parametrize("liczba_graczy", list(range(MIN_LICZBA_GRACZY, MAX_LICZBA_GRACZY_PRAWOSTRONNIE_OTWARTY)))
    def test_liczba_graczy(self, liczba_graczy):
        nazwy_graczy = []

        gracz_id = 0
        while gracz_id < liczba_graczy:
            nazwy_graczy.append(str(f"test_{gracz_id}"))
            gracz_id += 1

        gra = Gra(self._screen, self.kontroler_wiadomosci, liczba_graczy, nazwy_graczy, self.wizualizator, self._screen_width, self._screen_height, MockMain())

        gra.tura()

    def test_tura_jednego_gracza(self):
        self.gra.tura()

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_AkcjaStatystykOkno.py
from src.okno.AkcjaStatystykOkno import AkcjaStatystykOkno, MAKSYMALNA_DLUGOSC_NAZWY_GRACZA


class TestAkcjaStatystykOkno:
    def setup_method(self):
        pass

    def test_sprawdz_czy_nazwa_gracza_nie_za_dluga_jest_za_dluga(self):
        AkcjaStatystykOkno.sprawdz_czy_nazwa_gracza_nie_za_dluga(self, nazwa='{message: <{width}}'.format(
            message=' ',
            width=MAKSYMALNA_DLUGOSC_NAZWY_GRACZA + 1,
        ))

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_AkcjaZastawOkno.py
import pygame
import pytest

from src.Wizualizator import Wizualizator
from src.Gracz import Gracz
from src.okno.AkcjaZastawOkno import AkcjaZastawOkno
from unittest.mock import MagicMock


class TestAkcjaZastawOkno:
    def setup_method(self):
        pygame.init()

        mock_gra = MagicMock()
        mock_gra.wizualizator = Wizualizator()

        self.akcja_zastaw_okno = AkcjaZastawOkno(gra=mock_gra)

    def test_typ_zmiennych_zainicjalizowanych(self):
        assert isinstance(self.akcja_zastaw_okno.gracz, (type(None), Gracz))
        assert isinstance(self.akcja_zastaw_okno.czy_zastaw, bool)
        assert isinstance(self.akcja_zastaw_okno.zastaw_png, (pygame.Surface | pygame.SurfaceType))

    @pytest.mark.xfail(reason="Po ustawieniu gracza, gracz nie moze byc typu None")
    def test_czy_gracz_null(self):
        event = pygame.event.Event(type=pygame.MOUSEBUTTONDOWN)
        self.akcja_zastaw_okno.aktualizacja_zdarzen(event)

        assert self.akcja_zastaw_okno.gracz is not None

    @pytest.mark.xfail(reason="Gracz nie moze byc typu None, podczas wykonywania akcja na nim")
    def test_zastaw_gracz_none(self):
        self.akcja_zastaw_okno.gracz = None
        self.akcja_zastaw_okno.gracz.zastaw_posiadlosci()

    @pytest.mark.skip
    def test_klik_event_zastaw(self):
        # magic mock here
        pass

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Gra.py
import os
import pytest
import pygame

from src.Wizualizator import Wizualizator
from src.proxy.GraProxy import GraProxy
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci


# Komenda aby uruchomic testy: python -m pytest ./tests
class TestGra:
    def setup_method(self):
        pygame.init()
        pygame.font.init()
        os.environ["SDL_VIDEO_CENTERED"] = "1"
        self.font = pygame.font.Font(None, 20)
        self.wizualizator = Wizualizator()

        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font, self.wizualizator)
        self._screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        liczba_graczy = 2
        lista_nazw_graczy = ["test1", "test2"]
        self.gra = GraProxy(
            Gra(
                self._screen,
                self._kontroler_wiadomosci,
                liczba_graczy,
                lista_nazw_graczy,
                self.wizualizator,
                1200,
                800,
                self,
            )
        )

    # ten test powinien wyrzucić wyjątek, "out of index"
    # Podawany event w metodzie gra.aktualizacja_zdarzen(event), event= jest rowny None, poniewaz korzystamy z wewnetrznie zorganizowanej kolejki eventow
    # python -m pytest ./tests -k "test_no_players_quantity_given"
    @pytest.mark.xfail
    def test_brak_podanej_ilosci_graczy(self):
        try:
            self.gra.dodaj_zdarzenie_do_kolejki(event=pygame.event.Event(pygame.KEYDOWN, {"unicode": 32, "key": pygame.K_SPACE}))
            self.gra.pozwol_wykonac_zdarzenie_z_kolejki()
            self.gra.aktualizacja_zdarzenia(event=None)
        except Exception as e:
            pytest.fail(f"Test nie powinien rzucac wyjatku, problem ze spacja na poczatku gry! {e}")


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Gracz.py
import pytest

from src.Gracz import Gracz, UMIEJETNOSC_ZMIEJSZENIA_CZYNSZU_O
from unittest.mock import MagicMock, patch


class MockKontrolerWiadomosci:
    def dodaj_wiadomosc(self):
        pass


class MockWlasciciel:
    def dodaj_pieniadze(self, gra, czynsz):
        pass


class MockPosiadlosc:
    NAZWA = "mock_posiadlosc"
    DOMYSLNA_ZASTAW_KWOTA = 2_000
    DOMYSLNA_CZYNSZ_KWOTA = 1_000

    def __init__(self):
        self.cz_zastawiona: bool
        self.zastaw_kwota = MockPosiadlosc.DOMYSLNA_ZASTAW_KWOTA
        self.nazwa = MockPosiadlosc.NAZWA
        self.wlasciciel = MockWlasciciel()

    def oblicz_czynsz(self, czynsz):
        return MockPosiadlosc.DOMYSLNA_CZYNSZ_KWOTA


class MockAkcjaZastawOkno:
    def __init__(self):
        self.czy_zdejmij_zestaw: bool


class TestGracz:
    DOMYSLNE_ID = 0
    DOMYSLNA_KWOTA = 10_000
    DOMYSLNA_UMIEJETNOSC = "none"

    def setup_method(self):
        self.gracz = Gracz(TestGracz.DOMYSLNE_ID, TestGracz.DOMYSLNA_KWOTA, MagicMock(), TestGracz.DOMYSLNA_UMIEJETNOSC)

    def test_umiejetnosc_wiecej_pieniedzy_na_start(self):
        umiejetnosc = "wiecej_pieniedzy_na_start"
        gracz = Gracz(0, TestGracz.DOMYSLNA_KWOTA, MagicMock(), umiejetnosc)

        nowa_kwota = gracz.kwota

        assert TestGracz.DOMYSLNA_KWOTA < nowa_kwota

    def test_umiejetnosc_karta_wyjscia_z_wiezienia(self):
        umiejetnosc = "karta_wyjscia_z_wiezienia"
        gracz = Gracz(0, TestGracz.DOMYSLNA_KWOTA, MagicMock(), umiejetnosc)

        stara_liczba_kart_wyjdz_z_wiezienia = 0
        nowa_liczba_kart_wyjdz_z_wiezienia = gracz.liczba_kart_wyjdz_z_wiezienia

        assert stara_liczba_kart_wyjdz_z_wiezienia < nowa_liczba_kart_wyjdz_z_wiezienia

    def test_zastaw_posiadlosc(self):
        mock_gra = MagicMock()
        mock_posiadlosc = MockPosiadlosc()

        self.gracz.lista_posiadlosci.append(mock_posiadlosc)
        numer_ostatniej_posiadlosci = len(self.gracz.lista_posiadlosci) - 1

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            przewidywana_nowa_liczba_zastawionych = 1
            przewidywana_nowa_kwota = self.gracz.kwota

            self.gracz.zastaw_posiadlosci(mock_gra, numer_ostatniej_posiadlosci)

            przewidywana_nowa_kwota += MockPosiadlosc.DOMYSLNA_ZASTAW_KWOTA

            nowa_kwota_gracza = self.gracz.kwota
            nowa_liczba_zastawionych_gracza = self.gracz.liczba_zastawionych

            assert przewidywana_nowa_liczba_zastawionych == nowa_liczba_zastawionych_gracza
            assert przewidywana_nowa_kwota == nowa_kwota_gracza

    def test_zdejmij_zastaw_liczba_zastawionych_zero(self):
        mock_gra = MagicMock()

        with (patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci),
              patch.object(mock_gra, 'akcja_zastaw_okno', new=MockAkcjaZastawOkno)):
            self.gracz.zdejmij_zastaw_posiadlosci(mock_gra)

            assert mock_gra.akcja_zastaw_okno.czy_zdejmij_zastaw is False

    def test_zdejmij_zastaw_liczba_zastawionych_rozna_od_zera(self):
        mock_gra = MagicMock()

        with (patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci),
              patch.object(mock_gra, 'akcja_zastaw_okno', new=MockAkcjaZastawOkno)):
            mock_posiadlosc = MockPosiadlosc()

            self.gracz.lista_posiadlosci.append(mock_posiadlosc)
            numer_ostatniej_posiadlosci = len(self.gracz.lista_posiadlosci) - 1

            self.gracz.zastaw_posiadlosci(mock_gra, numer_ostatniej_posiadlosci)
            self.gracz.zdejmij_zastaw_posiadlosci(mock_gra)

        przewidywana_kwota_gracza = MockPosiadlosc.DOMYSLNA_ZASTAW_KWOTA + TestGracz.DOMYSLNA_KWOTA - MockPosiadlosc.DOMYSLNA_ZASTAW_KWOTA * 1.2
        nowa_kwota_gracza = self.gracz.kwota

        assert nowa_kwota_gracza == przewidywana_kwota_gracza

    def test_zaplac_czynsz_posiada_umiejetnosc_placi_mniejsze_czynsze(self):
        umiejetnosci = "placi_mniejsze_czynsze"
        gracz = Gracz(TestGracz.DOMYSLNE_ID, TestGracz.DOMYSLNA_KWOTA, MagicMock(), umiejetnosci)

        mock_gra = MagicMock()

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            gracz.zaplac_czynsz(mock_gra, MockPosiadlosc())

            # Ktos dodaj 2k?
            przewidywana_nowa_kwota_gracza = TestGracz.DOMYSLNA_KWOTA - (MockPosiadlosc.oblicz_czynsz(MockPosiadlosc, None) - UMIEJETNOSC_ZMIEJSZENIA_CZYNSZU_O + 2000)

            assert przewidywana_nowa_kwota_gracza == gracz.kwota

    @pytest.mark.parametrize("kwota_dodana", [5_000, -5_000, 0, 1, -1, -0])
    def test_dodaj_pieniadze_dodatnia(self, kwota_dodana):
        mock_gra = MagicMock()

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            self.gracz.dodaj_pieniadze(mock_gra, kwota_dodana)

            przewidywana_nowa_kwota_gracza = TestGracz.DOMYSLNA_KWOTA + kwota_dodana

            assert self.gracz.kwota == przewidywana_nowa_kwota_gracza

    def test_czy_przeszedl_przez_start_posiada_umiejetnosc_dostaje_wiecej_za_przejscie_przez_start(self):
        mock_gra = MagicMock()

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            mock_pionek = MagicMock()
            mock_pionek.numer_pola = 10
            stara_pozycja = 20
            umiejetnosc = "dostaje_wiecej_za_przejscie_przez_start"

            gracz = Gracz(TestGracz.DOMYSLNE_ID, TestGracz.DOMYSLNA_KWOTA, mock_pionek, umiejetnosc)
            stara_kwota_gracza = gracz.kwota

            gracz.czy_przeszedl_przez_start(mock_gra, stara_pozycja)

            assert stara_kwota_gracza + 2200 == gracz.kwota

    def test_czy_przeszedl_przez_start_nie_posiada_umiejetnosc_dostaje_wiecej_za_przejscie_przez_start(self):
        mock_gra = MagicMock()

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            mock_pionek = MagicMock()
            mock_pionek.numer_pola = 10
            stara_pozycja = 20
            umiejetnosc = "none"

            gracz = Gracz(TestGracz.DOMYSLNE_ID, TestGracz.DOMYSLNA_KWOTA, mock_pionek, umiejetnosc)
            stara_kwota_gracza = gracz.kwota

            gracz.czy_przeszedl_przez_start(mock_gra, stara_pozycja)

            assert stara_kwota_gracza + 2000 == gracz.kwota

    def test_czy_przeszedl_przez_start_nie_przeszedl(self):
        mock_gra = MagicMock()

        with patch.object(mock_gra, '_kontroler_wiadomosci', new=MockKontrolerWiadomosci):
            mock_pionek = MagicMock()
            mock_pionek.numer_pola = 10
            self.gracz.pionek = mock_pionek

            stara_pozycja = 5

            stara_kwota_gracza = self.gracz.kwota
            self.gracz.czy_przeszedl_przez_start(mock_gra, stara_pozycja)

            assert stara_kwota_gracza == self.gracz.kwota

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_KartaSzansy.py
from src.KartaSzansy import KartaSzansy


class TestKartaSzansy:
    def setup_method(self):
        pass

C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_KontrolerWiadomosci.py
import pytest
import pygame

from unittest.mock import MagicMock

from src.Wizualizator import Wizualizator
from src.KontrolerWiadomosci import KontrolerWiadomosci


class TestKontrolerWiadomosci:
    def setup_method(self):
        pygame.font.init()

        self.kontroler = KontrolerWiadomosci(MagicMock(), Wizualizator())

    podwojna_ilosc_maksymalnych_wiadomosci = KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI * 2

    @staticmethod
    def _dodaj_nowe_wiadomosci_do_kontrolera(kontroler: KontrolerWiadomosci, liczba_wiadomosc: int):
        numer = 0

        while numer < liczba_wiadomosc:
            kontroler.dodaj_wiadomosc(str(numer))
            numer += 1

    def test_typy_zmiennych_zainicjalizowane(self):
        assert isinstance(self.kontroler.wizualizator, Wizualizator)
        assert isinstance(self.kontroler.wiadomosci, list)
        assert isinstance(self.kontroler.font, pygame.font.Font)

    @pytest.mark.parametrize("numer_wiadomosci", list(range(0, podwojna_ilosc_maksymalnych_wiadomosci)))
    def test_dodaj_wiadomosc_ilosc_wiadomosci(self, numer_wiadomosci):
        self._dodaj_nowe_wiadomosci_do_kontrolera(self.kontroler, numer_wiadomosci)

        przewidywana_ilosc_wiadomosci = min(numer_wiadomosci, KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI)
        ilosc_wiadomosci_w_kontrolerze = self.kontroler.ilosc_wiadomosci

        assert przewidywana_ilosc_wiadomosci == ilosc_wiadomosci_w_kontrolerze

    poczworna_ilosc_maksymalnych_wiadomosci = KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI * 2

    @pytest.mark.parametrize("numer_wiadomosci", list(range(0, poczworna_ilosc_maksymalnych_wiadomosci)))
    def test_dodaj_wiadomosc_index_ostatniej_wiadomosci(self, numer_wiadomosci):
        self._dodaj_nowe_wiadomosci_do_kontrolera(self.kontroler, numer_wiadomosci)

        przewidywany_index_ostatniej_wiadomosci = numer_wiadomosci % KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI if self.kontroler.ilosc_wiadomosci >= KontrolerWiadomosci.MAKSYMALNA_ILOSC_WIADOMOSCI else 0
        rzeczywisty_ostatni_index_wiadomosci = self.kontroler.ostatnia_pozycyjnie_wiadomosc_index

        assert przewidywany_index_ostatniej_wiadomosci == rzeczywisty_ostatni_index_wiadomosci

    @pytest.mark.parametrize("numer_wiadomosci", list(range(0, podwojna_ilosc_maksymalnych_wiadomosci)))
    def test_usun_wszystkie_wiadomosci(self, numer_wiadomosci):
        self._dodaj_nowe_wiadomosci_do_kontrolera(self.kontroler, numer_wiadomosci)

        self.kontroler.usun_wszystkie_wiadomosci()

        ilosc_wiadomosci_w_liscie = len(self.kontroler.wiadomosci)
        ilosc_wiadomosci_atrybut = self.kontroler.ilosc_wiadomosci
        index_ostatniej_wiadomosci = self.kontroler.ostatnia_pozycyjnie_wiadomosc_index

        przewidywana_wartosc_dla_wszystkich = 0

        # symbol "\" powoduje możliwość zapisu zmiennej w nowej linijce
        assert ilosc_wiadomosci_w_liscie == ilosc_wiadomosci_atrybut == index_ostatniej_wiadomosci ==\
               przewidywana_wartosc_dla_wszystkich


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Pionek.py
import pytest
from src.Pionek import Pionek
from src.Plansza import Plansza
from unittest.mock import MagicMock, patch


class MockPlansza:
    def __init__(self):
        self.plansza = Plansza.inicializacja_planszy()


# Komenda aby uruchomic testy: python -m pytest ./tests
class TestPionek:
    def setup_method(self):
        self.pionek = MagicMock()
        self.pionek.numer_pola = 0
        self.pionek.przesun = Pionek.przesun
        # Pozniej dodaj "mock object"

    @pytest.mark.parametrize("liczba_pol", list(range(Pionek.MIN_LICZBA_OCZEK, Pionek.MAX_LICZBA_OCZEK)))
    def test_ruch_prawidlowa_ilosc_oczek(self, liczba_pol):
        mock_gra = MagicMock()
        mock_plansza = MockPlansza()

        with patch.object(mock_gra, '_plansza', new=mock_plansza):
            assert self.pionek.przesun(self.pionek, liczba_pol, mock_gra) is True

    @pytest.mark.parametrize("liczba_pol", [-1, -2, -50, -100])
    def test_ruch_nieprawidlowa_ilosc_oczek(self, liczba_pol):
        mock_gra = MagicMock()
        mock_plansza = MockPlansza()

        with patch.object(mock_gra, '_plansza', new=mock_plansza):
            assert self.pionek.przesun(self.pionek, liczba_pol, mock_gra) is False


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Plansza.py
import pygame
import pytest

from src.Pole import Pole
from src.Plansza import Plansza


class TestPlansza:
    def setup_method(self):
        pygame.init()

        self.plansza = Plansza()

    def test_typow_klasy_plansza(self):
        assert isinstance(self.plansza.plansza, list)

    @pytest.mark.parametrize("numer_pola", list(range(0, 40)))
    def test_pobierz_pole_poprawny_zakres(self, numer_pola):
        rezultat_pole = self.plansza.pobierz_pole(numer_pola)

        assert isinstance(rezultat_pole, Pole)

    @pytest.mark.parametrize("numer_pola", [-2, -1, -100, 41, 42, 50, 100, 1000])
    def test_pobierz_pole_niepoprawny_zakres(self, numer_pola):
        with pytest.raises(Exception):
            rezultat = self.plansza.pobierz_pole(numer_pola)

    def test_wczytaj_grafiki(self):
        path = "graphics/pola/pole_"
        extension = ".png"
        nr_pola = 0

        self.plansza.wczytaj_grafiki()

        for pole in self.plansza.plansza:
            tekst_sciezki = (path + str(nr_pola) + extension)
            nr_pola += 1

            assert pole.sciezka_do_grafiki == tekst_sciezki


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_PodatekDochodowy.py
import pygame
import pytest

from src.PodatekDochodowy import PodatekDochodowy


class TestPodatekDochodowy:
    DOMYSLNA_KWOTA = 1000

    def setup_method(self):
        self.podatek_dochodowy = PodatekDochodowy(0, TestPodatekDochodowy.DOMYSLNA_KWOTA)

    def test_typ_zmiennych(self):
        assert isinstance(self.podatek_dochodowy.podatek, int)
        assert self.podatek_dochodowy.typ == "Podatek dochodowy"

    @pytest.mark.skip
    def test_wyswietl_info(self):
        informacja_zwrotna = self.podatek_dochodowy.wyswietl_info()
        oczekiwany_tekst = f"Stanąłeś na polu podatek dochodowy. Musisz zapłacić podatek w wysokości {TestPodatekDochodowy.DOMYSLNA_KWOTA}"

        assert oczekiwany_tekst == informacja_zwrotna

    @pytest.mark.skip
    def test_zaplac_podatek_poprawna_odpowiedz_wystarczajaca_kwota(self):
        pass


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Pole.py
import pygame
import pytest

from src.Pole import Pole, Vector2, KierunekPol


def numery_malych_pol():
    male_pola = filter(lambda numer_pola: numer_pola % 10 != 0, list(range(0, Pole.MAKSYMALNA_LICZBA_POL)))

    return male_pola


class TestPole:
    DOMYSLNY_NUMER_POLA = 10

    def setup_method(self):
        self.typ_pole = "test_typ"
        self.pole = Pole(TestPole.DOMYSLNY_NUMER_POLA, self.typ_pole)

    @pytest.mark.parametrize("maksymalna_liczba_pol", list(range(0, len(KierunekPol) * Pole.DLUGOSC_SCIANY_W_POLACH)))
    def test_oblicz_zwrot_naglowka_pola_rzuca_wyjatek_niepoprawna_maksymalna_liczba_pol_za_mala(self, maksymalna_liczba_pol):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(TestPole.DOMYSLNY_NUMER_POLA, Pole.DLUGOSC_SCIANY_W_POLACH, maksymalna_liczba_pol)


    dodatkowa_sztuczna_ilosc_pol = 10

    @pytest.mark.parametrize("maksymalna_liczba_pol", list(range(len(KierunekPol) * Pole.DLUGOSC_SCIANY_W_POLACH + 1, (len(KierunekPol) + dodatkowa_sztuczna_ilosc_pol) * Pole.DLUGOSC_SCIANY_W_POLACH)))
    def test_oblicz_zwrot_naglowka_pola_rzuca_wyjatek_niepoprawna_maksymalna_liczba_pol_za_duza(self, maksymalna_liczba_pol):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(TestPole.DOMYSLNY_NUMER_POLA, Pole.DLUGOSC_SCIANY_W_POLACH, maksymalna_liczba_pol)

    def test_oblicz_zwrot_naglowka_pola_niepoprawna_maksymalna_liczba_pol_dzielnie_zero(self):
        with pytest.raises(Exception):
            wynik = Pole.oblicz_zwrot_naglowka_pola(10, dlugosc_sciany_w_polach=0, maksymalna_liczba_pol=Pole.MAKSYMALNA_LICZBA_POL)

    @pytest.mark.parametrize("numer_malego_pola", numery_malych_pol())
    def test_oblicz_zwrot_naglowka_pola_poprawna_male_wymiary(self, numer_malego_pola):
        # Aby zwrocilo male wymiary pola, numer pola nie może byc wielokrotnoscia dlugosc_sciany_w_polach
        wynikowe_wymiary = Pole.oblicz_rozmiar_pola(numer_malego_pola, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)

        assert wynikowe_wymiary == Pole.MALE_POLE_WYMIARY

    @pytest.mark.parametrize("numer_duzego_pola", list(range(0, len(KierunekPol), Pole.DLUGOSC_SCIANY_W_POLACH)))
    def test_oblicz_rozmiar_pola_poprawna_duze_wymiary(self, numer_duzego_pola):
        # Aby zwrocilo duze wymiary pola, numer pola musi byc wielokrotnoscia dlugosc_sciany_w_polach
        wynikowe_wymiary = Pole.oblicz_rozmiar_pola(numer_duzego_pola, Pole.DLUGOSC_SCIANY_W_POLACH, Pole.MAKSYMALNA_LICZBA_POL)

        assert wynikowe_wymiary == Pole.DUZE_POLE_WYMIARY

    def test_oblicz_rozmiar_pola(self):
        pass

    def test_inicjalizacja_pozycji(self):
        pass

    def test_typ_zmiennych_konstruktora(self):
        assert isinstance(self.pole.numer, int)
        assert isinstance(self.pole.typ, str)
        assert isinstance(self.pole.wymiary, Vector2)
        assert isinstance(self.pole.kierunek_sciany, KierunekPol)
        assert isinstance(self.pole.pozycja, Vector2)
        assert isinstance(self.pole.sciezka_do_grafiki, str)

    @pytest.mark.skip(reason="Not yet implemented path checking")
    def test_sciezka_do_grafiki(self):
        pass

    def test_zwroc_info(self):
        przewidywany_tekst = f"Nazwa: {self.typ_pole}"
        zwrocony_tekst = self.pole.zwroc_info()

        assert przewidywany_tekst == zwrocony_tekst



C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Posiadlosc.py
import pygame
import pytest
from unittest.mock import Mock, patch, MagicMock

from src.Pionek import Pionek
from src.Wizualizator import Wizualizator
from src.Posiadlosc import Posiadlosc
from src.Gracz import Gracz
from src.Gra import Gra
from src.KontrolerWiadomosci import KontrolerWiadomosci


# TODO: Zmiana typu z kolor: str na pygame.Color


class TestPosiadlosc:
    NUMER = 0
    NAZWA = "test"
    KOLOR = "czarny"
    CENA = 500
    CZYNSZ = 500
    ZASTAW = 500
    CENA_DOMU = 0

    def setup_method(self):
        pygame.init()
        # przepisz na mocki
        self.font = pygame.font.Font(None, 20)
        self.screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)
        self.wizualizator = Wizualizator()

        self._kontroler_wiadomosci = KontrolerWiadomosci(self.font, self.wizualizator)

        liczba_graczy = 2
        nazwy_graczy = ["test1", "test2"]
        szerokosc_ekranu = 1200
        wysokosc_ekranu = 660
        self._gra = Gra(
            self.screen,
            self._kontroler_wiadomosci,
            liczba_graczy,
            nazwy_graczy,
            self.wizualizator,
            szerokosc_ekranu,
            wysokosc_ekranu,
            self,
        )

        self.posiadlosc = Posiadlosc(
            TestPosiadlosc.NUMER,
            TestPosiadlosc.NAZWA,
            TestPosiadlosc.KOLOR,
            TestPosiadlosc.CENA,
            TestPosiadlosc.CZYNSZ,
            TestPosiadlosc.ZASTAW,
            TestPosiadlosc.CENA_DOMU,
        )

    def test_inicjalizacja_typow(self):
        assert isinstance(self.posiadlosc.nazwa, str)
        assert isinstance(self.posiadlosc.kolor, str)
        assert isinstance(self.posiadlosc.cena, int)
        assert isinstance(self.posiadlosc.zastaw_kwota, int)
        assert isinstance(self.posiadlosc.cena_domu, int)
        assert isinstance(self.posiadlosc.wlasciciel, (None | Gracz)) is True
        assert isinstance(self.posiadlosc.czy_zastawiona, bool)
        assert isinstance(self.posiadlosc.liczba_domow, int)
        assert isinstance(self.posiadlosc.liczba_hoteli, int)

    @pytest.mark.parametrize("liczba_domow", (0, 1, 2))
    def test_zwroc_info(self, liczba_domow):
        self.posiadlosc.liczba_domow = liczba_domow

        zwrocone_info = self.posiadlosc.zwroc_info()
        przewidywane_info = (
            (f"Nazwa: {TestPosiadlosc.NAZWA},  Cena: {TestPosiadlosc.CENA}")
            if liczba_domow > 0
            else (f"Nazwa: {TestPosiadlosc.NAZWA},  Cena: {TestPosiadlosc.CENA}")
        )

        assert zwrocone_info == przewidywane_info

    def test_kup_posiadlosc_udany(self):
        mock_pionek = MagicMock()
        mock_pionek.sciezka_do_grafiki = "123451234512345123451234512345"
        kwota_poczatkowa = 10_000
        gracz = Gracz(0, kwota_poczatkowa, mock_pionek, "test_umiejetnosc")

        self.posiadlosc.kup_posiadlosc(self._gra, gracz)

        kwota_gracza_po_zakupie = gracz.kwota
        przewidywana_kwota_po_zakupie = kwota_poczatkowa - TestPosiadlosc.CENA

        assert przewidywana_kwota_po_zakupie == kwota_gracza_po_zakupie


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Przycisk.py
import pytest
import pygame
from typing import Collection

from src.Przycisk import Przycisk


class TestPrzycisk:
    PRZYCISK_POS_X = 100
    PRZYCISK_POS_Y = 100
    PRZYCISK_SZEROKOSC = 100
    PRZYCISK_WYSOKOSC = 100

    LEWO_GORA = (PRZYCISK_POS_X, PRZYCISK_POS_Y)
    LEWO_DOL = (PRZYCISK_POS_X, PRZYCISK_POS_Y + PRZYCISK_WYSOKOSC - 1)
    PRAWO_GORA = (PRZYCISK_POS_X + PRZYCISK_SZEROKOSC - 1, PRZYCISK_POS_Y)
    PRAWO_DOL = (PRZYCISK_POS_X + PRZYCISK_SZEROKOSC - 1, PRZYCISK_POS_Y + PRZYCISK_WYSOKOSC - 1)

    def setup_method(self):
        pygame.init()
        # pygame.font.init()

        self.screen = pygame.display.set_mode((1200, 800), pygame.RESIZABLE)

        self.przycisk = Przycisk(TestPrzycisk.PRZYCISK_POS_X, TestPrzycisk.PRZYCISK_POS_Y,
                                 TestPrzycisk.PRZYCISK_SZEROKOSC, TestPrzycisk.PRZYCISK_WYSOKOSC,
                                 pygame.color.THECOLORS["green"],
                                 pygame.color.THECOLORS["violet"],
                                 "TestPrzycisk",
                                 pygame.color.THECOLORS["blue"])

    def test_inicjalizacja_typow_zmiennych(self):
        assert type(self.przycisk.rect) is pygame.Rect
        assert isinstance(self.przycisk.color, (pygame.color.Color, Collection)) is True
        assert isinstance(self.przycisk.hover_color, (pygame.color.Color, Collection)) is True
        assert type(self.przycisk.font) is pygame.font.Font

    def test_is_clicked_wewnatrz_przycisku(self):
        pozycja_klikniecia = (TestPrzycisk.PRZYCISK_POS_X + TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                              TestPrzycisk.PRZYCISK_POS_Y + TestPrzycisk.PRZYCISK_WYSOKOSC // 2)
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is True

    def test_is_clicked_zewnatrz_przycisku(self):
        pozycja_klikniecia = (TestPrzycisk.PRZYCISK_POS_X - TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                              TestPrzycisk.PRZYCISK_POS_Y - TestPrzycisk.PRZYCISK_WYSOKOSC // 2)
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is False

    # odpowiednio: lewo-gora, prawo-dol, lewo-dol, prawo-gora
    @pytest.mark.parametrize("pozycja_klikniecia", [LEWO_GORA, LEWO_DOL, PRAWO_GORA, PRAWO_DOL])
    def test_is_clicked_na_granicach_przycisku(self, pozycja_klikniecia):
        result_click = self.przycisk.is_clicked(pygame.event.Event(pygame.MOUSEBUTTONDOWN, {
            "button": 1,
            "pos": pozycja_klikniecia
        }))

        assert result_click is True

    # Zmiana w display na HIDDEN sprawia ze ten nie przechodzi, testowany na RESIZABLE
    def test_hover_kolor(self):
        kursor_pozycja_w_przycisku = (TestPrzycisk.PRZYCISK_POS_X + TestPrzycisk.PRZYCISK_SZEROKOSC // 8,
                                      TestPrzycisk.PRZYCISK_POS_Y + TestPrzycisk.PRZYCISK_WYSOKOSC // 8)

        pygame.mouse.set_pos(kursor_pozycja_w_przycisku)
        self.przycisk.draw(self.screen)

        przycisk_tlo_kolor = self.screen.get_at(kursor_pozycja_w_przycisku)

        assert (przycisk_tlo_kolor == self.przycisk.hover_color)

    def test_napis_kolor(self):
        kursor_pozycja_w_przycisku = (TestPrzycisk.PRZYCISK_POS_X + TestPrzycisk.PRZYCISK_SZEROKOSC // 2,
                                      TestPrzycisk.PRZYCISK_POS_Y + TestPrzycisk.PRZYCISK_WYSOKOSC // 2)

        pygame.mouse.set_pos(kursor_pozycja_w_przycisku)
        self.przycisk.draw(self.screen)

        przycisk_napis_kolor = self.screen.get_at(kursor_pozycja_w_przycisku)

        assert (przycisk_napis_kolor == self.przycisk.text_color)

    @pytest.mark.parametrize("pozycja_kursora", [LEWO_GORA, LEWO_DOL, PRAWO_GORA, PRAWO_DOL])
    def test_kolor_brzegi_przycisku(self, pozycja_kursora: tuple):
        pygame.mouse.set_pos(pozycja_kursora)
        self.przycisk.draw(self.screen)

        przycisk_tlo_kolor = self.screen.get_at(pozycja_kursora)

        assert (przycisk_tlo_kolor == self.przycisk.hover_color)

    # Uwaga na wymiary, nie dawać wartości równych, defaultowych!
    @pytest.mark.parametrize("wymiary", [(10, 10), (110, 110)])
    def test_updateSize_zgodne_wymiary(self, wymiary: tuple):
        poprzednie_wymiary = self.przycisk.pobierz_wymiary()

        self.przycisk.updateSize(TestPrzycisk.PRZYCISK_POS_X,
                                 TestPrzycisk.PRZYCISK_POS_Y,
                                 wymiary[0], wymiary[1])

        nowe_wymiary = self.przycisk.pobierz_wymiary()

        assert poprzednie_wymiary.width != nowe_wymiary.width
        assert poprzednie_wymiary.height != nowe_wymiary.height
        assert wymiary[0] == nowe_wymiary.width
        assert wymiary[1] == nowe_wymiary.height

    @pytest.mark.parametrize("wymiary", [(0, 0), (-5, -10), (-2, 10), (20, -43)])
    def test_updateSize_niezgodne_wymiary(self, wymiary: tuple):
        poprzednie_wymiary = self.przycisk.pobierz_wymiary()

        self.przycisk.updateSize(TestPrzycisk.PRZYCISK_POS_X,
                                 TestPrzycisk.PRZYCISK_POS_Y,
                                 wymiary[0], wymiary[1])

        nowe_wymiary = self.przycisk.pobierz_wymiary()

        assert poprzednie_wymiary.width == nowe_wymiary.width
        assert poprzednie_wymiary.height == nowe_wymiary.height
        assert wymiary[0] != nowe_wymiary.width
        assert wymiary[1] != nowe_wymiary.height


C:\Users\barte\OneDrive\Pulpit\Studia\ROK II\Semestr 4\IO\ProjektFUN\Monopoly_IO_UJ\tests\unit\test_Statystyka.py
from src.Statystyka import Statystyka


class TestStatystyka:
    def setup_method(self):
        self.statystyka = Statystyka(1000, "test1")

    def test_aktualizuj_stan_pieniedzy_poprawna_kwota(self):
        nowy_stan_pieniedzy = 2000

        self.statystyka.aktualizuj_stan_pieniedzy(nowy_stan_pieniedzy)

        stan_pieniedzy_po_aktualziacji = self.statystyka.pieniadze

        assert nowy_stan_pieniedzy == stan_pieniedzy_po_aktualziacji

    def test_aktualizuj_stan_pieniedzy_kwota_ujemna(self):
        nowy_stan_pieniedzy = -2000

        self.statystyka.aktualizuj_stan_pieniedzy(nowy_stan_pieniedzy)

        stan_pieniedzy_po_aktualziacji = self.statystyka.pieniadze

        assert (nowy_stan_pieniedzy == stan_pieniedzy_po_aktualziacji)

    def test_dodaj_posiadlosc(self):
        ilosc_posiadlosci_przed_dodaniem = self.statystyka.ilosc_posiadlosci

        self.statystyka.dodaj_posiadlosc()

        ilosc_posiadlosci_po_dodaniu = self.statystyka.ilosc_posiadlosci
        przewidywana_ilosc_posiadlosci = ilosc_posiadlosci_przed_dodaniem + 1

        assert przewidywana_ilosc_posiadlosci == ilosc_posiadlosci_po_dodaniu

    def test_dodaj_hotel_poprawna_ilosc(self):
        ilosc_hoteli_przed_dodaniem = self.statystyka.ilosc_hoteli
        ilosc_nowych_hoteli = 2

        self.statystyka.dodaj_hotel(ilosc_nowych_hoteli)

        ilsoc_hoteli_po_dodaniu = self.statystyka.ilosc_hoteli
        przewidywana_ilosc_hoteli = ilosc_hoteli_przed_dodaniem + ilosc_nowych_hoteli

        assert przewidywana_ilosc_hoteli == ilsoc_hoteli_po_dodaniu

    def test_dodaj_hotel_ujemna_ilosc(self):
        ilosc_hoteli_przed_dodaniem = self.statystyka.ilosc_hoteli
        ilosc_nowych_hoteli_niewlasciwa = -2

        self.statystyka.dodaj_hotel(ilosc_nowych_hoteli_niewlasciwa)

        niepoprawna_ilsoc_hoteli_po_dodaniu = self.statystyka.ilosc_hoteli
        przewidywana_ilosc_hoteli = ilosc_hoteli_przed_dodaniem

        assert przewidywana_ilosc_hoteli != niepoprawna_ilsoc_hoteli_po_dodaniu

    def test_dodaj_domek_poprawna_ilosc(self):
        ilosc_domkow_przed_dodaniem = self.statystyka.ilosc_domkow
        ilosc_nowych_domkow = 2

        self.statystyka.dodaj_domek(ilosc_nowych_domkow)

        ilsoc_domkow_po_dodaniu = self.statystyka.ilosc_domkow
        przewidywana_ilosc_hoteli = ilosc_domkow_przed_dodaniem + ilosc_nowych_domkow

        assert przewidywana_ilosc_hoteli == ilsoc_domkow_po_dodaniu

    def test_dodaj_domek_ujemna_ilosc(self):
        ilosc_domkow_przed_dodaniem = self.statystyka.ilosc_domkow
        ilosc_nowych_domkow_niewlasciwa = -2

        self.statystyka.dodaj_domek(ilosc_nowych_domkow_niewlasciwa)

        niepoprawna_ilsoc_domkow_po_dodaniu = self.statystyka.ilosc_domkow
        przewidywana_ilosc_hoteli = ilosc_domkow_przed_dodaniem

        assert przewidywana_ilosc_hoteli != niepoprawna_ilsoc_domkow_po_dodaniu

    def test_odejmij_domek_poprawna_ilosc(self):
        startowa_ilosc_domkow = 4
        self.statystyka.ilosc_domkow = startowa_ilosc_domkow

        ilosc_domkow_przed_odjeciem = self.statystyka.ilosc_domkow
        ilosc_odjetych_domkow = 2

        self.statystyka.odejmij_domek(ilosc_odjetych_domkow)

        ilsoc_domkow_po_odjeciu = self.statystyka.ilosc_domkow
        przewidywana_ilosc_domkow = ilosc_domkow_przed_odjeciem - ilosc_odjetych_domkow

        assert przewidywana_ilosc_domkow == ilsoc_domkow_po_odjeciu

    def test_odejmij_domek_ujemna_wartosc_domkow(self):
        startowa_ilosc_domkow = 0
        self.statystyka.ilosc_domkow = startowa_ilosc_domkow

        ilosc_domkow_przed_odjeciem = self.statystyka.ilosc_domkow
        ilosc_odjetych_domkow = 2

        self.statystyka.odejmij_domek(ilosc_odjetych_domkow)

        niepoprawna_ilsoc_domkow_po_odjeciu = self.statystyka.ilosc_domkow
        przewidywana_ilosc_domkow = ilosc_domkow_przed_odjeciem

        assert przewidywana_ilosc_domkow != niepoprawna_ilsoc_domkow_po_odjeciu

    def test_odejmij_domek_minusowa_ilosc_odejmowanych(self):
        startowa_ilosc_domkow = 0
        self.statystyka.ilosc_domkow = startowa_ilosc_domkow

        ilosc_domkow_przed_odjeciem = self.statystyka.ilosc_domkow
        ilosc_odjetych_domkow = -2

        self.statystyka.odejmij_domek(ilosc_odjetych_domkow)

        niepoprawna_ilsoc_domkow_po_odjeciu = self.statystyka.ilosc_domkow
        przewidywana_ilosc_domkow = ilosc_domkow_przed_odjeciem

        assert przewidywana_ilosc_domkow != niepoprawna_ilsoc_domkow_po_odjeciu


